import require$$0$7 from 'node:tty';
import require$$1$2 from 'node:util';
import require$$3$2, { readFileSync, writeFileSync, renameSync, chmodSync, rmSync, existsSync, realpathSync, accessSync, constants, statSync, mkdirSync, createWriteStream } from 'node:fs';
import require$$4$2 from 'node:net';
import require$$1$3 from 'node:events';
import require$$0$8, { URL as URL$1 } from 'node:url';
import require$$3$3, { IncomingMessage, createServer as createServer$1 } from 'node:http';
import { createServer } from 'node:https';
import require$$0$9 from 'node:buffer';
import require$$0$a, { dirname, resolve, basename, extname, isAbsolute, join } from 'node:path';
import require$$0$b, { createHash, randomUUID } from 'node:crypto';
import require$$0$c, { tmpdir } from 'node:os';
import require$$1$4 from 'node:stream';
import require$$3$4 from 'node:zlib';
import require$$1$5 from 'node:string_decoder';
import { TLSSocket } from 'node:tls';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var cjs$2;
var hasRequiredCjs$2;
function requireCjs$2() {
  if (hasRequiredCjs$2) return cjs$2;
  hasRequiredCjs$2 = 1;
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  cjs$2 = deepmerge_1;
  return cjs$2;
}

var cjsExports$1 = requireCjs$2();
var deepmerge$1 = /*@__PURE__*/getDefaultExportFromCjs(cjsExports$1);

/** Detect free variable `global` from Node.js. */
var freeGlobal$2 = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();

/** Built-in value references. */
var Symbol$3 = root$2.Symbol;

/** Used for built-in method references. */
var objectProto$l = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$i = objectProto$l.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$5 = objectProto$l.toString;

/** Built-in value references. */
var symToStringTag$5 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$i.call(value, symToStringTag$5),
    tag = value[symToStringTag$5];
  try {
    value[symToStringTag$5] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString$5.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$5] = tag;
    } else {
      delete value[symToStringTag$5];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$k = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$4 = objectProto$k.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$2(value) {
  return nativeObjectToString$4.call(value);
}

/** `Object#toString` result references. */
var nullTag$2 = '[object Null]',
  undefinedTag$2 = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$4 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$2(value) {
  if (value == null) {
    return value === undefined ? undefinedTag$2 : nullTag$2;
  }
  return symToStringTag$4 && symToStringTag$4 in Object(value) ? getRawTag$2(value) : objectToString$2(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$2(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$2 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$2(value) {
  return typeof value == 'symbol' || isObjectLike$2(value) && baseGetTag$2(value) == symbolTag$2;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap$2(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$2 = Array.isArray;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : undefined,
  symbolToString$2 = symbolProto$2 ? symbolProto$2.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$2(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$2(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap$2(value, baseToString$2) + '';
  }
  if (isSymbol$2(value)) {
    return symbolToString$2 ? symbolToString$2.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag$2 = '[object AsyncFunction]',
  funcTag$2 = '[object Function]',
  genTag$2 = '[object GeneratorFunction]',
  proxyTag$2 = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$3(value) {
  if (!isObject$2(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag$2(value);
  return tag == funcTag$2 || tag == genTag$2 || tag == asyncTag$2 || tag == proxyTag$2;
}

/** Used to detect overreaching core-js shims. */
var coreJsData$2 = root$2['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$2 = function () {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$2(func) {
  return !!maskSrcKey$2 && maskSrcKey$2 in func;
}

/** Used for built-in method references. */
var funcProto$6 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$6 = funcProto$6.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$6.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$5 = Function.prototype,
  objectProto$j = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$5 = funcProto$5.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$h = objectProto$j.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative$2 = RegExp('^' + funcToString$5.call(hasOwnProperty$h).replace(reRegExpChar$2, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$2(value) {
  if (!isObject$2(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative$2 : reIsHostCtor$2;
  return pattern.test(toSource$2(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$2(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$2(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative$2(value) ? value : undefined;
}

var defineProperty$1 = function () {
  try {
    var func = getNative$2(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$4 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint$2 = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$4 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint$2.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue$1(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */
var objectProto$i = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$g = objectProto$i.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue$1(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$g.call(object, key) && eq$2(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$3 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$1(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments$1(value) {
  return isObjectLike$2(value) && baseGetTag$2(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$h = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$h.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments$1 = baseIsArguments$1(function () {
  return arguments;
}()) ? baseIsArguments$1 : function (value) {
  return isObjectLike$2(value) && hasOwnProperty$f.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
};

/** Used to match property names within property paths. */
var reIsDeepProp$2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  reIsPlainProp$2 = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$2(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp$2.test(value) || !reIsDeepProp$2.test(value) || object != null && value in Object(object);
}

/* Built-in method references that are verified to be native. */
var nativeCreate$2 = getNative$2(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$2() {
  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$5 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$g.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? undefined : result;
  }
  return hasOwnProperty$e.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== undefined : hasOwnProperty$d.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$2 && value === undefined ? HASH_UNDEFINED$4 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$2(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash$2.prototype.clear = hashClear$2;
Hash$2.prototype['delete'] = hashDelete$2;
Hash$2.prototype.get = hashGet$2;
Hash$2.prototype.has = hashHas$2;
Hash$2.prototype.set = hashSet$2;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype;

/** Built-in value references. */
var splice$2 = arrayProto$2.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$2(key) {
  var data = this.__data__,
    index = assocIndexOf$2(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$2(key) {
  var data = this.__data__,
    index = assocIndexOf$2(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$2(key, value) {
  var data = this.__data__,
    index = assocIndexOf$2(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$2(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache$2.prototype.clear = listCacheClear$2;
ListCache$2.prototype['delete'] = listCacheDelete$2;
ListCache$2.prototype.get = listCacheGet$2;
ListCache$2.prototype.has = listCacheHas$2;
ListCache$2.prototype.set = listCacheSet$2;

/* Built-in method references that are verified to be native. */
var Map$3 = getNative$2(root$2, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash$2(),
    'map': new (Map$3 || ListCache$2)(),
    'string': new Hash$2()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$2(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$2(map, key) {
  var data = map.__data__;
  return isKeyable$2(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$2(key) {
  var result = getMapData$2(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$2(key) {
  return getMapData$2(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$2(key, value) {
  var data = getMapData$2(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$2(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache$2.prototype.clear = mapCacheClear$2;
MapCache$2.prototype['delete'] = mapCacheDelete$2;
MapCache$2.prototype.get = mapCacheGet$2;
MapCache$2.prototype.has = mapCacheHas$2;
MapCache$2.prototype.set = mapCacheSet$2;

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$2(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function () {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$2)();
  return memoized;
}

// Expose `MapCache`.
memoize$2.Cache = MapCache$2;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE$2 = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped$2(func) {
  var result = memoize$2(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE$2) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName$2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar$2 = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$2 = memoizeCapped$2(function (string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName$2, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$2, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$2(value) {
  return value == null ? '' : baseToString$2(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$2(value, object) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath$2(toString$2(value));
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$2(value) {
  if (typeof value == 'string' || isSymbol$2(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet$2(object, path) {
  path = castPath$2(path, object);
  var index = 0,
    length = path.length;
  while (object != null && index < length) {
    object = object[toKey$2(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$3(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet$2(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1,
    length = path.length,
    result = false;
  while (++index < length) {
    var key = toKey$2(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$1(length) && isIndex$2(key, length) && (isArray$2(object) || isArguments$1(object));
}

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$e.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas$1(object, key) {
  return object != null && hasOwnProperty$c.call(object, key);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has$1(object, path) {
  return object != null && hasPath$1(object, path, baseHas$1);
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet$1(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = castPath$2(path, object);
  var index = -1,
    length = path.length,
    lastIndex = length - 1,
    nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$2(path[index]),
      newValue = value;
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = undefined;
      if (newValue === undefined) {
        newValue = isObject$2(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
      }
    }
    assignValue$1(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set$1(object, path, value) {
  return object == null ? object : baseSet$1(object, path, value);
}

/**
 * Class representing a Proxiable.
 *
 * This class allows instances to be wrapped in a Proxy, enabling custom behaviors for property access, assignment, etc.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
/* eslint-disable-next-line @typescript-eslint/no-extraneous-class */
let Proxiable$1 = class Proxiable {
  /**
   * Creates a Proxiable instance wrapped in a Proxy.
   *
   * @param handler - A trap object for the proxy, which defines custom behavior for fundamental operations (e.g., property lookup, assignment, etc.).
   * @returns A new proxy object for this instance.
   */
  constructor(handler) {
    return new Proxy(this, handler);
  }
};

/**
 * Class representing a Config.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 *
 * @template TObject
 */
class Config extends Proxiable$1 {
  items;
  /**
   * Create a Config.
   *
   * @param items - Initial configuration items.
   * @returns A new Config instance.
   */
  static create(items) {
    return new this(items);
  }
  /**
   * Create a Config.
   *
   * @param items - Initial configuration items.
   */
  constructor(items) {
    super({
      get: (target, prop, receiver) => {
        if (Reflect.has(target, prop)) {
          return Reflect.get(target, prop, receiver);
        } else {
          return target.get(prop);
        }
      }
    });
    this.items = {
      ...items
    };
  }
  /**
   * Get the specified configuration value.
   *
   * @param key - The key or keys to retrieve from the configuration.
   * @param fallback - The fallback value if the key does not exist.
   * @returns The configuration value.
   */
  get(key, fallback) {
    return get$3(this.items, key, fallback);
  }
  /**
   * Get the first match configuration value.
   *
   * @param keys - An array of keys to check.
   * @param fallback - The fallback value if no key matches.
   * @returns The first matching configuration value.
   */
  firstMatch(keys, fallback) {
    const firstKey = keys.find(v => this.has(v)) ?? [];
    return get$3(this.items, firstKey, fallback);
  }
  /**
   * Get many configuration values.
   *
   * @param keys - The keys to retrieve from the configuration.
   * @returns An object containing the requested configuration values.
   */
  getMany(keys) {
    const defaults = {};
    const entries = Array.isArray(keys) ? keys.map(v => [v, undefined]) : Object.entries(keys);
    return entries.reduce((results, [key, fallback]) => ({
      ...results,
      [key]: get$3(this.items, key, fallback)
    }), defaults);
  }
  /**
   * Determine if the given configuration value exists.
   *
   * @param key - The key or keys to check.
   * @returns True if the key exists, false otherwise.
   */
  has(key) {
    return has$1(this.items, key);
  }
  /**
   * Set a given configuration value.
   *
   * @param key - The key or keys to set in the configuration.
   * @param value - The value to set.
   * @returns The current Config instance.
   */
  set(key, value) {
    const entries = !Array.isArray(key) && typeof key === 'object' ? Object.entries(key) : [[key, value]];
    for (const [name, val] of entries) {
      set$1(this.items, name, val);
    }
    return this;
  }
  /**
   * Set a given configuration value if it does not exist.
   *
   * @param key - The key or keys to set in the configuration.
   * @param value - The value to set.
   * @returns The current Config instance.
   */
  setIf(key, value) {
    return this.has(key) ? this : this.set(key, value);
  }
  /**
   * Allows providers to define the default config for a module.
   *
   * @param key - The key or keys to set as defaults.
   * @param value - The value to set as default.
   * @returns The current Config instance.
   */
  add(key, value) {
    const items = this.get(key);
    if (Array.isArray(items)) {
      return this.set(key, items.concat(value));
    } else if (isObjectLike$2(items) && isObjectLike$2(value)) {
      return this.set(key, deepmerge$1(items, value));
    }
    return this.set(key, value);
  }
  /**
   * Set all of the configuration items.
   *
   * @param items - The configuration items.
   * @returns The current Config instance.
   */
  setItems(items) {
    this.items = {
      ...items
    };
    return this;
  }
  /**
   * Get all of the configuration items as a literal object.
   *
   * @returns All configuration items.
   */
  all() {
    return this.items;
  }
  /**
   * Clear all of the configuration items.
   *
   * @returns The current Config instance.
   */
  clear() {
    this.items = Object.create(null);
    return this;
  }
}

var cjs$1;
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1) return cjs$1;
  hasRequiredCjs$1 = 1;
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  cjs$1 = deepmerge_1;
  return cjs$1;
}

var cjsExports = requireCjs$1();
var deepmerge = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

/** Built-in value references. */
var Symbol$2 = root$1.Symbol;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$d.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$3 = objectProto$d.toString;

/** Built-in value references. */
var symToStringTag$3 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$3),
    tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$2 = objectProto$c.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString$2.call(value);
}

/** `Object#toString` result references. */
var nullTag$1 = '[object Null]',
  undefinedTag$1 = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$2 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$1(value) {
  if (value == null) {
    return value === undefined ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' || isObjectLike$1(value) && baseGetTag$1(value) == symbolTag$1;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap$1(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
  symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap$1(value, baseToString$1) + '';
  }
  if (isSymbol$1(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag$1 = '[object AsyncFunction]',
  funcTag$1 = '[object Function]',
  genTag$1 = '[object GeneratorFunction]',
  proxyTag$1 = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$2(value) {
  if (!isObject$1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag$1(value);
  return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$1['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$1 = function () {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}

/** Used for built-in method references. */
var funcProto$4 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$4 = funcProto$4.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$4.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$3 = Function.prototype,
  objectProto$b = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$3 = funcProto$3.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative$1 = RegExp('^' + funcToString$3.call(hasOwnProperty$a).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative$1(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$2 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$9.call(object, key) && eq$1(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Used to match property names within property paths. */
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  reIsPlainProp$1 = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$1(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}

/* Built-in method references that are verified to be native. */
var nativeCreate$1 = getNative$1(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$3 ? undefined : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$7.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$2 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$1(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype['delete'] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;

/** Built-in value references. */
var splice$1 = arrayProto$1.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
    index = assocIndexOf$1(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
    index = assocIndexOf$1(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
    index = assocIndexOf$1(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$1(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype['delete'] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;

/* Built-in method references that are verified to be native. */
var Map$2 = getNative$1(root$1, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash$1(),
    'map': new (Map$2 || ListCache$1)(),
    'string': new Hash$1()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$1(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$1(map, key) {
  var data = map.__data__;
  return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  var result = getMapData$1(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  var data = getMapData$1(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$1(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype['delete'] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function () {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$1)();
  return memoized;
}

// Expose `MapCache`.
memoize$1.Cache = MapCache$1;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE$1 = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped$1(func) {
  var result = memoize$1(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE$1) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar$1 = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$1 = memoizeCapped$1(function (string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName$1, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : baseToString$1(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$1(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey$1(value, object) ? [value] : stringToPath$1(toString$1(value));
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$1(value) {
  if (typeof value == 'string' || isSymbol$1(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet$1(object, path) {
  path = castPath$1(path, object);
  var index = 0,
    length = path.length;
  while (object != null && index < length) {
    object = object[toKey$1(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$2(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet$1(object, path);
  return result === undefined ? defaultValue : result;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto$2 = Function.prototype,
  objectProto$7 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index = -1,
    length = path.length,
    lastIndex = length - 1,
    nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$1(path[index]),
      newValue = value;
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = undefined;
      if (newValue === undefined) {
        newValue = isObject$1(objValue) ? objValue : isIndex$1(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/**
 * Custom error for pipeline operations.
 */
class PipelineError extends Error {
  constructor(message) {
    super(message);
    this.name = 'PipelineError';
  }
}
/**
 * Check if the value is a string.
 *
 * @param value - The value to check.
 * @returns `true` if the value is an string, otherwise `false`.
 */
const isString$1 = value => typeof value === 'string';
/**
 * Check if the value is a function.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a function, otherwise `false`.
 */
const isFunction$1 = value => typeof value === 'function';
/**
 * Checks if the given value is a constructor function.
 *
 * @param value - The value to be checked.
 * @returns True if the value is a constructor function, false otherwise.
 */
const isConstructor = value => {
  return isFunction$1(value) && Object.prototype.hasOwnProperty.call(value, 'prototype');
};
/**
 * Check if the meta pipe is a function pipe.
 *
 * @param metaPipe - The meta pipe to check.
 * @returns `true` if the meta pipe is a function pipe, otherwise `false`.
 */
const isFunctionPipe = metaPipe => {
  return !isAliasPipe(metaPipe) && !isClassPipe(metaPipe) && !isFactoryPipe(metaPipe);
};
/**
 * Check if the meta pipe is an alias pipe.
 *
 * @param metaPipe - The meta pipe to check.
 * @returns `true` if the meta pipe is an alias pipe, otherwise `false`.
 */
const isAliasPipe = metaPipe => {
  return metaPipe.isAlias === true && isString$1(metaPipe.module);
};
/**
 * Check if the meta pipe is a class pipe.
 *
 * @param metaPipe - The meta pipe to check.
 * @returns `true` if the meta pipe is a class pipe, otherwise `false`.
 */
const isClassPipe = metaPipe => {
  return metaPipe.isClass === true && isFunction$1(metaPipe.module) && isConstructor(metaPipe.module);
};
/**
 * Check if the meta pipe is a factory pipe.
 *
 * @param metaPipe - The meta pipe to check.
 * @returns `true` if the meta pipe is a factory pipe, otherwise `false`.
 */
const isFactoryPipe = metaPipe => {
  return metaPipe.isFactory === true && isFunction$1(metaPipe.module);
};

/**
 * Class representing a Pipeline.
 *
 * @template T - The type of the passable object in the pipeline.
 * @template R - The type of the return value from the pipeline execution.
 *
 * This class is responsible for managing and executing a series of operations
 * on a set of passable values through multiple configurable pipes.
 */
class Pipeline {
  /** The passable objects sent through the pipeline */
  passable;
  /** The method name to call on each pipe */
  method;
  /** Flag indicating whether the pipeline should run synchronously or asynchronously */
  isSync;
  /** The default priority for the pipes in the pipeline */
  _defaultPriority;
  /** The sorted metadata pipes that will be executed */
  sortedMetaPipes;
  /** The resolver function used to resolve pipes before they are executed in the pipeline. */
  resolver;
  /**
   * Create a pipeline instance.
   *
   * @param options - Optional Pipeline options.
   * @returns The pipeline instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Initialize a new Pipeline instance.
   *
   * @param options - Optional Pipeline options.
   */
  constructor(options) {
    this.isSync = false;
    this.method = 'handle';
    this.sortedMetaPipes = [];
    this._defaultPriority = 10;
    this.resolver = options?.resolver;
  }
  /**
   * Set the default priority for pipes in the pipeline.
   *
   * @param value - The priority value to set.
   * @returns The current Pipeline instance.
   */
  defaultPriority(value) {
    this._defaultPriority = value;
    return this;
  }
  /**
   * Set the passable objects being sent through the pipeline.
   *
   * @param passable - The object to pass through the pipeline.
   * @returns The current Pipeline instance.
   */
  send(passable) {
    this.passable = passable;
    return this;
  }
  /**
   * Set the pipes for the pipeline.
   *
   * @param pipes - The pipes or MetaPipe instances.
   * @returns The current Pipeline instance.
   */
  through(...pipes) {
    const metaPipes = pipes.map(pipe => isString$1(pipe) || isFunction$1(pipe) ? {
      module: pipe,
      priority: this._defaultPriority
    } : pipe);
    this.sortedMetaPipes = Array.from(new Set(metaPipes)).sort((a, b) => a.priority !== undefined && b.priority !== undefined ? a.priority - b.priority : 0).reverse();
    return this;
  }
  /**
   * Add additional pipes to the pipeline.
   *
   * @param pipe - A single pipe or an array of pipes.
   * @returns The current Pipeline instance.
   */
  pipe(...pipe) {
    return this.through(...this.sortedMetaPipes, ...pipe);
  }
  /**
   * Set the method to call on each pipe.
   *
   * @param method - The method name to use on each pipe.
   * @returns The current Pipeline instance.
   */
  via(method) {
    this.method = method;
    return this;
  }
  /**
   * Configure the pipeline to run synchronously or asynchronously.
   *
   * @param value - Set true for sync, false for async (default is true).
   * @returns The current Pipeline instance.
   */
  sync(value = true) {
    this.isSync = value;
    return this;
  }
  /**
   * Run the pipeline with a final destination callback.
   *
   * @param destination - The final function to execute.
   * @returns The result of the pipeline, either synchronously or as a Promise.
   */
  then(destination) {
    if (this.passable === undefined) {
      throw new PipelineError('No passable object has been set for this pipeline.');
    }
    return this.sortedMetaPipes.reduce(this.isSync ? this.reducer() : this.asyncReducer(), destination.bind(destination))(this.passable);
  }
  /**
   * Run the pipeline and return the result.
   *
   * @returns The result of the pipeline, either synchronously or as a Promise.
   */
  thenReturn() {
    return this.then(passable => passable);
  }
  /**
   * Get the asynchronous reducer to iterate over the pipes.
   *
   * @returns The asynchronous reducer callback.
   */
  asyncReducer() {
    return (previousPipeExecutor, currentPipe) => {
      return async passable => {
        return await this.executePipe(currentPipe, passable, previousPipeExecutor);
      };
    };
  }
  /**
   * Get the synchronous reducer to iterate over the pipes.
   *
   * @returns The synchronous reducer callback.
   */
  reducer() {
    return (previousPipeExecutor, currentPipe) => {
      return passable => {
        return this.executePipe(currentPipe, passable, previousPipeExecutor);
      };
    };
  }
  /**
   * Resolve and execute a pipe.
   *
   * @param currentPipe - The current pipe to execute (class or service alias string).
   * @param passable - The passable object to send through the pipe.
   * @param previousPipeExecutor - The previous pipe executor in the sequence.
   * @returns The result of the pipe execution.
   * @throws PipelineError If the pipe cannot be resolved or the method is missing.
   */
  executePipe(currentPipe, passable, previousPipeExecutor) {
    let instance = isFunction$1(this.resolver) ? this.resolver(currentPipe) : undefined;
    if (instance === undefined) {
      instance = this.createInstanceFromPipe(currentPipe);
      if (instance === undefined) {
        throw new PipelineError(`Cannot resolve this pipe ${String(currentPipe)}.`);
      }
    } else if (isFunction$1(instance)) {
      instance = {
        [this.method]: instance
      };
    }
    this.validatePipeMethod(instance, currentPipe);
    return instance[this.method](passable, previousPipeExecutor, ...(currentPipe.params ?? []));
  }
  /**
   * Create an instance from the provided pipe.
   *
   * @param currentPipe - The pipe function to create an instance from.
   * @returns The created instance or an object with the method.
   */
  createInstanceFromPipe(currentPipe) {
    if (isFunction$1(currentPipe.module)) {
      if (isClassPipe(currentPipe)) {
        return new currentPipe.module.prototype.constructor(...[]);
      }
      return {
        [this.method]: isFactoryPipe(currentPipe) ? currentPipe.module(...[]) : currentPipe.module
      };
    }
  }
  /**
   * Validate that the required method exists on the instance.
   *
   * @param instance - The instance to validate.
   * @param currentPipe - The current pipe being executed.
   * @throws {PipelineError} If the method does not exist on the instance.
   */
  validatePipeMethod(instance, currentPipe) {
    if (!isFunction$1(instance[this.method])) {
      throw new PipelineError(`No method with this name(${this.method}) exists in this constructor(${currentPipe.module.constructor.name})`);
    }
  }
}

/**
 * Class representing a Proxiable.
 *
 * This class allows instances to be wrapped in a Proxy, enabling custom behaviors for property access, assignment, etc.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
/* eslint-disable-next-line @typescript-eslint/no-extraneous-class */
class Proxiable {
  /**
   * Creates a Proxiable instance wrapped in a Proxy.
   *
   * @param handler - A trap object for the proxy, which defines custom behavior for fundamental operations (e.g., property lookup, assignment, etc.).
   * @returns A new proxy object for this instance.
   */
  constructor(handler) {
    return new Proxy(this, handler);
  }
}

/**
 * Abstract class representing a Binding.
 *
 * This abstract class serves as the base class for all types of bindings in the service container. It holds a value and provides an abstract method
 * to resolve and return that value, allowing different subclasses to implement their own resolution logic. Bindings are used to manage dependencies
 * and control how objects are instantiated within the container.
 *
 * @template V - The type of value that this binding holds.
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Binding {
  /**
   * The value held by the binding.
   *
   * This value is resolved at runtime, either directly or through a resolver function.
   */
  value;
  /**
   * Create a new instance of Binding.
   *
   * @param value - The value to be held by the binding.
   */
  constructor(value) {
    this.value = value;
  }
  /**
   * Check if the value has been resolved.
   *
   * @returns A boolean indicating whether the value has been resolved.
   */
  isResolved() {
    return this.value !== undefined;
  }
}

/**
 * Class representing a ContainerError.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class ContainerError extends Error {
  /**
   * Error type indicating an alias conflict.
   */
  static ALIAS_TYPE = 'alias';
  /**
   * Error type indicating that the resolver is not a function.
   */
  static RESOLVER_TYPE = 'resolver';
  /**
   * Error type indicating a resolution failure.
   */
  static RESOLUTION_TYPE = 'resolution';
  /**
   * Error type indicating an attempt to alias an unbound value.
   */
  static ALIAS_UNBOUND_TYPE = 'alias_unbound';
  /**
   * Error type indicating that a value is not a service.
   */
  static NOT_A_SERVICE_TYPE = 'not_a_service';
  /**
   * Error type indicating an error thrown by the resolver function.
   */
  static CANNOT_RESOLVE_TYPE = 'cannot_resolve';
  /**
   * Error type indicating a circular dependency.
   */
  static CIRCULAR_DEPENDENCY_TYPE = 'circular_dependency';
  /**
   * The type of the error.
   */
  type;
  /**
   * Create a ContainerError.
   *
   * @param type - The type of the error.
   * @param message - The error message or key related to the error.
   */
  constructor(type, message) {
    super();
    this.type = type;
    this.name = 'ContainerError';
    this.message = this.getMessage(type, message);
  }
  /**
   * Retrieve the error message based on the type and provided message.
   *
   * @param type - The type of the error.
   * @param message - The error message or key related to the error.
   * @returns The formatted error message.
   */
  getMessage(type, message) {
    const messages = {
      [ContainerError.RESOLUTION_TYPE]: this.getResolutionMessage(message),
      [ContainerError.ALIAS_TYPE]: `${String(message)} is aliased to itself`,
      [ContainerError.CANNOT_RESOLVE_TYPE]: `Failed to resolve binding: ${String(message)}`,
      [ContainerError.ALIAS_UNBOUND_TYPE]: `Cannot alias an unbound value : ${String(message)}`,
      [ContainerError.CIRCULAR_DEPENDENCY_TYPE]: `Circular dependency detected for key: ${String(message)}`,
      [ContainerError.RESOLVER_TYPE]: `Invalid resolver: Expected a function but received ${typeof message}`,
      [ContainerError.NOT_A_SERVICE_TYPE]: `This (${String(message)}) is not a service. Must contain $$metadata$$ static property or must use @Service decorator.`
    };
    return messages[type] ?? 'An error has occurred.';
  }
  /**
   * Retrieve the resolution message based on the key.
   *
   * @param key - The key for which the resolution failed.
   * @returns The formatted resolution error message.
   */
  getResolutionMessage(key) {
    let value = '';
    if (key === undefined) {
      value = 'undefined';
    } else if (key === null) {
      value = 'null';
    } else if (typeof key === 'function') {
      const funcName = key.name !== '' ? `: ${key.name}` : '';
      value = `[Function${funcName}]`;
    } else if (typeof key === 'object') {
      value = `[Object: ${key.constructor.name}]`;
    } else if (typeof key === 'string') {
      value = `type ${typeof key} with a value of '${key}'`;
    } else if (typeof key === 'symbol') {
      value = key.toString();
    } else {
      value = `type ${typeof key} with a value of ${String(key)}`;
    }
    return `Failed to resolve a binding with a key of ${value} from the service container.`;
  }
}

/**
 * Class representing a ResolverBinding.
 *
 * This class extends the Binding class, using a resolver function to lazily resolve the value when needed.
 *
 * @template V - The type of value that this binding holds.
 * @author Mr. Stone <evensstone@gmail.com>
 */
class ResolverBinding extends Binding {
  /**
   * The resolver function used to provide the binding value.
   *
   * This function will be called when the value is needed, allowing for lazy instantiation
   * and dependency resolution. It should return an instance of type `V`.
   */
  resolver;
  /**
   * Create a new instance of ResolverBinding.
   *
   * @param resolver - The resolver function to provide the binding value.
   * @throws ContainerError if the resolver is not a function.
   */
  constructor(resolver) {
    super();
    if (typeof resolver !== 'function') {
      throw new ContainerError(ContainerError.RESOLVER_TYPE, resolver);
    }
    this.resolver = resolver;
  }
}

/**
 * Class representing a Factory.
 *
 * The Factory class extends the ResolverBinding class, providing a mechanism to resolve a new instance each time the binding is resolved.
 * This ensures that a fresh instance is created with each call to the `resolve` method.
 *
 * @template V - The type of value that this binding holds.
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Factory extends ResolverBinding {
  /**
   * Resolve and return the value of the binding.
   *
   * Each time this method is called, a new value is resolved using the resolver function.
   * This is intended for cases where a fresh instance is required for each resolution, such as factories or transient dependencies.
   *
   * @param container - The container to resolve dependencies from.
   * @returns The resolved value of the binding.
   * @throws ContainerError if the value cannot be resolved.
   */
  resolve(container) {
    try {
      return this.resolver(container);
    } catch (error) {
      throw new ContainerError(ContainerError.CANNOT_RESOLVE_TYPE, error.message);
    }
  }
}

/**
 * Class representing an Instance.
 *
 * This class extends the Binding class and directly holds an instance value.
 * It provides a straightforward resolution mechanism that simply returns the stored value.
 *
 * @template V - The type of value that this binding holds.
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Instance extends Binding {
  /**
   * Resolve and return the value of the binding.
   *
   * @param _container - Container to resolve dependencies (not used in this implementation).
   * @returns The resolved value of the binding.
   */
  resolve(_container) {
    return this.value;
  }
}

/**
 * Class representing a Singleton.
 *
 * The Singleton class extends the ResolverBinding class, ensuring that the value is only resolved once.
 * Subsequent calls to the `resolve` method will return the previously resolved value, making it behave as a singleton.
 *
 * @template V - The type of value that this binding holds.
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Singleton extends ResolverBinding {
  /**
   * Resolve and return the value of the binding.
   *
   * If the value has already been resolved, return the cached value. Otherwise, use the resolver function
   * to resolve the value, store it, and return it.
   *
   * @param container - The container to resolve dependencies from.
   * @returns The resolved value of the binding.
   * @throws ContainerError if the value cannot be resolved.
   */
  resolve(container) {
    if (!this.isResolved()) {
      try {
        this.value = this.resolver(container);
      } catch (error) {
        throw new ContainerError(ContainerError.CANNOT_RESOLVE_TYPE, error.message);
      }
    }
    return this.value;
  }
}

/**
 * Class representing a Container.
 *
 * The Container class acts as a dependency injection container, managing bindings and resolving instances.
 * It supports different types of bindings, such as singletons, factories, and instances, and allows the use of aliases for bindings.
 * This makes it easier to manage and resolve complex dependency trees in an application.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Container extends Proxiable {
  aliases;
  resolvingKeys = new Set();
  bindings;
  /**
   * Create a Container.
   *
   * @returns A new Container instance.
   */
  static create() {
    return new this();
  }
  /**
   * Create a ProxyHandler for the container.
   *
   * @returns A new ProxyHandler instance.
   */
  static Proxyhandler() {
    return {
      get: (target, prop, receiver) => {
        if (Reflect.has(target, prop)) {
          return Reflect.get(target, prop, receiver);
        } else {
          return target.make(prop);
        }
      }
    };
  }
  /**
   * Create a container.
   *
   * Initializes the container with empty alias and binding maps.
   */
  constructor() {
    super(Container.Proxyhandler());
    this.aliases = new Map();
    this.bindings = new Map();
  }
  /**
   * Retrieve the value of the bindings property.
   *
   * @returns A map of all bindings registered in the container.
   */
  getBindings() {
    return this.bindings;
  }
  /**
   * Retrieve the value of the aliases property.
   *
   * @returns A map of all aliases registered in the container.
   */
  getAliases() {
    return this.aliases;
  }
  /**
   * Set a binding as alias.
   *
   * Adds one or more aliases for a given binding key.
   *
   * @param key - The binding value.
   * @param aliases - One or more strings representing the aliases.
   * @returns The container instance.
   */
  alias(key, aliases) {
    [].concat(aliases).forEach(alias => {
      if (key === alias) {
        throw new ContainerError(ContainerError.ALIAS_TYPE, key);
      } else if (!this.has(key)) {
        throw new ContainerError(ContainerError.ALIAS_UNBOUND_TYPE, key);
      }
      this.aliases.set(alias, key);
    });
    return this;
  }
  /**
   * Check if an alias exists in the container.
   *
   * @param alias - The alias to check.
   * @returns True if the alias exists, false otherwise.
   */
  isAlias(alias) {
    return this.aliases.has(alias);
  }
  /**
   * Get a binding key by its alias.
   *
   * @param alias - The alias name.
   * @returns The binding key associated with the alias, or undefined if not found.
   */
  getAliasKey(alias) {
    return this.aliases.get(alias);
  }
  /**
   * Bind a single instance or value into the container under the provided key.
   *
   * @param key - The key to associate with the value.
   * @param value - The value to be bound.
   * @returns The container instance.
   */
  instance(key, value) {
    this.bindings.set(key, new Instance(value));
    return this;
  }
  /**
   * Bind a single instance or value into the container under the provided key if not already bound.
   *
   * @param key - The key to associate with the value.
   * @param value - The value to be bound.
   * @returns The container instance.
   */
  instanceIf(key, value) {
    if (!this.bound(key)) {
      this.instance(key, value);
    }
    return this;
  }
  /**
   * Bind a resolver function into the container under the provided key as a singleton.
   *
   * The resolver function will be called once, and the resulting value will be cached for future use.
   *
   * @param key - The key to associate with the singleton value.
   * @param resolver - The resolver function to provide the value.
   * @returns The container instance.
   */
  singleton(key, resolver) {
    this.bindings.set(key, new Singleton(resolver));
    return this;
  }
  /**
   * Bind a resolver function into the container under the provided key as a singleton if not already bound.
   *
   * @param key - The key to associate with the singleton value.
   * @param resolver - The resolver function to provide the value.
   * @returns The container instance.
   */
  singletonIf(key, resolver) {
    if (!this.bound(key)) {
      this.singleton(key, resolver);
    }
    return this;
  }
  /**
   * Bind a resolver function into the container under the provided key, returning a new instance each time.
   *
   * @param key - The key to associate with the value.
   * @param resolver - The resolver function to provide the value.
   * @returns The container instance.
   */
  binding(key, resolver) {
    this.bindings.set(key, new Factory(resolver));
    return this;
  }
  /**
   * Bind a resolver function into the container under the provided key, returning a new instance each time if not already bound.
   *
   * @param key - The key to associate with the value.
   * @param resolver - The resolver function to provide the value.
   * @returns The container instance.
   */
  bindingIf(key, resolver) {
    if (!this.bound(key)) {
      this.binding(key, resolver);
    }
    return this;
  }
  /**
   * Resolve a registered value from the container by its key.
   *
   * @param key - The key to resolve.
   * @returns The resolved value.
   * @throws ContainerError if the key cannot be resolved.
   */
  make(key) {
    key = this.getAliasKey(key) ?? key;
    if (this.resolvingKeys.has(key)) {
      throw new ContainerError(ContainerError.CIRCULAR_DEPENDENCY_TYPE, key);
    }
    this.resolvingKeys.add(key);
    try {
      const binding = this.bindings.get(key);
      if (binding !== undefined) {
        return binding.resolve(new Proxy(this, Container.Proxyhandler()));
      }
    } finally {
      this.resolvingKeys.delete(key);
    }
    throw new ContainerError(ContainerError.RESOLUTION_TYPE, key);
  }
  /**
   * Resolve a value from the container by its key, binding it if necessary.
   *
   * @param key - The key to resolve.
   * @param singleton - Whether to bind as a singleton if not already bound.
   * @returns The resolved value.
   */
  resolve(key, singleton = false) {
    if (this.has(key)) {
      return this.make(key);
    } else {
      return this.autoBinding(key, key, singleton).make(key);
    }
  }
  /**
   * Resolve a value from the container by its key and return it in a factory function.
   *
   * @param key - The key to resolve.
   * @returns A factory function that returns the resolved value.
   */
  factory(key) {
    return () => this.make(key);
  }
  /**
   * Check if a value is already bound in the container by its key.
   *
   * @param key - The key to check.
   * @returns True if the key is bound, false otherwise.
   */
  bound(key) {
    return this.bindings.has(this.getAliasKey(key) ?? key);
  }
  /**
   * Check if a value is already bound in the container by its key.
   *
   * @param key - The key to check.
   * @returns True if the key is bound, false otherwise.
   */
  has(key) {
    return this.bound(key);
  }
  /**
   * Reset the container so that all bindings are removed.
   *
   * @returns The container instance.
   */
  clear() {
    this.aliases.clear();
    this.bindings.clear();
    return this;
  }
  /**
   * AutoBind value to the service container.
   *
   * @param name - A key to make the binding. Can be anything.
   * @param item - The item to bind.
   * @param singleton - Bind as singleton when true.
   * @param alias - Key binding aliases.
   * @returns The container instance.
   */
  autoBinding(name, item, singleton = true, alias = []) {
    const key = name;
    const value = item ?? name;
    if (!this.bound(key)) {
      if (typeof value === 'function') {
        const callable = value;
        const resolver = Object.prototype.hasOwnProperty.call(callable, 'prototype') ? container => new callable.prototype.constructor(container) : container => callable(container);
        singleton ? this.singleton(key, resolver) : this.binding(key, resolver);
      } else {
        this.instance(key, value);
      }
      this.alias(key, alias);
    }
    return this;
  }
}

/**
 * Class representing a RuntimeError.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class RuntimeError extends Error {
  code;
  cause;
  metadata;
  /**
   * Create a RuntimeError.
   *
   * @param options - The options to create a RuntimeError.
   * @returns A new RuntimeError instance.
   */
  static create(message, options = {}) {
    return new this(message, options);
  }
  /**
   * Create a RuntimeError.
   *
   * @param message - The message to log.
   * @param options - The error options.
   */
  constructor(message, options = {}) {
    super(message);
    this.code = options.code;
    this.name = 'RuntimeError';
    this.metadata = options.metadata;
    if (options.cause !== undefined) {
      this.cause = options.cause;
    }
    if (Error.captureStackTrace !== undefined) {
      Error.captureStackTrace(this, this.constructor); // Official V8 method to capture the stack trace, excluding the constructor
    } else {
      this.stack = new Error(message).stack; // Fallback for environments without captureStackTrace
    }
  }
  /**
   * Converts the error to a formatted string representation.
   *
   * @param multiline - Determine if output value must be multiline or not.
   * @returns A formatted error string.
   */
  toString(multiline = false) {
    const baseMessage = `Error: ${this.name}`;
    const codeMessage = this.code !== undefined ? `Code: ${String(this.code)}` : '';
    const mainMessage = `Message: "${this.message}"`;
    const metadataMessage = this.metadata !== undefined ? `Metadata: ${JSON.stringify(this.metadata)}` : '';
    if (multiline) {
      return [baseMessage, codeMessage, mainMessage, metadataMessage].filter(Boolean).join('\n');
    }
    return [`[${this.name}]`, this.code !== undefined ? `Code: ${String(this.code)}` : '', `Message: "${this.message}"`, this.metadata !== undefined ? `Metadata: ${JSON.stringify(this.metadata)}` : ''].filter(Boolean).join(', ');
  }
}

/**
 * Custom error for Setup layer operations.
 */
class SetupError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'SetupError';
  }
}

/**
 * Merges multiple blueprints into a single application blueprint.
 *
 * This function takes any number of blueprint objects and merges them into one,
 * with later blueprints overwriting properties of earlier ones in case of conflicts.
 * It uses deep merging to ensure nested properties are also combined appropriately.
 * Note: The `deepmerge` function can lead to unexpected results if objects have circular references.
 * Consider handling such cases or documenting this behavior if it applies to your usage.
 *
 * @param blueprints - An array of blueprints to be merged.
 * @returns The merged application blueprint.
 *
 * @throws {SetupError} - If any of the provided blueprints are not valid objects.
 *
 * @example
 * ```typescript
 * const mergedBlueprint = mergeBlueprints(blueprint1, blueprint2);
 * ```
 */
const mergeBlueprints = (...blueprints) => {
  validateBlueprints(blueprints);
  return blueprints.reduce((prev, curr) => deepmerge(prev, curr, {
    isMergeableObject: isMergeable
  }), {
    stone: {}
  });
};
/**
 * Defines a factory service with metadata for the provided module.
 *
 * @param alias - The alias for the service.
 * @param module - The module handler function to be defined.
 * @returns The defined factory service with metadata.
*/
const factoryService = (alias, module) => {
  return {
    alias,
    module,
    isFactory: true
  };
};
/**
 * Defines a class middleware with metadata for the provided module.
 *
 * @param module - The module handler function to be defined.
 * @param options - The metadata options for the middleware.
 * @returns The defined class middleware with metadata.
*/
const classMiddleware = (module, options = {}) => {
  return {
    ...options,
    module,
    isClass: true,
    isFactory: false
  };
};
/**
 * Check if the provided value is a Stone blueprint.
 * This function checks if the value is an object and contains the required `stone` property.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a Stone blueprint, otherwise `false`.
 */
const isStoneBlueprint = value => {
  return typeof value?.stone === 'object';
};
/**
 * Check if the provided value is an object module.
 *
 * @param value - The value to check.
 * @returns `true` if the value is an object module, otherwise `false`.
 */
const isObjectLikeModule = value => {
  return isObjectLike$1(value);
};
/**
 * Check if the provided value is a function module.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a function module, otherwise `false`.
 */
const isFunctionModule = value => {
  return isFunction$1(value);
};
/**
 * Check if the provided value is a meta function module.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a meta function module, otherwise `false`.
 */
const isMetaFunctionModule = value => {
  return isFunction$1(value?.module) && value?.isClass !== true && value?.isFactory !== true;
};
/**
 * Check if the provided value is a meta class module.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a meta class module, otherwise `false`.
*/
const isMetaClassModule = value => {
  return value?.isClass === true && isConstructor(value?.module);
};
/**
 * Check if the provided value is a meta factory module.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a meta factory module, otherwise `false`.
 */
const isMetaFactoryModule = value => {
  return value?.isFactory === true && isFunction$1(value?.module);
};
/**
 * Check if the provided handler has the specified hook.
 *
 * @param handler - The handler to check.
 * @param hookName - The hook name to check.
 * @returns `true` if the handler has the specified hook, otherwise `false`.
 */
const isHandlerHasHook = (handler, hookName) => {
  return typeof handler[hookName] === 'function';
};
/**
 * Check if the provided value is not empty.
 *
 * @param value - The value to check.
 * @returns `true` if the value is not empty, otherwise `false`.
*/
const isNotEmpty = value => {
  return value !== undefined && value !== null;
};
/**
 * Custom function to determine if an object is mergeable.
 * Helps to avoid issues with circular references.
 *
 * @param value - The value to check for mergeability.
 * @returns Whether the value is mergeable or not.
 *
 * @example
 * ```typescript
 * const canMerge = isMergeable(someValue);
 * ```
 */
const isMergeable = value => {
  return value !== undefined && typeof value === 'object' && !Object.isFrozen(value);
};
/**
 * Validates that the provided blueprints are valid objects.
 *
 * This function checks if each blueprint in the provided array is an object,
 * throwing a SetupError if an invalid blueprint is found.
 *
 * @param blueprints - An array of blueprints to validate.
 * @throws {SetupError} - If any of the provided blueprints are not valid objects.
 *
 * @example
 * ```typescript
 * validateBlueprints([blueprint1, blueprint2]);
 * ```
 */
const validateBlueprints = blueprints => {
  blueprints.forEach((blueprint, index) => {
    if (typeof blueprint !== 'object' || blueprint === null) {
      throw new SetupError(`Invalid blueprint at index ${index}. Expected an object but received ${typeof blueprint}.`);
    }
  });
};

/**
 * Constants are defined here to prevent Circular dependency between modules
 * This pattern must be applied to all Stone libraries or third party libraries.
 */
/**
 * A unique symbol key to mark classes as the main application entry point.
 */
const STONE_APP_KEY = Symbol.for('StoneApp');
/**
 * A unique symbol key to mark classes as middleware.
 */
const ADAPTER_MIDDLEWARE_KEY = Symbol.for('AdapterMiddleware');
/**
 * A unique symbol key to mark classes as middleware.
 */
const CONFIG_MIDDLEWARE_KEY = Symbol.for('ConfigMiddleware');
/**
 * A unique symbol used as a key for the configuration metadata.
 */
const CONFIGURATION_KEY = Symbol.for('Configuration');
/**
 * A unique symbol used as a key for the error handler metadata.
 */
const ERROR_HANDLER_KEY = Symbol.for('ErrorHandler');
/**
 * A unique symbol used as a key for the adapter error handler metadata.
 */
const ADAPTER_ERROR_HANDLER_KEY = Symbol.for('AdapterErrorHandler');
/**
 * A unique symbol key to mark classes as listeners.
 */
const LISTENER_KEY = Symbol.for('Listener');
/**
 * A unique symbol key to mark classes as middleware.
 */
const MIDDLEWARE_KEY = Symbol.for('Middleware');
/**
 * A unique symbol key to mark classes as providers.
 */
const PROVIDER_KEY = Symbol.for('Provider');
/**
 * A unique symbol key to mark classes as services.
 */
const SERVICE_KEY = Symbol.for('Service');
/**
 * A unique symbol key to mark classes as subscribers.
 */
const SUBSCRIBER_KEY = Symbol.for('Subscriber');
/**
 * A unique symbol key to mark classes as the blueprint container.
 */
const BLUEPRINT_KEY = Symbol.for('blueprint');

/**
 * A unique symbol for storing and accessing metadata on classes and their members.
 * This symbol is used by decorators to define and retrieve metadata across modules.
 */
const MetadataSymbol = Symbol.metadata !== undefined ? Symbol.metadata : Symbol.for('Symbol.metadata');
/**
 * Check if a class has specific metadata.
 *
 * @param Class - The class to check for metadata.
 * @param key - The key of the metadata to check.
 * @returns True if the metadata key exists on the class, false otherwise.
 */
function hasMetadata(Class, key) {
  return hasMetadataSymbol(Class) && Class[MetadataSymbol]?.[key] !== undefined;
}
/**
 * Get the metadata value for a given key from a class.
 *
 * @param Class - The class to get the metadata from.
 * @param key - The key of the metadata to retrieve.
 * @param fallback - The default value to return if the metadata key is not found.
 * @returns The metadata value or the default value if the key does not exist.
 */
function getMetadata(Class, key, fallback) {
  return hasMetadataSymbol(Class) ? Class[MetadataSymbol]?.[key] : fallback;
}
/**
 * Check if a class has blueprint.
 *
 * @param Class - The class to check for metadata.
 * @returns True if the metadata and BLUEPRINT_KEY keys exist on the class, false otherwise.
 */
function hasBlueprint(Class) {
  return hasMetadataSymbol(Class) && Class[MetadataSymbol]?.[BLUEPRINT_KEY] !== undefined;
}
/**
 * Get the blueprint value from a class.
 *
 * @param Class - The class to get the blueprint from.
 * @param fallback - The default value to return if the blueprint key is not found.
 * @returns The blueprint value or the default value if the key does not exist.
 */
function getBlueprint(Class, fallback) {
  return hasMetadataSymbol(Class) ? Class[MetadataSymbol]?.[BLUEPRINT_KEY] : fallback;
}
/**
 * Type guard to check if a class has metadata.
 *
 * @param target - The target class to check.
 * @returns True if the target has metadata, false otherwise.
 */
function hasMetadataSymbol(target) {
  return target !== undefined && MetadataSymbol in target && typeof target[MetadataSymbol] !== 'undefined';
}

/**
 * Class representing a ConfigBuilder for the Stone.js framework.
 *
 * The ConfigBuilder is responsible for constructing and configuring the dynamic, complex structured options required by the Stone.js framework.
 * It inspects various modules, extracts metadata, and builds the "blueprint" object which serves as the primary configuration for the Stone.js application.
 * This class also manages middleware used to process and populate the configuration during the application setup.
 *
 * The ConfigBuilder allows users to create a unified configuration that is used to initialize and bootstrap the Stone.js application,
 * ensuring all necessary metadata is aggregated into a blueprint that can be used consistently throughout the application lifecycle.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class ConfigBuilder {
  options;
  /**
   * Create a ConfigBuilder.
   *
   * @param options - The options to create a ConfigBuilder.
   * @returns A new ConfigBuilder instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Create a ConfigBuilder.
   *
   * @param options - The options to create a ConfigBuilder.
   */
  constructor(options = {
    middleware: [],
    defaultMiddlewarePriority: 0
  }) {
    this.options = options;
  }
  /**
   * Build the configuration blueprint by extracting metadata from the provided modules.
   *
   * This method processes the given raw modules, extracts metadata to populate the blueprint,
   * and returns the resulting configuration blueprint. It allows users to pass a custom blueprint
   * or use a default one if none is provided.
   *
   * @param modules - The modules to build the configuration from.
   * @param blueprint - The initial blueprint to populate, defaults to a newly created Config instance.
   * @returns A promise that resolves to the populated Blueprint object.
   *
   * @example
   * ```typescript
   * const configBuilder = ConfigBuilder.create();
   * const blueprint = await configBuilder.build(rawModules);
   * ```
   */
  async build(modules, blueprint = Config.create()) {
    const context = {
      modules,
      blueprint
    };
    const {
      middleware,
      defaultMiddlewarePriority
    } = await this.extractOptionsFromModules(modules, blueprint);
    return await Pipeline.create().send(context).through(...middleware).defaultPriority(defaultMiddlewarePriority ?? 0).then(v => v.blueprint);
  }
  /**
   * Extract the configuration options from the modules.
   *
   * @param modules - The modules to extract options from.
   * @returns The configuration options.
   */
  async extractOptionsFromModules(modules, blueprint) {
    const {
      middleware,
      defaultMiddlewarePriority
    } = blueprint.get('stone.builder', {
      middleware: []
    });
    this.options.middleware = this.options.middleware.concat(middleware);
    this.options.defaultMiddlewarePriority ??= defaultMiddlewarePriority;
    for (const module of modules) {
      if (isConstructor(module)) {
        await this.applyMetadata(module);
      } else if (isStoneBlueprint(module)) {
        this.populateOptions(module.stone.builder);
      }
    }
    return this.options;
  }
  /**
   * Apply metadata from a class to the options.
   *
   * @param module - The class to extract metadata from.
   */
  async applyMetadata(module) {
    if (hasBlueprint(module)) {
      const blueprint = getBlueprint(module);
      this.populateOptions(blueprint?.stone?.builder);
    } else if (hasMetadata(module, CONFIG_MIDDLEWARE_KEY)) {
      const metadata = getMetadata(module, CONFIG_MIDDLEWARE_KEY, {});
      this.populateOptions({
        middleware: [{
          ...metadata,
          pipe: module
        }]
      });
    } else if (hasMetadata(module, CONFIGURATION_KEY) && isConstructor(module)) {
      const options = getMetadata(module, CONFIGURATION_KEY, {
        live: false
      });
      if (options.live !== true) {
        const blueprint = Config.create();
        await new module.prototype.constructor().configure(blueprint);
        this.populateOptions(blueprint.get('stone.builder'));
      }
    }
  }
  /**
   * Populate the configuration options with metadata.
   *
   * @param builder - The metadata to use for populating options.
   */
  populateOptions(builder) {
    if (isObjectLikeModule(builder)) {
      const {
        middleware,
        defaultMiddlewarePriority
      } = builder;
      if (Array.isArray(middleware)) {
        this.options.middleware = this.options.middleware.concat(middleware);
        this.options.defaultMiddlewarePriority = defaultMiddlewarePriority ?? this.options.defaultMiddlewarePriority;
      }
    }
  }
}

/**
 * Log level enumeration to define possible log levels.
 */
var LogLevel;
(function (LogLevel) {
  LogLevel["TRACE"] = "trace";
  LogLevel["DEBUG"] = "debug";
  LogLevel["INFO"] = "info";
  LogLevel["WARN"] = "warn";
  LogLevel["ERROR"] = "error";
})(LogLevel || (LogLevel = {}));
/** ************** End Adapter *************/

/**
 * Console Logger class.
 *
 * This class implements the ILogger interface and uses either the native console object or a custom logging tool.
 *
 * @example
 * ```typescript
 * const logger = ConsoleLogger.create({ blueprint });
 * logger.info('Application started');
 * ```
 */
class ConsoleLogger {
  blueprint;
  /**
   * Create a new ConsoleLogger instance.
   *
   * @param {LoggerOptions} options - Options for creating the ConsoleLogger.
   * @returns {ConsoleLogger} - A new instance of ConsoleLogger.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs a ConsoleLogger instance.
   *
   * @param {LoggerOptions} options - Options for creating the ConsoleLogger.
   */
  constructor({
    blueprint
  }) {
    if (blueprint === undefined) {
      throw new RuntimeError('Blueprint is required to create a ConsoleLogger instance.');
    }
    this.blueprint = blueprint;
  }
  /**
   * Logs informational messages.
   *
   * @param {string} message - The message to log.
   * @param {...unknown[]} optionalParams - Optional parameters to log.
   */
  info(message, ...optionalParams) {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatMessage(message), ...optionalParams);
    }
  }
  /**
   * Logs debug-level messages, used for debugging purposes.
   *
   * @param {string} message - The message to log.
   * @param {...unknown[]} optionalParams - Optional parameters to log.
   */
  debug(message, ...optionalParams) {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatMessage(message), ...optionalParams);
    }
  }
  /**
   * Logs warnings, used to indicate potential issues.
   *
   * @param {string} message - The warning message to log.
   * @param {...unknown[]} optionalParams - Optional parameters to log.
   */
  warn(message, ...optionalParams) {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatMessage(message), ...optionalParams);
    }
  }
  /**
   * Logs errors, used to report errors or exceptions.
   *
   * @param {string} message - The error message to log.
   * @param {...unknown[]} optionalParams - Optional parameters to log.
   */
  error(message, ...optionalParams) {
    if (this.shouldLog(LogLevel.ERROR)) {
      console.error(this.formatMessage(message), ...optionalParams);
    }
  }
  /**
   * Logs general messages, similar to `info` but less specific.
   *
   * @param {string} message - The message to log.
   * @param {...unknown[]} optionalParams - Optional parameters to log.
   */
  log(message, ...optionalParams) {
    if (this.shouldLog(LogLevel.INFO)) {
      console.log(this.formatMessage(message), ...optionalParams);
    }
  }
  /**
   * Determines if the specified log level should be logged based on the current log level setting.
   *
   * @param {'error' | 'warn' | 'info' | 'debug' | 'trace'} level - The log level to check.
   * @returns {boolean} - True if the specified log level should be logged, otherwise false.
   */
  shouldLog(level) {
    const levels = ['trace', 'debug', 'info', 'warn', 'error'];
    const appLevel = this.blueprint.get('stone.logger.level', 'info');
    return levels.slice(levels.indexOf(appLevel)).includes(level);
  }
  /**
   * Formats the log message by optionally adding a timestamp.
   *
   * @param {string} message - The message to format.
   * @returns {string} - The formatted message.
   */
  formatMessage(message) {
    if (this.blueprint.get('stone.logger.useTimestamp', false)) {
      return `[${new Date().toISOString()}] ${message}`;
    }
    return message;
  }
}

/**
 * Class representing an Event.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Event {
  /**
   * The type of the event.
   */
  type;
  /**
   * The metadata associated with the event.
   */
  metadata;
  /**
   * The source of the event.
   */
  source;
  /**
   * The timestamp of the event creation.
   */
  timeStamp;
  /**
   * Create an Event.
   *
   * @param options - The options to create an Event.
   */
  constructor({
    type = '',
    metadata = {},
    source,
    timeStamp = Date.now()
  }) {
    this.type = type;
    this.source = source;
    this.timeStamp = timeStamp;
    this.metadata = isPlainObject(metadata) ? metadata : {};
  }
  /**
   * Get data from metadata.
   *
   * @param key - The key to retrieve from metadata.
   * @param fallback - The fallback value if the key is not found.
   * @returns The value associated with the key or the fallback.
   */
  get(key, fallback) {
    return this.getMetadataValue(key, fallback);
  }
  /**
   * Get data from metadata.
   *
   * @param key - The key to retrieve from metadata.
   * @param fallback - The fallback value if the key is not found.
   * @returns The value associated with the key or the fallback.
   */
  getMetadataValue(key, fallback) {
    return get$2(this.metadata, key, fallback);
  }
  /**
   * Add data to metadata.
   *
   * @param key - The key or object to add to metadata.
   * @param value - The value to associate with the key.
   * @returns This Event instance.
   */
  setMetadataValue(key, value) {
    Object.entries(isPlainObject(key) ? key : {
      [key]: value
    }).forEach(([name, val]) => set(this.metadata, name, val));
    return this;
  }
  /**
   * Return a cloned instance.
   *
   * @returns A cloned instance of the current class.
   */
  clone() {
    return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
  }
}

/**
 * Class representing a kernel Event.
 *
 * @extends Event
 */
class KernelEvent extends Event {
  /**
   * DISPATCHING_EVENT Event name, fires before dispatching
   * the incoming event to the destination handler.
   *
   * @event KernelEvent#DISPATCHING_EVENT
   */
  static DISPATCHING_EVENT = 'stonejs@kernel.dispatching_event';
  /**
   * PREPARING_RESPONSE Event name, fires before preparing the response.
   *
   * @event KernelEvent#PREPARING_RESPONSE
   */
  static PREPARING_RESPONSE = 'stonejs@kernel.preparing_response';
  /**
   * RESPONSE_PREPARED Event name, fires after the response was prepared.
   *
   * @event KernelEvent#RESPONSE_PREPARED
   */
  static RESPONSE_PREPARED = 'stonejs@kernel.response_prepared';
  /**
   * Create a KernelEvent.
   *
   * @param options - The options to create a KernelEvent.
   * @returns A new KernelEvent instance.
   */
  static create(options) {
    return new this(options);
  }
}
/**
 * Class representing an EventEmitter.
 */
class EventEmitter {
  listeners;
  /**
   * Create an EventEmitter.
   */
  constructor() {
    this.listeners = new Map();
  }
  /**
   * Registers an event listener for the given event type.
   *
   * @param event - The event name or type.
   * @param handler - The callback to invoke when the event is emitted.
   */
  on(event, handler) {
    const handlers = this.listeners.get(event);
    isNotEmpty(handlers) ? handlers.push(handler) : this.listeners.set(event, [handler]);
    return this;
  }
  /**
   * Removes an event listener for the given event type.
   *
   * @param event - The event name or type.
   * @param handler - The callback to remove.
   */
  off(event, handler) {
    const handlers = this.listeners.get(event);
    isNotEmpty(handlers) ? handlers.splice(handlers.indexOf(handler) >>> 0, 1) : this.listeners.set(event, []);
    return this;
  }
  /**
   * Emits an event, triggering all associated listeners.
   *
   * @param event - The event name or an instance of Event.
   * @param args - Additional arguments to pass to the listeners.
   */
  async emit(event, args) {
    let eventName;
    let eventPayload;
    if (event instanceof Event) {
      eventName = event.type;
      eventPayload = event;
    } else {
      eventName = event;
      eventPayload = args;
    }
    const handlers = this.listeners.get(eventName);
    const wilcardHandlers = this.listeners.get('*');
    if (isNotEmpty(handlers) && eventPayload !== undefined) {
      for (const handler of handlers.slice()) {
        await handler(eventPayload);
      }
    }
    if (isNotEmpty(wilcardHandlers) && eventPayload !== undefined) {
      for (const handler of wilcardHandlers.slice()) {
        await handler(eventName, eventPayload);
      }
    }
  }
}

/**
 * Class representing an OutgoingResponse.
 *
 * @extends Event
 */
class OutgoingResponse extends Event {
  /**
   * OUTGOING_RESPONSE Event name, fires on response to the incoming event.
   *
   * @event OutgoingResponse#OUTGOING_RESPONSE
   */
  static OUTGOING_RESPONSE = 'stonejs@outgoing_response';
  /**
   * The original content of the response.
   */
  originalContent;
  /**
   * The content of the response.
   */
  _content;
  /**
   * The status code of the response.
   */
  _statusCode;
  /**
   * The status message of the response.
   */
  _statusMessage;
  /**
   * Create an OutgoingResponse.
   *
   * @param options - The options to create an OutgoingResponse.
   * @returns A new OutgoingResponse instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Create an OutgoingResponse.
   *
   * @param options - The options to create an OutgoingResponse.
   */
  constructor({
    source,
    content,
    metadata = {},
    timeStamp = Date.now(),
    statusCode = undefined,
    statusMessage = undefined,
    type = OutgoingResponse.OUTGOING_RESPONSE
  }) {
    super({
      type,
      metadata,
      source,
      timeStamp
    });
    this._content = content;
    this._statusCode = statusCode;
    this.originalContent = content;
    this._statusMessage = statusMessage;
  }
  /**
   * Gets the status code of the outgoing response.
   *
   * @returns The status code of the response, or undefined if not set.
   */
  get statusCode() {
    return this._statusCode;
  }
  /**
   * Gets the status message of the outgoing response.
   *
   * @returns The status message of the response, or undefined if not set.
   */
  get statusMessage() {
    return this._statusMessage;
  }
  /**
   * Gets the content of the outgoing response.
   *
   * @returns The content of the outgoing response.
   */
  get content() {
    return this._content;
  }
  /**
   * Prepare response before sending it.
   *
   * @param _event - The incoming event associated with this response.
   * @param _container - The container.
   * @returns This OutgoingResponse instance.
   */
  prepare(_event, _container) {
    // Add logic to modify the response based on the incoming event if needed
    return this;
  }
}

/**
 * Custom error for Initialization layer operations.
 */
class InitializationError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'InitializationError';
  }
}

/**
 * Class representing a Kernel.
 *
 * The Kernel class is responsible for managing the main lifecycle of the application, including middleware
 * registration and provider management. It manages the initialization, registration, and booting of the
 * components required for a fully functional application.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class Kernel {
  logger;
  hooks;
  container;
  blueprint;
  eventEmitter;
  registeredProviders;
  providers;
  resolvedErrorHandlers;
  resolvedApplication;
  resolvedEventHandler;
  /**
   * Create a Kernel.
   *
   * @param options - Kernel configuration options.
   * @returns A new Kernel instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Create a Kernel.
   *
   * @param options - Kernel configuration options.
   */
  constructor({
    blueprint,
    container,
    eventEmitter,
    logger
  }) {
    if (!(blueprint instanceof Config)) {
      throw new InitializationError('Blueprint is required to create a Kernel instance.');
    }
    if (!(container instanceof Container)) {
      throw new InitializationError('Container is required to create a Kernel instance.');
    }
    if (!(eventEmitter instanceof EventEmitter)) {
      throw new InitializationError('EventEmitter is required to create a Kernel instance.');
    }
    this.logger = logger;
    this.providers = new Set();
    this.container = container;
    this.blueprint = blueprint;
    this.resolvedErrorHandlers = {};
    this.eventEmitter = eventEmitter;
    this.registeredProviders = new Set();
    this.hooks = blueprint.get('stone.kernel.hooks', {});
  }
  /**
   * Populate the context with the given bindings.
   * The context here is the service container.
   * Invoke subsequent hooks.
   * Resolve the app event handler.
   */
  async onPrepare() {
    this.registerBaseBindings();
    await this.runLiveConfigurations();
    await this.resolveProviders();
    for (const provider of this.providers) {
      await provider.onPrepare?.();
    }
    await this.registerProviders();
    await this.executeHooks('onPrepare');
    await this.resolveApplication()?.onPrepare?.();
  }
  /**
   * Boot the providers.
   * Invoke subsequent hooks.
   */
  async beforeHandle() {
    for (const provider of this.providers) {
      await provider.beforeHandle?.();
    }
    await this.bootProviders();
    await this.executeHooks('beforeHandle');
    await this.resolveApplication()?.beforeHandle?.();
  }
  /**
   * Handle Stone IncomingEvent.
   *
   * @param event - The Stone incoming event to handle.
   * @returns The Stone outgoing response.
   */
  async handle(event) {
    return await this.sendEventThroughDestination(event);
  }
  /**
   * Invoke subsequent hooks after handling the event.
   */
  async afterHandle(context) {
    for (const provider of this.providers) {
      await provider.afterHandle?.(context);
    }
    await this.executeHooks('afterHandle');
    await this.resolveApplication()?.afterHandle?.(context);
  }
  /**
   * Invoke subsequent hooks on termination.
   */
  async onTerminate(context) {
    for (const provider of this.providers) {
      await provider.onTerminate?.(context);
    }
    await this.executeHooks('onTerminate');
    await this.resolveApplication()?.onTerminate?.(context);
  }
  /**
   * Send event to the destination.
   *
   * @param event - The incoming event.
   * @returns The prepared response.
   * @throws InitializationError if no IncomingEvent is provided.
   */
  async sendEventThroughDestination(event) {
    if (event === undefined) {
      throw new InitializationError('No IncomingEvent provided.');
    }
    if (typeof event.clone === 'function') {
      this.container.instance('originalEvent', event.clone());
    }
    this.container.instance('event', event).instance('request', event);
    const middleware = this.blueprint.get('stone.kernel.middleware', []);
    try {
      return await Pipeline.create(this.makePipelineOptions()).send(event).through(...middleware).then(async ev => await this.prepareResponse(ev));
    } catch (error) {
      return await this.handleErrors(error, event);
    }
  }
  /**
   * Prepare response before sending
   *
   * @protected
   * @param event - The Kernel event.
   * @returns The prepared response.
   */
  async prepareResponse(event) {
    await this.eventEmitter.emit(KernelEvent.create({
      type: KernelEvent.DISPATCHING_EVENT,
      source: this,
      metadata: {
        event
      }
    }));
    const response = await this.resolveEventHandler().handle(event);
    const validatedResponse = await this.validateAndResolveResponse(response);
    await this.eventEmitter.emit(KernelEvent.create({
      type: KernelEvent.PREPARING_RESPONSE,
      source: this,
      metadata: {
        event,
        response: validatedResponse
      }
    }));
    const preparedResponse = await validatedResponse.prepare(event, this.container);
    await this.eventEmitter.emit(KernelEvent.create({
      type: KernelEvent.RESPONSE_PREPARED,
      source: this,
      metadata: {
        event,
        response: preparedResponse
      }
    }));
    this.container.instance('response', preparedResponse);
    return preparedResponse;
  }
  /**
   * Creates pipeline options for the Kernel.
   *
   * @protected
   * @returns The pipeline options for configuring middleware.
   */
  makePipelineOptions() {
    return {
      resolver: metaPipe => {
        if (isClassPipe(metaPipe) || isAliasPipe(metaPipe)) {
          return this.container.resolve(metaPipe.module, true);
        } else if (isFactoryPipe(metaPipe)) {
          return metaPipe.module(this.container);
        }
      }
    };
  }
  /**
   * Registers the base bindings into the container.
   *
   * @private
   * @returns The Kernel instance.
   */
  registerBaseBindings() {
    this.container.instance(Config, this.blueprint).instance(Container, this.container).instance(ConsoleLogger, this.logger).instance(EventEmitter, this.eventEmitter).alias(Config, 'config').alias(Config, 'blueprint').alias(Container, 'container').alias(EventEmitter, 'events').alias(ConsoleLogger, 'logger').alias(EventEmitter, 'eventEmitter');
    return this;
  }
  /**
   * Resolves the application from the container.
   * This application is the main entry point for the Stone.js framework in declarative context.
   * It is the class decorated with the @StoneApp() decorator.
   * Note: It does not exist in imperative context.
   * It is used here to instantiate the it after resolving the providers
   * And to execute the lifecycle hooks.
   * So the user can get benefit of destructuring DI in the constructor.
   *
   * @returns The resolved application or undefined if not found.
   */
  resolveApplication() {
    if (this.resolvedApplication === undefined) {
      const metaApp = this.blueprint.get('stone.application');
      if (isMetaClassModule(metaApp)) {
        this.resolvedApplication = this.container.resolve(metaApp.module, true);
      }
    }
    return this.resolvedApplication;
  }
  /**
   * Resolves the app event handler from the container.
   *
   * @returns The resolved event handler or undefined if not found.
   * @throws InitializationError if no event handler is found.
   */
  resolveEventHandler() {
    if (this.resolvedEventHandler === undefined) {
      const mixedEventHandler = this.blueprint.get('stone.handler');
      if (isMetaClassModule(mixedEventHandler)) {
        this.resolvedEventHandler = this.container.resolve(mixedEventHandler.module, true);
      } else if (isMetaFactoryModule(mixedEventHandler)) {
        this.resolvedEventHandler = {
          handle: mixedEventHandler.module(this.container)
        };
      } else if (isMetaFunctionModule(mixedEventHandler)) {
        this.resolvedEventHandler = {
          handle: mixedEventHandler.module
        };
      } else if (isFunctionModule(mixedEventHandler)) {
        this.resolvedEventHandler = {
          handle: mixedEventHandler
        };
      } else {
        throw new InitializationError('No event handler has been provided.');
      }
    }
    return this.resolvedEventHandler;
  }
  /**
   * Get the error handler for the given error.
   *
   * @param error - The error to get the handler for.
   * @returns The error handler.
   * @throws Error if no error handler is found.
   */
  resolveErrorHandler(error) {
    if (this.resolvedErrorHandlers[error.name] === undefined) {
      const handlers = this.blueprint.get('stone.kernel.errorHandlers', []);
      const mixedErrorHandler = handlers.find(v => v.error === error.name || v.error.includes(error.name)) ?? handlers.find(v => v.error === 'default');
      if (isMetaClassModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = this.container.resolve(mixedErrorHandler.module, true);
      } else if (isMetaFactoryModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = {
          handle: mixedErrorHandler.module(this.container)
        };
      } else if (isMetaFunctionModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = {
          handle: mixedErrorHandler.module
        };
      } else {
        throw error;
      }
    }
    return this.resolvedErrorHandlers[error.name];
  }
  /**
   * Resolves all providers defined in the blueprint.
   *
   * @private
   * @returns The Kernel instance.
   */
  async resolveProviders() {
    const providers = this.blueprint.get('stone.providers', []);
    for (const provider of providers) {
      let resolvedProvider;
      if (isMetaClassModule(provider)) {
        resolvedProvider = this.container.resolve(provider.module, true);
      } else if (isMetaFactoryModule(provider)) {
        resolvedProvider = provider.module(this.container);
      } else if (isConstructor(provider)) {
        resolvedProvider = this.container.resolve(provider, true);
      }
      if (resolvedProvider !== undefined && (resolvedProvider.mustSkip === undefined || !(await resolvedProvider.mustSkip()))) {
        this.providers.add(resolvedProvider);
      }
    }
  }
  /**
   * Registers the providers.
   *
   * @private
   * @returns A promise that resolves when all providers are registered.
   */
  async registerProviders() {
    for (const provider of this.providers) {
      if (provider.register === undefined || this.registeredProviders.has(provider.constructor.name)) {
        continue;
      }
      await provider.register();
      this.registeredProviders.add(provider.constructor.name);
    }
  }
  /**
   * Boots the providers.
   *
   * @private
   * @returns A promise that resolves when all providers have been booted.
   */
  async bootProviders() {
    for (const provider of this.providers) {
      await provider.boot?.();
    }
  }
  /**
   * Handle errors.
   *
   * @param error - The error to handle.
   * @param event - The incoming event.
   * @returns The outgoing response.
   */
  async handleErrors(error, event) {
    const errorHandler = this.resolveErrorHandler(error);
    const response = await errorHandler.handle(error, event);
    const validatedResponse = await this.validateAndResolveResponse(response);
    return await validatedResponse.prepare(event, this.container);
  }
  /**
   * Validate and resolve the response.
   *
   * @param returnedValue - The returned value that might be a response.
   * @returns The validated and resolved response.
   * @throws InitializationError if the response is invalid or undefined.
   */
  async validateAndResolveResponse(returnedValue) {
    const responseResolver = this.blueprint.get('stone.kernel.responseResolver');
    if (returnedValue === undefined) {
      if (responseResolver === undefined) {
        throw new InitializationError('No response was returned');
      }
      return await responseResolver({});
    }
    if (!(returnedValue instanceof OutgoingResponse)) {
      if (responseResolver === undefined) {
        throw new InitializationError('Returned response must be an instance of `OutgoingResponse` or a subclass of it.');
      }
      const valueOptions = returnedValue;
      const options = valueOptions?.content === undefined && valueOptions?.statusCode === undefined ? {
        content: returnedValue
      } : returnedValue;
      return await responseResolver(options);
    }
    return returnedValue;
  }
  /**
   * Run live configurations.
   * Live configurations are loaded at each request.
   */
  async runLiveConfigurations() {
    const liveConfigurations = this.blueprint.get('stone.liveConfigurations', []);
    for (const configuration of liveConfigurations) {
      if (isMetaClassModule(configuration)) {
        await this.container.resolve(configuration.module).configure(this.blueprint);
      } else if (isFunctionModule(configuration)) {
        await configuration(this.blueprint);
      }
    }
  }
  /**
   * Execute lifecycle hooks.
   *
   * @param name - The hook's name.
   */
  async executeHooks(name) {
    if (Array.isArray(this.hooks[name])) {
      for (const listener of this.hooks[name]) {
        await listener(this.container);
      }
    }
  }
}

/**
 * Class representing a CoreServiceProvider.
 *
 * The CoreServiceProvider is responsible for managing the core services,
 * listeners, subscribers, and adapters required by the application.
 * It interacts with the service container to bind and resolve dependencies,
 * ensuring all components are available when needed.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class CoreServiceProvider {
  /**
   * The logger
   */
  logger;
  /**
   * The service container that manages dependencies.
   */
  container;
  /**
   * Blueprint configuration used to retrieve app settings.
   */
  blueprint;
  /**
   * The event emitter used for managing and firing events.
   */
  eventEmitter;
  /**
   * Create a new instance of CoreServiceProvider.
   *
   * @param container - The service container to manage dependencies.
   * @throws {InitializationError} If the Blueprint config or EventEmitter is not bound to the container.
   */
  constructor({
    container,
    blueprint,
    eventEmitter,
    logger
  }) {
    if (logger === undefined) {
      throw new InitializationError('Logger is required to create a CoreServiceProvider instance.');
    }
    if (container === undefined) {
      throw new InitializationError('Container is required to create a CoreServiceProvider instance.');
    }
    if (blueprint === undefined) {
      throw new InitializationError('Blueprint is required to create a CoreServiceProvider instance.');
    }
    if (eventEmitter === undefined) {
      throw new InitializationError('EventEmitter is required to create a CoreServiceProvider instance.');
    }
    this.logger = logger;
    this.container = container;
    this.blueprint = blueprint;
    this.eventEmitter = eventEmitter;
  }
  /**
   * Get the list of services from the configuration.
   *
   * @returns A list of services or an array of service options.
   */
  get services() {
    return this.blueprint.get('stone.services', []);
  }
  /**
   * Get the list of listeners from the configuration.
   *
   * @returns A record of event listeners.
   */
  get listeners() {
    return this.blueprint.get('stone.listeners', []);
  }
  /**
   * Get the list of subscribers from the configuration.
   *
   * @returns A list of subscribers.
   */
  get subscribers() {
    return this.blueprint.get('stone.subscribers', []);
  }
  /**
   * Get the list of aliases from the configuration.
   *
   * @returns A record of class aliases.
   */
  get aliases() {
    return this.blueprint.get('stone.aliases', {});
  }
  /**
   * Register core components in the service container.
   *
   * This method registers services, listeners, adapters, and aliases in the container.
   */
  register() {
    this.registerServices();
    this.registerListeners();
    this.registerAliases();
  }
  /**
   * Boot core components.
   *
   * This method is used to bootstrap subscribers.
   */
  async boot() {
    await this.bootSubscribers();
  }
  /**
   * Register aliases in the service container.
   *
   * @returns This CoreServiceProvider instance for chaining.
   */
  registerAliases() {
    Object.entries(this.aliases).forEach(([alias, Class]) => isConstructor(Class) && this.container.alias(Class, alias));
  }
  /**
   * Register decorated and imported services.
   *
   * @returns This CoreServiceProvider instance for chaining.
   */
  registerServices() {
    this.services.forEach(service => {
      const {
        singleton = true,
        alias = []
      } = service;
      if (isMetaClassModule(service)) {
        this.container.autoBinding(service.module, service.module, singleton, alias);
      } else if (isMetaFactoryModule(service)) {
        const [name, ...aliases] = [alias].flat();
        this.container.autoBinding(name, service.module, true, aliases);
      }
    });
  }
  /**
   * Register decorated and imported listeners in the event emitter.
   *
   * @returns This CoreServiceProvider instance for chaining.
   */
  registerListeners() {
    for (const listener of this.listeners) {
      const {
        event: eventName
      } = listener;
      let instance;
      if (isMetaClassModule(listener)) {
        instance = this.container.resolve(listener.module, true);
      } else if (isMetaFactoryModule(listener)) {
        instance = {
          handle: listener.module(this.container)
        };
      } else if (isMetaFunctionModule(listener)) {
        instance = {
          handle: listener.module
        };
      }
      if (instance?.handle !== undefined) {
        this.eventEmitter.on(eventName, async event => {
          try {
            await instance.handle(event);
          } catch (error) {
            this.logger.error(`An error has occured with this listener (${String(listener)}) ${String(error.message)}`);
          }
        });
      }
    }
  }
  /**
   * Bootstrap subscribers by resolving them from the container and subscribing to the event emitter.
   *
   * @returns This CoreServiceProvider instance for chaining.
   */
  async bootSubscribers() {
    for (const subscriber of this.subscribers) {
      let instance;
      if (isMetaClassModule(subscriber)) {
        instance = this.container.resolve(subscriber.module, true);
      } else if (isMetaFactoryModule(subscriber)) {
        instance = {
          subscribe: subscriber.module(this.container)
        };
      } else if (isMetaFunctionModule(subscriber)) {
        instance = {
          subscribe: subscriber.module
        };
      } else if (isConstructor(subscriber)) {
        instance = this.container.resolve(subscriber, true);
      }
      try {
        await instance?.subscribe(this.eventEmitter);
      } catch (error) {
        this.logger.error(`An error has occured with this subscriber (${String(subscriber)}) ${String(error.message)}`);
      }
    }
  }
}

/**
 * Custom error for Integration layer operations.
 */
class IntegrationError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'IntegrationError';
  }
}

/**
 * Class representing StoneFactory.
 *
 * The StoneFactory is responsible for creating and running the main application by resolving
 * the appropriate adapter from the provided blueprint. It handles the core setup of the application.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class StoneFactory {
  /**
   * The blueprint configuration for the application.
   */
  blueprint;
  /**
   * Create a new StoneFactory instance.
   *
   * @param options - The options to create the StoneFactory.
   * @returns A new StoneFactory instance.
   *
   * @example
   * ```typescript
   * const factory = StoneFactory.create({ blueprint });
   * ```
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Create a new instance of StoneFactory.
   *
   * @param options - The options to create the StoneFactory.
   */
  constructor({
    blueprint
  }) {
    if (blueprint === undefined) {
      throw new RuntimeError('Blueprint is required to create a StoneFactory instance.');
    }
    this.blueprint = blueprint;
  }
  /**
   * Run the application by resolving and executing the adapter.
   *
   * @returns A promise that resolves to the result of the adapter's `run` method.
   * @throws {IntegrationError} If no adapter resolver or adapter is provided in the blueprint.
   *
   * @example
   * ```typescript
   * await factory.run();
   * ```
   */
  async run() {
    return await this.makeAdapter().run();
  }
  /**
   * Resolve and create the appropriate adapter from the blueprint.
   *
   * @returns The resolved adapter instance.
   * @throws {IntegrationError} If no adapter resolver or adapter is provided in the blueprint.
   */
  makeAdapter() {
    const resolver = this.blueprint.get('stone.adapter.resolver');
    if (resolver === undefined) {
      throw new IntegrationError('No adapter resolver provided. Ensure that a valid adapter resolver is configured under "stone.adapter.resolver" in the blueprint configuration.');
    }
    const adapter = resolver(this.blueprint);
    if (adapter === undefined) {
      throw new IntegrationError('No adapters provided. Stone.js needs at least one adapter to run.');
    }
    return adapter;
  }
}

/**
 * Stone builder.
 *
 * This class provides a fluent interface for building Stone applications.
 * It allows you to configure the application using a builder pattern,
 * with options for adding modules, plugins, and custom configurations.
 *
 * @template TEvent, UResponse
 */
class StoneBuilder {
  modules;
  blueprint;
  /**
   * Create a new StoneBuilder instance.
   *
   * @param options - The options to create the StoneBuilder.
   * @returns A new StoneBuilder instance.
   *
   * @example
   * ```typescript
   * const builder = StoneBuilder.create();
   * ```
   */
  static create(options = {}) {
    return new this(options);
  }
  /**
   * Create a new StoneBuilder instance.
   *
   * @param options - The options to create the StoneBuilder.
   */
  constructor({
    modules = []
  } = {}) {
    this.modules = modules;
    this.blueprint = Config.create();
  }
  /**
   * Add Stone plugins's blueprint to the application.
   *
   * @param blueprints - The plugins's blueprint to add to the application.
   * @returns The current StoneBuilder instance.
   */
  use(...blueprints) {
    const mergedBlueprint = mergeBlueprints(this.blueprint.all(), ...blueprints);
    this.blueprint.setItems(mergedBlueprint);
    return this;
  }
  /**
   * Configure the application using the blueprint resolver.
   * Use this method to add custom configurations to the application.
   *
   * @param resolver - The blueprint resolver function.
   * @returns The current StoneBuilder instance.
   */
  configure(resolver) {
    resolver(this.blueprint);
    return this;
  }
  /**
   * Set a value in the application blueprint.
   *
   * @param key - The key to set.
   * @param value - The value to set.
   * @returns The current StoneBuilder instance.
   */
  set(key, value) {
    this.blueprint.set(key, value);
    return this;
  }
  /**
   * Add a value to the application blueprint.
   *
   * @param key - The key to add.
   * @param value - The value to add.
   * @returns The current StoneBuilder instance.
   */
  add(key, value) {
    this.blueprint.add(key, value);
    return this;
  }
  /**
   * Add an event listener handler to the application.
   *
   * @param event - The event name to add.
   * @param handler - The listener handler to add.
   * @param options - The event listener options.
   * @returns The current StoneBuilder instance.
   */
  on(event, handler, options) {
    this.blueprint.add('stone.listeners', [{
      ...options,
      event,
      module: handler
    }]);
    return this;
  }
  /**
   * Add a listener hook to the application.
   *
   * @param key - The hook name to add.
   * @param listener - The hook listener function to add.
   * @returns The current StoneBuilder instance.
   */
  hook(key, listener) {
    this.blueprint.add(`stone.kernel.hooks.${key}`, [listener]);
    return this;
  }
  /**
   * Add an adapter listener hook to the application.
   * This hook is specific to the adapter and is called when the adapter is initialized.
   * Because the adapter is initialized before the application,
   *
   * @param listener - The hook function listener to add.
   * @returns The current StoneBuilder instance.
   */
  onInit(listener) {
    this.blueprint.add('stone.adapter.hooks.onInit', [listener]);
    return this;
  }
  /**
   * Hook to register modules to the service container.
   * This hook is called when the application is prepared.
   * Just after the onPrepare hook.
   * At this point, the application is ready to register modules to the service container.
   * And all third-party modules are already registered.
   * Usefull to register your own modules to the service container.
   *
   * @param listener - The hook function listener to add.
   * @returns The current StoneBuilder instance.
   */
  onRegister(listener) {
    this.hook('onPrepare', listener);
    return this;
  }
  /**
   * Hook to boot the application.
   * This hook is called when the application is booted.
   * At this point, the application is ready to handle events.
   * This hook is called after the onRegister hook.
   * And just before the handle method is called.
   * Usefull to boot stuffs at each event handling.
   *
   * @param listener - The hook function listener to add.
   * @returns The current StoneBuilder instance.
   */
  onBoot(listener) {
    this.hook('beforeHandle', listener);
    return this;
  }
  /**
   * Handle application events.
   * This method is a shorthand for running the application with the provided event handler.
   *
   * @param handler - The application event handler function.
   * @returns The platform-specific response.
   */
  async handle(handler) {
    this.blueprint.set('stone.handler', handler);
    return await this.run();
  }
  /**
   * Run the application.
   * Populates the blueprint via introspection and runs the application.
   *
   * @returns The platform-specific response.
   */
  async run() {
    const blueprint = await ConfigBuilder.create().build(this.modules, this.blueprint);
    return await StoneFactory.create({
      blueprint
    }).run();
  }
}
/**
 * Create a new Stone instance with the given options.
 *
 * This function creates a new Stone instance with the provided options.
 * It allows you to configure the application using the StoneBuilder.
 *
 * @template U, V
 * @param options - The options to create the Stone instance.
 * @returns A new StoneBuilder instance.
 */
function stoneApp(options = {}) {
  return StoneBuilder.create(options);
}

/**
 * Default logger resolver function.
 *
 * This function resolves the logger for the application, using the blueprint configuration.
 * By default, it creates a `ConsoleLogger` instance with the provided blueprint.
 *
 * @param blueprint - The blueprint configuration to use for the logger.
 * @returns A `ConsoleLogger` instance.
 */
function defaultLoggerResolver(blueprint) {
  return ConsoleLogger.create({
    blueprint
  });
}
/**
 * Default response resolver function.
 *
 * This function resolves the response for the application, using the options provided.
 * By default, it creates an `OutgoingResponse` instance with the provided options.
 *
 * @param options - The options to create the response.
 * @returns An outgoing response instance.
 */
function defaultResponseResolver(options) {
  return OutgoingResponse.create(options);
}
/**
 * Default kernel resolver function.
 *
 * This function resolves the kernel for the application, using the blueprint configuration.
 * It creates a `Kernel` instance with the given blueprint, logger, container, and an event emitter.
 *
 * @template U, V
 * @param blueprint - The blueprint configuration to use for the kernel.
 * @returns A `Kernel` instance configured with the provided blueprint.
 */
function defaultKernelResolver(blueprint) {
  const loggerResolver = blueprint.get('stone.logger.resolver', defaultLoggerResolver);
  return Kernel.create({
    blueprint,
    logger: loggerResolver(blueprint),
    container: Container.create(),
    eventEmitter: new EventEmitter()
  });
}

/**
 * Class representing an Adapter.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 *
 * @template RawEventType
 * @template RawResponseType
 * @template ExecutionContextType
 * @template IncomingEventType
 * @template IncomingEventOptionsType
 * @template OutgoingResponseType
 * @template AdapterContextType
 */
class Adapter {
  logger;
  hooks;
  blueprint;
  handlerResolver;
  resolvedErrorHandlers;
  /**
   * Create an Adapter.
   *
   * @param options - Adapter options.
   */
  constructor({
    hooks,
    logger,
    blueprint,
    handlerResolver
  }) {
    if (logger === undefined) {
      throw new IntegrationError('Logger is required to create an Adapter instance.');
    }
    if (blueprint?.get === undefined) {
      throw new IntegrationError('Blueprint is required to create an Adapter instance.');
    }
    if (typeof handlerResolver !== 'function') {
      throw new IntegrationError(`The 'handlerResolver' expects a function or a class, but provided: ${typeof handlerResolver}.`);
    }
    this.logger = logger;
    this.hooks = hooks ?? [];
    this.blueprint = blueprint;
    this.resolvedErrorHandlers = {};
    this.handlerResolver = handlerResolver;
  }
  /**
   * Incoming message listener.
   *
   * @param context - The event context.
   * @returns Platform-specific output.
   */
  async sendEventThroughDestination(eventHandler, context) {
    if (eventHandler === undefined) {
      throw new IntegrationError('No eventHandler provided');
    }
    if (context.rawResponseBuilder?.build === undefined) {
      throw new IntegrationError('No RawResponseBuilder provided');
    }
    if (context.incomingEventBuilder?.build === undefined) {
      throw new IntegrationError('No IncomingEventBuilder provided');
    }
    const middleware = this.blueprint.get('stone.adapter.middleware', []);
    try {
      await this.beforeHandle(eventHandler);
      const responseBuilder = await Pipeline.create(this.makePipelineOptions()).send(context).through(...middleware).then(async ctx => await this.prepareResponse(eventHandler, ctx));
      await this.afterHandle(eventHandler, context);
      context.rawResponse = await responseBuilder.build().respond();
    } catch (error) {
      context.rawResponse = await this.resolveErrorHandler(error).handle(error, context);
    } finally {
      try {
        await this.onTerminate(eventHandler, context);
      } catch (error) {
        this.logger.error(error.message, {
          error
        });
      }
    }
    return context.rawResponse;
  }
  /**
   * Hook that runs once before everything.
   */
  async onInit() {
    await this.executeHooks('onInit');
  }
  /**
   * Hook that runs before preparing the event context.
   *
   * @param eventHandler - Action handler to be run.
   */
  async onPrepare(eventHandler) {
    await this.executeHooks('onPrepare');
    if (isHandlerHasHook(eventHandler, 'onPrepare')) {
      await eventHandler.onPrepare();
    }
  }
  /**
   * Hook that runs before handling each event.
   *
   * @param eventHandler - Action handler to be run.
   */
  async beforeHandle(eventHandler) {
    await this.executeHooks('beforeHandle');
    if (isHandlerHasHook(eventHandler, 'beforeHandle')) {
      await eventHandler.beforeHandle();
    }
  }
  /**
   * Hook that runs after handling each event.
   *
   * @param eventHandler - Action handler to be run.
   * @param context - The event context.
   */
  async afterHandle(eventHandler, context) {
    await this.executeHooks('afterHandle', context);
    if (isHandlerHasHook(eventHandler, 'afterHandle')) {
      await eventHandler.afterHandle(this.makeHookContext(context));
    }
  }
  /**
   * Hook that runs after running the action handler.
   *
   * @param eventHandler - Action handler to be run.
   * @param context - The event context.
   */
  async onTerminate(eventHandler, context) {
    await this.executeHooks('onTerminate', context);
    if (isHandlerHasHook(eventHandler, 'onTerminate')) {
      await eventHandler.onTerminate(this.makeHookContext(context));
    }
  }
  /**
   * Execute lifecycle hooks.
   *
   * @param hook - The hook to execute.
   * @param context - The event context.
   */
  async executeHooks(hook, context) {
    if (Array.isArray(this.hooks[hook])) {
      for (const listener of this.hooks[hook]) {
        await listener(this.blueprint, this.makeHookContext(context));
      }
    }
  }
  /**
   * Create pipeline options for the Adapter.
   *
   * @returns The pipeline options for transforming the event.
   */
  makePipelineOptions() {
    return {
      resolver: metaPipe => {
        if (isClassPipe(metaPipe)) {
          return new metaPipe.module.prototype.constructor({
            blueprint: this.blueprint,
            logger: this.logger
          });
        } else if (isFactoryPipe(metaPipe)) {
          return metaPipe.module({
            blueprint: this.blueprint,
            logger: this.logger
          });
        }
      }
    };
  }
  /**
   * Get the error handler for the given error.
   *
   * @param error - The error to get the handler for.
   * @returns The error handler.
   */
  resolveErrorHandler(error) {
    if (this.resolvedErrorHandlers[error.name] === undefined) {
      const handlers = this.blueprint.get('stone.adapter.errorHandlers', []);
      const mixedErrorHandler = handlers.find(v => v.error === error.name || v.error.includes(error.name)) ?? handlers.find(v => v.error === 'default');
      if (isMetaClassModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = new mixedErrorHandler.module.prototype.constructor({
          blueprint: this.blueprint,
          logger: this.logger
        });
      } else if (isMetaFactoryModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = {
          handle: mixedErrorHandler.module({
            blueprint: this.blueprint,
            logger: this.logger
          })
        };
      } else if (isMetaFunctionModule(mixedErrorHandler)) {
        this.resolvedErrorHandlers[error.name] = {
          handle: mixedErrorHandler.module
        };
      } else {
        throw new IntegrationError(`The error handler for ${String(error.name)} is not provided or is not a class.`);
      }
    }
    return this.resolvedErrorHandlers[error.name];
  }
  /**
   * Prepare the response for the event handler.
   *
   * @param eventHandler - The event handler to prepare the response for.
   * @param context - The event context.
   * @returns The raw response wrapper.
   */
  async prepareResponse(eventHandler, context) {
    const lifecycleEventHandler = eventHandler;
    context.incomingEvent = context.incomingEventBuilder.build();
    if (context.incomingEvent === undefined) {
      throw new IntegrationError('No IncomingEvent provided');
    }
    context.outgoingResponse = isFunction$1(lifecycleEventHandler.handle) ? await lifecycleEventHandler.handle(context.incomingEvent) : await eventHandler(context.incomingEvent);
    return context.rawResponseBuilder;
  }
  /**
   * Create a hook context.
   *
   * @param context - The adapter context.
   * @returns The hook context.
   */
  makeHookContext(context) {
    return {
      event: context?.incomingEvent,
      response: context?.outgoingResponse
    };
  }
}

/**
 * Middleware to build a blueprint from provided modules and pass it to the next pipeline step.
 *
 * This middleware processes each module to extract its blueprint or configuration metadata, merges
 * them into a single meta blueprint, and sets the resulting blueprint in the provided context.
 * It uses `Promise.all()` to execute the module processing concurrently for better performance.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns A promise that resolves to the updated blueprint.
 *
 * @example
 * ```typescript
 * await BlueprintMiddleware({ modules, blueprint }, next);
 * ```
 */
const BlueprintMiddleware = async (context, next) => {
  let blueprints = [];
  for (const module of context.modules) {
    if (isStoneBlueprint(module)) {
      // Blueprint configuration
      blueprints = blueprints.concat(module);
    } else if (hasBlueprint(module)) {
      // Declarative configuration
      blueprints = blueprints.concat(getBlueprint(module, {
        stone: {}
      }));
    } else if (hasMetadata(module, CONFIGURATION_KEY) && isConstructor(module)) {
      // Imperative configuration
      const options = getMetadata(module, CONFIGURATION_KEY, {
        live: false
      });
      if (options.live !== true) {
        await new module.prototype.constructor().configure(context.blueprint);
      } else {
        context.blueprint.add('stone.liveConfigurations', [{
          ...options,
          module
        }]);
      }
    }
  }
  // Imperative configuration takes precedence over declarative configuration
  context.blueprint.setItems(mergeBlueprints(...blueprints, context.blueprint.all()));
  return await next(context);
};
/**
 * Middleware to set the application entry point in the blueprint.
 *
 * This middleware identifies the module marked as the main application entry point and sets it in the
 * blueprint as the handler. If no entry point is found, an error is thrown.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * ApplicationEntryPointMiddleware({ modules, blueprint }, next);
 * ```
 */
const ApplicationEntryPointMiddleware = async (context, next) => {
  const blueprint = await next(context);
  const module = context.modules.find(module => hasMetadata(module, STONE_APP_KEY));
  // Set the application entry point as the fallback 
  // main handler in the blueprint if not already set
  if (module !== undefined) {
    const metaApp = {
      ...getMetadata(module, STONE_APP_KEY, {}),
      module
    };
    blueprint.set('stone.application', metaApp);
    !blueprint.has('stone.handler.module') && blueprint.set('stone.handler', metaApp);
  }
  if (!blueprint.has('stone.handler.module')) {
    throw new SetupError('No main event handler found. Every Stone.js app must define one main event handler.');
  }
  return blueprint;
};
/**
 * Middleware to set the current adapter configuration in the blueprint.
 *
 * This middleware checks if there is only one adapter in the list, if yes return it,
 * otherwise it looks for the preferred adapter, followed by the adapter with the matching alias,
 * and finally the default adapter. The selected adapter is then set in the blueprint.
 *
 * @param context - The configuration context containing the modules and blueprint.
 * @param next - The next function in the pipeline to continue processing.
 * @returns The updated blueprint or a promise resolving to the updated blueprint.
 *
 * @example
 * ```typescript
 * await SetCurrentAdapterMiddleware({ modules, blueprint }, next);
 * ```
 */
const SetCurrentAdapterMiddleware = async (context, next) => {
  const current = context.blueprint.get('stone.adapter');
  const adapters = context.blueprint.get('stone.adapters', []);
  const adapter = adapters.length === 1 ? adapters[0] : adapters.find(v => v.current === true) ?? adapters.find(v => v.alias === current?.alias) ?? adapters.find(v => v.platform === current?.platform) ?? adapters.find(v => v.default === true) ?? {};
  context.blueprint.set('stone.adapter', adapter);
  return await next(context);
};
/**
 * Middleware to add service providers to the blueprint.
 *
 * This middleware identifies modules marked as service providers and adds them to the blueprint's
 * list of providers.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * ProviderMiddleware({ modules, blueprint }, next);
 * ```
 */
const ProviderMiddleware = async (context, next) => {
  const providers = context.modules.filter(module => hasMetadata(module, PROVIDER_KEY)).map(module => ({
    ...getMetadata(module, PROVIDER_KEY, {}),
    module
  }));
  context.blueprint.add('stone.providers', providers);
  return await next(context);
};
/**
 * Middleware to register service providers to the `onInit` hook of the current adapter.
 *
 * This middleware filters modules to identify service providers that implement the `onInit` hook,
 * and adds them to the `onInit` lifecycle event of the current adapter.
 *
 * @param {ConfigContext} context - The configuration context containing the modules and blueprint.
 * @param {NextPipe<ConfigContext, IBlueprint>} next - The next function in the middleware pipeline.
 * @returns {IBlueprint | Promise<IBlueprint>} - Returns the updated blueprint or a promise resolving to it.
 *
 * @example
 * ```typescript
 * await RegisterProviderToOnInitHookMiddleware({ modules, blueprint }, next);
 * ```
 */
const RegisterProviderToOnInitHookMiddleware = async (context, next) => {
  const adapter = context.blueprint.get('stone.adapter');
  const providers = context.modules.filter(module => hasMetadata(module, PROVIDER_KEY));
  if (adapter !== undefined) {
    providers.map(provider => provider).filter(provider => provider.onInit !== undefined).forEach(provider => {
      adapter.hooks ??= {};
      adapter.hooks.onInit ??= [];
      adapter.hooks.onInit = adapter.hooks.onInit.concat(async v => await provider.onInit(v));
    });
  }
  return await next(context);
};
/**
 * Middleware to add error handlers to the blueprint.
 *
 * This middleware identifies modules marked as error handlers and adds them to the blueprint's list
 * of kernel.errorhandlers.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * ErrorHandlerMiddleware({ modules, blueprint }, next);
 * ```
 */
const ErrorHandlerMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, ERROR_HANDLER_KEY)).forEach(module => {
    const options = getMetadata(module, ERROR_HANDLER_KEY, {
      error: 'default'
    });
    const errorHandlers = Array(options.error).flat().map(error => ({
      ...options,
      error,
      module
    }));
    context.blueprint.add('stone.kernel.errorHandlers', errorHandlers);
  });
  return await next(context);
};
/**
 * Middleware to add adapter error handlers to the blueprint.
 *
 * This middleware identifies modules marked as adapter error handlers and adds them to the blueprint's list
 * of adapter.errorhandlers.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * AdapterErrorHandlerMiddleware({ modules, blueprint }, next);
 * ```
 */
const AdapterErrorHandlerMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, ADAPTER_ERROR_HANDLER_KEY)).forEach(module => {
    const options = getMetadata(module, ADAPTER_ERROR_HANDLER_KEY, {
      error: 'default'
    });
    const errorHandlers = Array(options.error).flat().map(error => ({
      ...options,
      error,
      module
    }));
    context.blueprint.add('stone.adapter.errorHandlers', errorHandlers);
  });
  return await next(context);
};
/**
 * Middleware to add services to the blueprint.
 *
 * This middleware identifies modules marked as services and adds them to the blueprint's list
 * of services.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * ServiceMiddleware({ modules, blueprint }, next);
 * ```
 */
const ServiceMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, SERVICE_KEY)).forEach(module => {
    const options = getMetadata(module, SERVICE_KEY, {
      alias: ''
    });
    context.blueprint.add('stone.services', [{
      ...options,
      module
    }]);
  });
  return await next(context);
};
/**
 * Middleware to add listeners to the blueprint.
 *
 * This middleware processes modules marked as listeners and associates them with the relevant
 * events within the blueprint. Throws an error if no event name is provided for a listener.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * ListenerMiddleware({ modules, blueprint }, next);
 * ```
 */
const ListenerMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, LISTENER_KEY)).forEach(module => {
    const options = getMetadata(module, LISTENER_KEY, {
      event: ''
    });
    if (options.event === undefined || options.event.length === 0) {
      throw new SetupError(`No event name provided for this listener ${String(typeof module)}`);
    }
    context.blueprint.add('stone.listeners', [{
      ...options,
      module
    }]);
  });
  return await next(context);
};
/**
 * Middleware to add subscribers to the blueprint.
 *
 * This middleware identifies modules marked as subscribers and adds them to the blueprint's
 * list of subscribers.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * SubscriberMiddleware({ modules, blueprint }, next);
 * ```
 */
const SubscriberMiddleware = async (context, next) => {
  const subscribers = context.modules.filter(module => hasMetadata(module, SUBSCRIBER_KEY)).map(module => ({
    ...getMetadata(module, SUBSCRIBER_KEY, {}),
    module
  }));
  context.blueprint.add('stone.subscribers', subscribers);
  return await next(context);
};
/**
 * Middleware to add adapter-specific middleware to the blueprint.
 *
 * This middleware processes modules marked as adapter middleware and associates them with the
 * appropriate adapter configuration in the blueprint.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * AdapterMiddlewareMiddleware({ modules, blueprint }, next);
 * ```
 */
const AdapterMiddlewareMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, ADAPTER_MIDDLEWARE_KEY)).forEach(module => {
    const options = getMetadata(module, ADAPTER_MIDDLEWARE_KEY, {});
    const middleware = {
      ...options,
      module
    };
    context.blueprint.get('stone.adapters', []).forEach(adapter => {
      adapter.middleware ??= [];
      if (options.platform === undefined) {
        adapter.middleware.push(middleware);
      } else if (options.alias === adapter.alias) {
        adapter.middleware.push(middleware);
      } else if (options.platform === adapter.platform) {
        adapter.middleware.push(middleware);
      }
    });
  });
  return await next(context);
};
/**
 * Middleware to add global and specific middleware to the kernel blueprint.
 *
 * This middleware processes modules marked as general middleware and associates them with the
 * kernel's configuration in the blueprint.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * MiddlewareMiddleware({ modules, blueprint }, next);
 * ```
 */
const MiddlewareMiddleware = async (context, next) => {
  context.modules.filter(module => hasMetadata(module, MIDDLEWARE_KEY)).forEach(module => {
    const options = getMetadata(module, MIDDLEWARE_KEY, {});
    const middleware = {
      ...options,
      module
    };
    options.global === true && context.blueprint.add('stone.kernel.middleware', [middleware]);
  });
  return await next(context);
};
/**
 * Array representing the core configuration middleware for the application.
 *
 * This array contains the list of core middleware functions that are used to process the application
 * configuration in a specific order. Each middleware is associated with a priority that determines
 * the sequence in which it is executed. Middleware functions are used to build the application's blueprint,
 * set up the adapter, register providers, and handle other essential configuration steps.
 *
 * @type {MetaPipe[]}
 * @example
 * ```typescript
 * import { coreConfigMiddleware } from './coreConfigMiddleware';
 *
 * // The middleware will be used to configure the application's settings before it starts.
 * ```
 */
const coreConfigMiddleware = [{
  module: BlueprintMiddleware,
  priority: 0
}, {
  module: ApplicationEntryPointMiddleware,
  priority: 0.1
}, {
  module: SetCurrentAdapterMiddleware,
  priority: 0.5
}, {
  module: ProviderMiddleware,
  priority: 0.6
}, {
  module: ServiceMiddleware,
  priority: 0.7
}, {
  module: ListenerMiddleware,
  priority: 0.7
}, {
  module: SubscriberMiddleware,
  priority: 0.7
}, {
  module: ErrorHandlerMiddleware,
  priority: 0.7
}, {
  module: AdapterErrorHandlerMiddleware,
  priority: 0.7
}, {
  module: RegisterProviderToOnInitHookMiddleware,
  priority: 0.7
}, {
  module: AdapterMiddlewareMiddleware,
  priority: 3
}, {
  module: MiddlewareMiddleware,
  priority: 3
}];

/**
 * Class representing a generic AdapterEventBuilder.
 *
 * This class provides a builder pattern to construct an object of type `R` based on options of type `V`.
 * It is intended to handle complex object creation by allowing flexible modification of options and resolving the final object.
 *
 * @template V - The type of the options used to build the final object. Must be an object.
 * @template R - The type of the final object that will be built.
 */
class AdapterEventBuilder {
  /**
   * The options used for building the final object.
   */
  options;
  /**
   * The resolver function that takes the options and returns the final object of type `R`.
   */
  resolver;
  /**
   * Static method to create a new AdapterEventBuilder instance.
   *
   * @param options - The options for creating the AdapterEventBuilder instance, including the initial options and the resolver function.
   * @returns A new instance of AdapterEventBuilder.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs an AdapterEventBuilder.
   *
   * @param options - The options for creating the AdapterEventBuilder instance, including the initial options and the resolver function.
   * @protected
   */
  constructor({
    options,
    resolver
  }) {
    if (typeof resolver !== 'function') {
      throw new IntegrationError('Resolver is required to create an AdapterEventBuilder instance.');
    }
    this.resolver = resolver;
    /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions */
    this.options = options ?? {};
  }
  /**
   * Adds or updates a key-value pair in the options.
   *
   * @param key - The key in the options to be updated.
   * @param value - The value to set for the given key.
   * @returns This instance of AdapterEventBuilder for method chaining.
   */
  add(key, value) {
    this.options[key] = value;
    return this;
  }
  /**
   * Builds the final object by using the resolver function with the current options.
   *
   * @returns The final object of type `R`.
   */
  build() {
    return this.resolver(this.options);
  }
}

/**
 * **Default Logger Configuration**
 *
 * The `logger` constant provides a default setup for the logger.
 * It includes the following default settings:
 *
 * - **Log Level**: `'error'`  Only logs error messages.
 * - **Color Output**: Disabled  Logs are displayed without color formatting.
 * - **Timestamp**: Disabled  Timestamps are not included in log messages.
 * - **Resolver**: `defaultLoggerResolver`  Uses the default logger resolver function.
 *
 * This default configuration can be overridden by providing a custom `LoggerConfig` object.
 */
const logger = {
  level: 'error',
  useColors: false,
  useTimestamp: false,
  resolver: defaultLoggerResolver
};

/**
 * Global app-level settings for all adapters.
 *
 * This object defines the kernel-level settings for middleware, which apply to all adapters.
 * It allows you to configure middleware behavior, including event processing, response handling,
 * and termination processing.
 */
const kernel = {
  middleware: [],
  resolver: defaultKernelResolver,
  responseResolver: defaultResponseResolver
};

/**
 * Options builder namespace.
 *
 * This object defines the main builder options for constructing the blueprint.
 * It includes middleware definitions and the default priority for those pipes.
 */
const builder = {
  // Here you can define middleware to build the Blueprint.
  // Middleware consists of core pipes and custom pipes used in the blueprint construction process.
  middleware: [...coreConfigMiddleware],
  // Here you can define the default priority for pipes.
  // It will be used when a pipe does not have a priority.
  defaultMiddlewarePriority: 10
};

/**
 * Common adapters settings.
 *
 * This array defines the collection of adapters and their respective configurations.
 */
const adapters = [];

/**
 * Environment settings.
 */
var Environment;
(function (Environment) {
  Environment["Test"] = "test";
  Environment["Production"] = "production";
  Environment["Development"] = "development";
})(Environment || (Environment = {}));
/**
 * Stone main options.
 *
 * This object defines the main configuration options for the Stone.js framework.
 * It includes settings for middleware, adapters, application-level configurations,
 * logging, services, listeners, subscribers, providers, and aliases.
 *
 * @returns {StoneBlueprint}
 */
const stoneBlueprint = {
  // App namespace.
  // Here you can define application-level settings.
  stone: {
    // The name of your application.
    name: 'Stone.js',
    // The "environment" your application is currently running in (e.g., development, production).
    env: Environment.Production,
    // Whether your application is in debug mode.
    // Useful for showing detailed error messages with stack traces.
    debug: false,
    // The default timezone for your application.
    timezone: 'UTC',
    // The default locale for your application.
    locale: 'en',
    // The fallback locale for your application.
    fallback_locale: 'en',
    // Options builder namespace.
    builder,
    // Adapters namespace.
    // Here you can define adapter settings.
    adapters,
    // Global app-level settings for all adapters.
    kernel,
    // Logging settings for all adapters.
    logger,
    // Services to be automatically registered when the application starts.
    services: [],
    // Listeners to be automatically registered when the application starts.
    listeners: [],
    // Subscribers to be automatically registered when the application starts.
    subscribers: [],
    // Service providers to be automatically loaded at each request to your application.
    providers: [CoreServiceProvider],
    // Class aliases to be registered when the application starts.
    aliases: {}
  }
};

/**
 * Class representing an IncomingEvent.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 *
 * @extends Event
 */
class IncomingEvent extends Event {
  /**
   * INCOMING_EVENT Event name, fires on platform message.
   *
   * @event IncomingEvent#INCOMING_EVENT
   */
  static INCOMING_EVENT = 'stonejs@incoming_event';
  /**
   * The locale of the event.
   */
  locale;
  /**
   * The source of the event.
   */
  source;
  /**
   * Create an IncomingEvent.
   *
   * @param options - The options to create an IncomingEvent.
   * @returns A new IncomingEvent instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Create an IncomingEvent.
   *
   * @param options - The options to create an IncomingEvent.
   */
  constructor({
    source,
    locale = 'en',
    metadata = {},
    timeStamp = Date.now(),
    type = IncomingEvent.INCOMING_EVENT
  }) {
    super({
      type,
      metadata,
      timeStamp
    });
    this.locale = locale;
    this.source = source;
  }
}

/**
 * Defines a factory handler with metadata for the provided handler function.
 * This function allows users to define a factory handler with metadata.
 *
 * @param module - The module handler function to be defined.
 * @returns The defined factory handler with metadata.
*/
const factoryHandler = module => {
  return {
    module,
    isFactory: true
  };
};
/**
 * Regular expression for extracting path constraints from route segments.
 */
const pathConstraintRegex = /^(.+?)?[:{](.+?)(?:@(.+?))?(?:\((.+?)\))?([?*+]?)(?:=(.+?))?\}?$/;
/**
 * Regular expression for extracting domain constraints from route options.
 */
const domainConstraintRegex = /^(?:\{(.+?)(?:@(.+?))?(?:\((.+?)\))?([?*+]?)(?:=(.+?))?\})?(.+)$/;
/**
 * Builds a regular expression for matching a full URI based on route options.
 *
 * @param options - The route options to build the regex from.
 * @param flags - Regular expression flags, defaults to 'i' (case insensitive).
 * @returns A regular expression for matching URIs.
 *
 * @example
 * ```typescript
 * const regex = uriRegex({ path: '/users/:id', strict: false });
 * console.log(regex.test('/users/123')); // true
 * ```
 */
const uriRegex = (options, flags = 'i') => {
  flags = options.strict === true ? '' : flags;
  const domain = buildDomainPattern(getDomainConstraints(options)) ?? '';
  const trailingSlash = options.strict === true ? options.path.endsWith('/') ? '/' : '' : '/?';
  const path = getSegmentsConstraints(options).reduce((prev, curr) => `${prev}${buildSegmentPattern(curr)}`, '');
  return new RegExp(`^${domain}${path}${trailingSlash}$`, flags);
};
/**
 * Builds a regular expression for matching route paths based on route options.
 *
 * @param options - The route options to build the regex from.
 * @param flags - Regular expression flags, defaults to 'i' (case insensitive).
 * @returns A regular expression for matching route paths.
 *
 * @example
 * ```typescript
 * const regex = pathRegex({ path: '/users/:id', strict: false });
 * console.log(regex.test('/users/123')); // true
 * ```
 */
const pathRegex = (options, flags = 'i') => {
  flags = options.strict === true ? '' : flags;
  const trailingSlash = options.strict === true ? options.path.endsWith('/') ? '/' : '' : '/?';
  const pattern = getSegmentsConstraints(options).reduce((prev, curr) => `${prev}${buildSegmentPattern(curr)}`, '');
  return new RegExp(`^${pattern}${trailingSlash}$`, flags);
};
/**
 * Builds a regular expression for matching domains based on route options.
 *
 * @param options - The route options to build the regex from.
 * @param flags - Regular expression flags, defaults to 'i' (case insensitive).
 * @returns A regular expression for matching domains or undefined if no domain is specified.
 *
 * @example
 * ```typescript
 * const regex = domainRegex({ domain: '{subdomain}.example.com' });
 * console.log(regex?.test('api.example.com')); // true
 * ```
 */
const domainRegex = (options, flags = 'i') => {
  flags = options.strict === true ? '' : flags;
  const pattern = options.domain !== undefined ? buildDomainPattern(getDomainConstraints(options)) : undefined;
  return pattern !== undefined ? new RegExp(`^${pattern}$`, flags) : undefined;
};
/**
 * Builds a domain pattern based on a route segment constraint.
 *
 * @param constraint - Partial route segment constraint for domain matching.
 * @returns A string representing the domain pattern or undefined.
 */
const buildDomainPattern = constraint => {
  if (constraint?.param === undefined) {
    return constraint?.suffix;
  }
  return constraint.optional === true ? `(${stringifyRegex(constraint.rule)})?${String(constraint.suffix)}` : `(${stringifyRegex(constraint.rule)})${String(constraint.suffix)}`;
};
/**
 * Builds a path segment pattern based on a route segment constraint.
 *
 * @param constraint - Partial route segment constraint for path matching.
 * @returns A string representing the path pattern.
 */
const buildSegmentPattern = constraint => {
  if (constraint === undefined) {
    return '/';
  } else if (constraint.param === undefined) {
    return `/${String(constraint.match)}`;
  } else if (constraint.prefix !== undefined) {
    switch (constraint.quantifier) {
      case '?':
        return `/${String(constraint.prefix)}(${stringifyRegex(constraint.rule)})?`;
      case '+':
        return `/${String(constraint.prefix)}((?:${stringifyRegex(constraint.rule)})(?:/(?:${stringifyRegex(constraint.rule)}))*)`;
      case '*':
        return `/${String(constraint.prefix)}((?:${stringifyRegex(constraint.rule)})(?:/(?:${stringifyRegex(constraint.rule)}))*)?`;
      default:
        return `/${String(constraint.prefix)}(${stringifyRegex(constraint.rule)})`;
    }
  } else {
    switch (constraint.quantifier) {
      case '?':
        return `(?:/(${stringifyRegex(constraint.rule)}))?`;
      case '+':
        return `/((?:${stringifyRegex(constraint.rule)})(?:/(?:${stringifyRegex(constraint.rule)}))*)`;
      case '*':
        return `(?:/((?:${stringifyRegex(constraint.rule)})(?:/(?:${stringifyRegex(constraint.rule)}))*))?`;
      default:
        return `/(${stringifyRegex(constraint.rule)})`;
    }
  }
};
/**
 * Generates an array of URI constraints based on route options.
 *
 * @param options - The route options to extract constraints from.
 * @returns An array of partial route segment constraints.
 */
const uriConstraints = options => {
  return [getDomainConstraints(options), getSegmentsConstraints(options)].flat().filter(v => v !== undefined);
};
/**
 * Extracts domain constraints from route options.
 *
 * @param options - The route options to extract domain constraints from.
 * @returns Partial route segment constraint for the domain or undefined.
 */
const getDomainConstraints = options => {
  let domainConstraints;
  if (options.domain !== undefined) {
    const keys = ['match', 'param', 'alias', 'rule', 'quantifier', 'default', 'suffix'];
    domainConstraints ??= options.domain.match(domainConstraintRegex)?.filter((_, i) => i < keys.length).reduce((prev, curr, i) => ({
      ...prev,
      [keys[i]]: curr
    }), {});
    if (domainConstraints?.param !== undefined) {
      domainConstraints.rule ??= options.rules?.[domainConstraints.param];
      domainConstraints.default ??= options.defaults?.[domainConstraints.param];
      domainConstraints.optional = /^[?*]$/.test(String(domainConstraints.quantifier));
    }
  }
  return domainConstraints;
};
/**
 * Extracts path segment constraints from route options.
 *
 * @param options - The route options to extract constraints from.
 * @returns An array of partial segment constraints for the path.
 */
const getSegmentsConstraints = options => {
  return options.path.split('/').filter(segment => segment.trim().length > 0).map(segment => {
    if (/[:}]/.test(segment)) {
      const keys = ['match', 'prefix', 'param', 'alias', 'rule', 'quantifier', 'default'];
      return segment.match(pathConstraintRegex)?.filter((_, i) => i < keys.length)?.reduce((prev, curr, i) => ({
        ...prev,
        [keys[i]]: curr
      }), {});
    } else {
      return {
        match: segment
      };
    }
  }).filter(segment => segment !== undefined).map(segment => {
    if (segment?.param !== undefined) {
      segment.rule ??= options.rules?.[segment.param];
      segment.default ??= options.defaults?.[segment.param];
      segment.optional = /^[?*]$/.test(String(segment.quantifier));
    }
    return segment;
  });
};
const stringifyRegex = pattern => {
  return pattern instanceof RegExp ? pattern?.source : pattern ?? '.+';
};

/**
 * Matches the host of an incoming HTTP event against a route's host configuration.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The matcher options containing the route and event.
 * @returns `true` if the host matches or if no specific host is configured.
 *
 * @example
 * ```typescript
 * const match = hostMatcher({ route, event });
 * console.log(match); // true or false
 * ```
 */
function hostMatcher({
  route,
  event
}) {
  return domainRegex(route.options) === undefined || domainRegex(route.options)?.test(event.host) === true;
}
/**
 * Matches the HTTP method of an incoming HTTP event against a route's method configuration.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The matcher options containing the route and event.
 * @returns `true` if the method matches, otherwise `false`.
 *
 * @example
 * ```typescript
 * const match = methodMatcher({ route, event });
 * console.log(match); // true or false
 * ```
 */
function methodMatcher({
  route,
  event
}) {
  return route.getOption('method') === event.method;
}
/**
 * Matches the protocol (HTTP or HTTPS) of an incoming HTTP event against a route's configuration.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The matcher options containing the route and event.
 * @returns `true` if the protocol matches the route's requirements, otherwise `false`.
 *
 * @example
 * ```typescript
 * const match = protocolMatcher({ route, event });
 * console.log(match); // true or false
 * ```
 */
function protocolMatcher({
  route,
  event
}) {
  if (route.isHttpOnly()) {
    return event.isSecure !== true;
  } else if (route.isHttpsOnly()) {
    return event.isSecure === true;
  } else {
    return true;
  }
}
/**
 * Matches the URI of an incoming HTTP event against a route's path configuration.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The matcher options containing the route and event.
 * @returns `true` if the URI matches the route's configuration, otherwise `false`.
 *
 * @example
 * ```typescript
 * const match = uriMatcher({ route, event });
 * console.log(match); // true or false
 * ```
 */
function uriMatcher({
  route,
  event
}) {
  return pathRegex(route.options).test(event.decodedPathname ?? event.pathname);
}

/**
 * Custom error for Integration layer operations.
 */
class RouterError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'RouterError';
  }
}

/**
 * Custom error for Integration layer operations.
 */
class RouteNotFoundError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'RouteNotFoundError';
  }
}

/**
 * Represents a route that defines how incoming events are handled.
 *
 * @template IncomingEventType - The type of the incoming event.
 * @template OutgoingResponseType - The type of the outgoing response.
 */
class Route {
  options;
  eventUrl;
  resolver;
  routeParams;
  eventQuery;
  matchers;
  dispatchers;
  uriConstraints;
  /**
   * Factory method for creating a route instance.
   *
   * @param options - Configuration options for the route.
   * @returns A new `Route` instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Creates a new `Route` instance.
   *
   * @param options - Configuration options for the route.
   * @returns A new `Route` instance.
   */
  constructor(options) {
    this.options = options;
    this.validateOptions(options);
    this.matchers = [];
    this.uriConstraints = uriConstraints(options);
  }
  /**
   * Gets the parameters extracted from the route.
   *
   * @throws {RouterError} If the event is not bound.
   * @returns The route parameters.
   */
  get params() {
    if (this.routeParams !== undefined) {
      return this.routeParams;
    } else {
      throw new RouterError('Event is not bound');
    }
  }
  /**
   * Gets the URL of the event.
   *
   * @returns The event URL or a default URL (`http://localhost`).
   */
  get url() {
    return this.eventUrl ?? new URL('http://localhost');
  }
  /**
   * Gets the full URI of the route.
   *
   * @returns The full URI as a string.
   */
  get uri() {
    return this.url.href;
  }
  /**
   * Gets the pathname of the route.
   *
   * @returns The pathname as a string.
   */
  get path() {
    return this.url.pathname;
  }
  /**
   * Gets the query parameters from the event URL.
   *
   * @returns A record of query parameters.
   */
  get query() {
    return this.eventQuery ?? {};
  }
  /**
   * Gets the hash fragment from the event URL.
   *
   * @returns The hash fragment as a string.
   */
  get hash() {
    return this.url.hash;
  }
  /**
   * Gets the protocol for the route.
   *
   * @returns The protocol as a string (`http` or `https`).
   */
  get protocol() {
    return this.options.protocol ?? this.url.protocol.replace(':', '').trim();
  }
  /**
   * Gets the HTTP method for the route.
   *
   * @returns The HTTP method.
   */
  get method() {
    return this.options.method;
  }
  /**
   * Gets the hostname of the route.
   *
   * @returns The hostname as a string.
   */
  get domain() {
    return this.url.hostname;
  }
  /**
   * Checks if the route has a domain constraint.
   *
   * @returns `true` if the route has a domain constraint, otherwise `false`.
   */
  hasDomain() {
    return this.options.domain !== undefined;
  }
  /**
   * Checks if the route has any parameters.
   *
   * @returns `true` if parameters are present, otherwise `false`.
   */
  hasParams() {
    return Object.keys(this.params).length > 0;
  }
  /**
   * Checks if the route has a specific parameter.
   *
   * @param name - The name of the parameter to check.
   * @returns `true` if the parameter exists, otherwise `false`.
   */
  hasParam(name) {
    return this.params[name] !== undefined;
  }
  /**
   * Retrieves the value of a specific parameter.
   *
   * @param name - The name of the parameter to retrieve.
   * @param fallback - An optional fallback value if the parameter is not found.
   * @returns The value of the parameter or the fallback value if not found.
   */
  getParam(name, fallback) {
    return this.params[name] ?? fallback;
  }
  /**
   * Retrieves all parameters that are defined (non-undefined values).
   *
   * @returns A record of defined parameters.
   */
  getDefinedParams() {
    return Object.fromEntries(Object.entries(this.params).filter(([_, value]) => value !== undefined));
  }
  /**
   * Retrieves the names of all parameters.
   *
   * @returns An array of parameter names.
   */
  getParamNames() {
    return Object.keys(this.params);
  }
  /**
   * Retrieves the names of all optional parameters.
   *
   * @returns An array of optional parameter names.
   */
  getOptionalParamNames() {
    return this.getParamNames().filter(param => this.uriConstraints.find(v => v.param === param)?.optional === true);
  }
  /**
   * Checks if a parameter name is optional.
   *
   * @param name - The name of the parameter to check.
   * @returns `true` if the parameter is optional, otherwise `false`.
   */
  isParamNameOptional(name) {
    return this.getOptionalParamNames().includes(name);
  }
  /**
   * Retrieves a specified option from the route configuration.
   *
   * @param key - The key of the option to retrieve.
   * @param fallback - An optional fallback value if the option is not found.
   * @returns The value of the option or the fallback value if not found.
   */
  getOption(key, fallback) {
    return this.options[key] ?? fallback;
  }
  /**
   * Retrieves a specified options from the route configuration.
   *
   * @param keys - The kesy of the option to retrieve.
   * @returns The values of the option.
   */
  getOptions(keys) {
    return Object.fromEntries(keys.map(key => [key, this.options[key]]));
  }
  /**
   * Adds a middleware to the route.
   *
   * @param middleware - The middleware to add.
   * @returns The updated `Route` instance.
   */
  addMiddleware(middleware) {
    this.options.middleware = (this.options.middleware ?? []).concat(middleware);
    return this;
  }
  /**
   * Checks if the route requires HTTPS for security.
   *
   * @returns `true` if the route is HTTPS-only, otherwise `false`.
   */
  isSecure() {
    return this.isHttpsOnly();
  }
  /**
   * Checks if the route uses HTTP protocol.
   *
   * @returns `true` if the route is HTTP-only, otherwise `false`.
   */
  isHttpOnly() {
    return this.protocol === 'http';
  }
  /**
   * Checks if the route uses HTTPS protocol.
   *
   * @returns `true` if the route is HTTPS-only, otherwise `false`.
   */
  isHttpsOnly() {
    return this.protocol === 'https';
  }
  /**
   * Checks if the route is marked as a fallback route.
   *
   * @returns `true` if the route is a fallback, otherwise `false`.
   */
  isFallback() {
    return this.options.fallback ?? false;
  }
  /**
   * Checks if the route operates in strict mode.
   *
   * @returns `true` if the route is strict, otherwise `false`.
   */
  isStrict() {
    return this.options.strict === true;
  }
  /**
   * Determines if a specific middleware is excluded from execution.
   *
   * @param mixedMiddleware - The middleware to check.
   * @returns `true` if the middleware is excluded, otherwise `false`.
   */
  isMiddlewareExcluded(mixedMiddleware) {
    const metaMid = mixedMiddleware;
    const middleware = isFunctionPipe(metaMid) ? mixedMiddleware : metaMid.module;
    return this.getOption('excludeMiddleware')?.includes(middleware) === true;
  }
  /**
   * Checks if the route matches the provided options.
   *
   * @param options - The options to match against the route.
   * @returns `true` if the route matches the options, otherwise `false`.
  */
  matchesOptions(options) {
    return Object.entries(options).reduce((matched, [key, value]) => matched && this.options[key] === value, true);
  }
  /**
   * Checks if the provided event matches the route.
   *
   * @param event - The incoming event to check against the route.
   * @param includingMethod - Whether to include HTTP method matching in the evaluation.
   * @returns `true` if the event matches the route, otherwise `false`.
   */
  matches(event, includingMethod) {
    return this.matchers.filter(matcher => !(!includingMethod && matcher === methodMatcher)) // Skip method matcher if not needed
    .reduce((matched, matcher) => matched && matcher({
      route: this,
      event
    }), true);
  }
  /**
   * Binds the provided event to the route, initializing route parameters and query data.
   *
   * @param event - The incoming event to bind to the route.
   * @returns A promise that resolves once the binding is complete.
   */
  async bind(event) {
    this.eventUrl = event.url;
    this.routeParams = await this.bindParameters(event);
    this.eventQuery = Object.fromEntries(event.query?.entries() ?? []);
  }
  /**
   * Executes the route's action based on the provided event.
   *
   * @param event - The incoming event to handle.
   * @returns A promise that resolves to the outgoing response generated by the route's action.
   * @throws `RouterError` if the route action is invalid.
   */
  async run(event) {
    if (this.isRedirection()) {
      return await this.runRedirection(event, this.options.redirect);
    } else if (this.isHandler()) {
      return await this.runHandler(event);
    } else if (this.isCallable()) {
      return await this.runCallable(event);
    } else if (this.isComponent()) {
      return await this.runComponent(event);
    } else {
      throw new RouterError('Invalid handler provided.');
    }
  }
  /**
   * Generates a URL or URI for the route with optional parameters, query, hash, and protocol.
   *
   * @param options - Options for generating the URL.
   *   - `params`: Route parameters to include in the path.
   *   - `query`: Query parameters to append to the URL.
   *   - `hash`: A hash fragment to include in the URL.
   *   - `withDomain`: Whether to include the domain in the URL.
   *   - `protocol`: The protocol to use in the URL.
   * @returns The generated URL as a string.
   * @throws `RouterError` if required parameters are missing.
   */
  generate({
    params = {},
    query = {},
    hash = '',
    withDomain = false,
    protocol
  }) {
    // Helper to construct hash value
    const formatHash = hash => hash.length > 0 ? hash.startsWith('#') ? hash : `#${hash}` : '';
    // Build query parameters
    const queryParams = new URLSearchParams(Object.entries(params).filter(([name]) => !this.uriConstraints.some(constraint => constraint.param === name)).concat(Object.entries(query))).toString();
    // Build path from URI constraints
    const path = this.uriConstraints.reduce((prevPath, constraint) => {
      const paramValue = params[constraint.param ?? ''] ?? constraint.default;
      // Validate required parameters
      if (constraint.param !== undefined && constraint.optional !== true && paramValue === undefined) {
        throw new RouterError(`Missing required parameter "${String(constraint.param)}"`);
      }
      // Handle domain constraints
      if (withDomain && constraint.suffix !== undefined) {
        return [protocol ?? this.protocol, '://', paramValue, constraint.suffix, prevPath].filter(Boolean).join('');
      }
      // Append path segments
      return [prevPath, constraint.prefix, constraint.param !== undefined ? paramValue : constraint.match, '/'].filter(Boolean).join('');
    }, '/').replace(/(?<!:)(\/{2,})/g, '/'); // Replace redundant slashes
    // Combine path, query, and hash
    return [path, queryParams?.length > 0 && `?${queryParams}`, formatHash(hash)].filter(Boolean).join('');
  }
  /**
   * Sets the resolver for the route.
   * The resolver is used to resolve the route's handler.
   *
   * @param resolver - The resolver to set.
   * @returns The updated `Route` instance.
   */
  setResolver(resolver) {
    this.resolver = resolver;
    return this;
  }
  /**
   * Sets the matchers to use for evaluating if an event matches the route.
   *
   * @param matchers - An array of matchers to set.
   * @returns The updated `Route` instance.
   */
  setMatchers(matchers) {
    this.matchers = matchers;
    return this;
  }
  /**
   * Sets the dispatchers for handling callable or handler actions.
   *
   * @param dispatchers - The dispatchers to set.
   * @returns The updated `Route` instance.
   */
  setDispatchers(dispatchers) {
    this.dispatchers = dispatchers;
    return this;
  }
  /**
   * Converts the route into a JSON object representation.
   *
   * @returns A JSON object representing the route.
   */
  toJSON() {
    return {
      path: this.options.path,
      method: this.options.method,
      handler: this.isHandler() ? this.getHandlerFullname() : 'callable',
      name: this.options.name ?? 'N/A',
      domain: this.options.domain ?? 'N/A',
      fallback: this.isFallback()
    };
  }
  /**
   * Converts the route into a string representation (JSON format).
   *
   * @returns A JSON string representing the route.
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  isRedirection() {
    return this.options.redirect !== undefined;
  }
  isCallable() {
    return isMetaFactoryModule(this.options.handler) || isMetaFunctionModule(this.options.handler) || isFunctionModule(this.options.handler);
  }
  isHandler() {
    return isMetaClassModule(this.options.handler);
  }
  isComponent() {
    return this.options.handler === undefined && this.options.component !== undefined;
  }
  getCallable() {
    if (isMetaFactoryModule(this.options.handler)) {
      return this.options.handler.module(this.resolver);
    } else if (isMetaFunctionModule(this.options.handler)) {
      return this.options.handler.module;
    } else if (isFunctionModule(this.options.handler)) {
      return this.options.handler;
    } else {
      throw new RouterError('Invalid callable provided.');
    }
  }
  getHandlerClass() {
    if (isMetaClassModule(this.options.handler)) {
      return this.options.handler.module;
    } else {
      throw new RouterError('Invalid event handler provided.');
    }
  }
  getHandlerInstance() {
    return this.resolveModule(this.getHandlerClass());
  }
  getHandlerAction() {
    if (!isFunctionModule(this.options.handler)) {
      return this.options.handler.action;
    }
  }
  getHandlerFullname() {
    return `${this.getHandlerClass().name}@${String(this.getHandlerAction())}`;
  }
  async bindParameters(event) {
    if (event.getUri === undefined) {
      throw new RouterError('Event must have a `getUri` method.');
    }
    const params = {};
    const matches = event.getUri(this.hasDomain())?.match(uriRegex(this.options))?.filter((_v, i) => i > 0).map(v => !isNaN(Number(v)) ? parseFloat(v) : v);
    for (const [i, constraint] of this.uriConstraints.filter(({
      param
    }) => param !== undefined).entries()) {
      let value = matches?.[i];
      if (constraint.param !== undefined) {
        value = this.hasModelBinding(constraint.param) ? await this.bindValue(constraint.param, value, constraint.alias) : value;
        params[constraint.param] = value ?? constraint.default;
        if (params[constraint.param] === undefined && constraint.optional !== true) {
          throw new RouteNotFoundError(`No value found for this key "${String(constraint.param)}".`);
        }
      }
    }
    return Object.entries(this.options.defaults ?? {}).reduce((prev, [name, value]) => prev[name] !== undefined ? prev : {
      ...prev,
      [name]: value
    }, params);
  }
  hasModelBinding(key) {
    return this.options.bindings?.[key] !== undefined;
  }
  async bindValue(field, value, alias) {
    const key = alias ?? field;
    const bindingOptions = this.options.bindings?.[field];
    const bindingResolver = bindingOptions?.resolveRouteBinding ?? bindingOptions;
    if (typeof bindingResolver === 'function') {
      return await bindingResolver(key, value, this.resolver);
    } else {
      throw new RouterError('Binding must be either a class with a static bindingResolver method or a function.');
    }
  }
  getDispatcher(type) {
    if (this.dispatchers?.[type] === undefined) {
      throw new RouterError(`Dispatcher for ${type} not found`);
    } else {
      return this.dispatchers[type];
    }
  }
  async runCallable(event) {
    return await this.getDispatcher('callable')({
      event,
      handler: this.getCallable()
    });
  }
  async runHandler(event) {
    return await this.getDispatcher('handler')({
      event,
      action: this.getHandlerAction(),
      handler: this.getHandlerInstance()
    });
  }
  async runComponent(_event) {
    return {
      layout: this.options.layout,
      component: this.options.component
    };
  }
  async runRedirection(event, redirect, status = 302) {
    if (typeof redirect === 'object') {
      return await this.runRedirection(event, redirect.location, parseInt(redirect.status));
    } else if (typeof redirect === 'function') {
      return await this.runRedirection(event, await redirect(this, event));
    } else {
      return {
        status,
        statusCode: status,
        headers: {
          Location: redirect
        }
      };
    }
  }
  resolveModule(Class) {
    return this.resolver?.resolve(Class) ?? new Class();
  }
  validateOptions(options) {
    if (options === undefined) {
      throw new RouterError('Route options are required to create a Route instance');
    }
  }
}

// HTTP Methods
const GET = 'GET';
const PUT = 'PUT';
const HEAD = 'HEAD';
const POST = 'POST';
const PATCH = 'PATCH';
const DELETE = 'DELETE';
const OPTIONS = 'OPTIONS';
const HTTP_METHODS = [GET, PUT, HEAD, POST, PATCH, DELETE, OPTIONS];
// Node.js Console Platform name
const NODE_CONSOLE_PLATFORM = 'node_console';
// Navigation event
const NAVIGATION_EVENT = '@stonejs/router.navigate';

/**
 * Maps route definitions into concrete `Route` instances.
 *
 * @template IncomingEventType - Represents the type of incoming HTTP events.
 * @template OutgoingResponseType - Represents the type of outgoing HTTP responses.
 */
class RouteMapper {
  options;
  /**
   * Factory method to create a RouteMapper instance.
   *
   * @param options - Configuration options for the RouteMapper.
   * @returns A new RouteMapper instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs a RouteMapper instance.
   *
   * @param options - Configuration options for the RouteMapper.
   * @throws {RouterError} If `maxDepth` is not a positive integer.
   */
  constructor(options) {
    this.options = options;
    if (options.maxDepth <= 0) {
      throw new RouterError('Maximum depth must be a positive integer.');
    }
  }
  /**
   * Maps route definitions into Route instances.
   *
   * @param definitions - An array of route definitions.
   * @returns An array of Route instances.
   */
  toRoutes(definitions) {
    return this.flattenDefinitions(definitions).map(definition => Route.create(this.toRouteOptions(definition)).setMatchers(this.options.matchers));
  }
  /**
   * Flattens nested route definitions.
   *
   * @param definitions - An array of route definitions.
   * @param depth - Current recursion depth.
   * @returns An array of flattened route definitions.
   * @throws {RouterError} If maximum depth is exceeded.
   */
  flattenDefinitions(definitions, depth = 0) {
    if (depth >= this.options.maxDepth) {
      throw new RouterError(`Maximum route definition depth of ${String(this.options.maxDepth)} exceeded.`);
    }
    depth++;
    return definitions.flatMap(def => [def.path].flat().filter(Boolean).map(path => ({
      ...def,
      path
    }))).flatMap(def => this.gathersMethods(def).map(method => ({
      ...def,
      method
    }))).flatMap(def => [def.protocol].flat().map(protocol => ({
      ...def,
      protocol
    }))).flatMap(def => [def.domain].flat().map(domain => ({
      ...def,
      domain
    }))).flatMap(def => {
      if (!Array.isArray(def.children)) {
        return def.method === GET ? [def, {
          ...def,
          isInternalHeader: true,
          method: HEAD
        }] : def;
      }
      return this.flattenDefinitions(def.children, depth).map(child => this.mergeDefinitions(def, child));
    });
  }
  /**
   * Gathers all HTTP methods for a route definition.
   *
   * @param definition - The route definition to gather HTTP methods from.
   * @returns An array of HTTP methods
   */
  gathersMethods({
    method,
    methods
  }) {
    const values = [method, methods].flat().filter(v => isNotEmpty(v));
    values.length === 0 && values.push(GET);
    return values;
  }
  /**
   * Merges parent and child route definitions.
   *
   * @param parent - The parent route definition.
   * @param child - The child route definition.
   * @returns A merged route definition.
   */
  mergeDefinitions(parent, child) {
    child.rules = {
      ...parent.rules,
      ...child.rules
    };
    child.defaults = {
      ...parent.defaults,
      ...child.defaults
    };
    child.bindings = {
      ...parent.bindings,
      ...child.bindings
    };
    child.name = [parent.name, child.name].filter(Boolean).join('.');
    child.path = ['/', parent.path, child.path].filter(Boolean).join('/');
    child.middleware = [child.middleware, parent.middleware].flat().filter(v => v !== undefined);
    child.excludeMiddleware = [child.excludeMiddleware, parent.excludeMiddleware].flat().filter(v => v !== undefined);
    if (child.handler !== undefined && !isFunctionModule(parent.handler) && !isFunctionModule(child.handler)) {
      child.handler = {
        ...parent.handler,
        ...child.handler
      };
    }
    return {
      ...parent,
      ...child
    };
  }
  /**
   * Convert and validates a route option.
   *
   * @param definition - The route definition to validate.
   * @returns The validated route options.
   * @throws {RouterError} If validation fails.
   */
  toRouteOptions(definition) {
    if (definition.path === undefined) {
      throw new RouterError('Route definition must have a path');
    }
    if (definition.method === undefined || !HTTP_METHODS.includes(definition.method)) {
      throw new RouterError(`Invalid method(${String(definition.method)}), valid methods are(${String(HTTP_METHODS.join(','))})`);
    }
    // One of the following must be defined
    if (definition.handler === undefined && definition.component === undefined && definition.redirect === undefined) {
      throw new RouterError('Route definition must have one of the following: action, component, or redirect');
    }
    return {
      ...definition,
      children: undefined,
      strict: definition.strict ?? this.options.strict,
      rules: {
        ...this.options.rules,
        ...definition.rules
      },
      bindings: {
        ...this.options.bindings,
        ...definition.bindings
      },
      defaults: {
        ...this.options.defaults,
        ...definition.defaults
      },
      name: definition.name?.replace(/\.{2,}/g, '.').replace(/^\.+|\.+$/g, ''),
      path: ['/', this.options.prefix, definition.path].filter(Boolean).join('/').replace(/\/{2,}/g, '/')
    };
  }
}

/**
 * Custom error for Integration layer operations.
 */
class MethodNotAllowedError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'MethodNotAllowedError';
  }
}

/**
 * Manages a collection of `Route` instances.
 *
 * @template IncomingEventType - The type of incoming HTTP events.
 * @template OutgoingResponseType - The type of outgoing HTTP responses.
 */
class RouteCollection {
  /**
   * A map of all routes using a unique key combining method and path.
   */
  routes = new Map();
  /**
   * A map of named routes for quick lookup by name.
   */
  nameList = new Map();
  /**
   * A map of routes grouped by HTTP methods.
   */
  methodList = new Map();
  /**
   * Factory method to create a `RouteCollection` instance.
   *
   * @param routes - Optional array of `Route` instances to initialize the collection.
   * @returns A new `RouteCollection` instance.
   */
  static create(routes) {
    return new this(routes);
  }
  /**
   * Constructs a `RouteCollection` instance.
   *
   * @param routes - Optional array of `Route` instances to initialize the collection.
   */
  constructor(routes) {
    if (Array.isArray(routes)) {
      routes.forEach(route => this.add(route));
    }
  }
  /**
   * Retrieves the total number of routes in the collection.
   */
  get size() {
    return this.getRoutes().length;
  }
  /**
   * Adds a `Route` to the collection.
   *
   * @param route - The `Route` to add.
   * @returns The updated `RouteCollection` instance.
   */
  add(route) {
    this.addToCollections(route);
    this.addToMethodList(route);
    this.addToNameList(route);
    return this;
  }
  /**
   * Matches a `Route` based on a set of options.
   *
   * @param options - The options to match against.
   * @returns The matched `Route`, or `undefined` if no match is found.
  */
  matchOptions(options) {
    const {
      method,
      path
    } = options;
    const methodPath = `${String(method)}.${String(path)}`;
    return this.routes.has(methodPath) ? this.routes.get(methodPath) : this.routes.values().find(route => route.matchesOptions(options));
  }
  /**
   * Matches a `Route` based on an incoming event.
   *
   * @param event - The incoming HTTP event.
   * @param includingMethod - Whether to consider the HTTP method during matching. Defaults to `true`.
   * @returns The matched `Route`.
   * @throws {RouteNotFoundError} If no route matches the event.
   */
  match(event, includingMethod = true) {
    const routes = this.getRoutesByMethod(event.method);
    const route = this.matchAgainstRoutes(routes, event, includingMethod);
    return this.handleMatchedRoute(event, route);
  }
  /**
   * Checks if a named route exists.
   *
   * @param name - The name of the route.
   * @returns `true` if the named route exists, `false` otherwise.
   */
  hasNamedRoute(name) {
    return this.nameList.has(name);
  }
  /**
   * Retrieves a route by name.
   *
   * @param name - The name of the route.
   * @returns The corresponding `Route`, or `undefined` if not found.
   */
  getByName(name) {
    return this.nameList.get(name);
  }
  /**
   * Retrieves all routes for a given HTTP method.
   *
   * @param method - The HTTP method.
   * @returns An array of matching routes.
   */
  getRoutesByMethod(method) {
    return Array.from(this.methodList.get(method.toUpperCase())?.values() ?? []);
  }
  /**
   * Retrieves all registered routes as an array.
   *
   * @returns An array of all routes.
   */
  getRoutes() {
    return Array.from(this.routes.values());
  }
  /**
   * Dumps all routes as an array of JSON objects.
   *
   * @returns An array of route definitions.
   */
  dump() {
    return Array.from(this.methodList.entries()).reduce((prev, [method, routeMap]) => {
      return prev.concat(this.removeInternalHeaders(Array.from(routeMap.values())).map(route => ({
        ...route.toJSON(),
        method
      })));
    }, []).sort((a, b) => a.path?.localeCompare(b.path));
  }
  /**
   * Converts all routes to a JSON string.
   *
   * @returns A JSON string representing all routes.
   */
  toString() {
    return JSON.stringify(this.dump());
  }
  /**
   * Implements the iterable protocol for iterating over routes.
   *
   * @returns An iterator for the routes.
   */
  [Symbol.iterator]() {
    let index = -1;
    const routes = this.getRoutes();
    return {
      next: () => ({
        value: routes[++index],
        done: !(index in routes)
      })
    };
  }
  addToCollections(route) {
    this.routes.set(`${String(route.getOption('method'))}.${String(route.getOption('path'))}`, route);
  }
  addToMethodList(route) {
    const path = route.getOption('path');
    const method = route.getOption('method');
    if (method !== undefined && path !== undefined) {
      !this.methodList.has(method) && this.methodList.set(method, new Map());
      this.methodList.get(method)?.set(path, route);
    }
  }
  addToNameList(route) {
    const name = route.getOption('name');
    name !== undefined && this.nameList.set(name, route);
  }
  matchAgainstRoutes(routes, event, includingMethod) {
    return routes.sort((a, b) => Number(a.getOption('fallback')) - Number(b.getOption('fallback'))).find(route => route.matches(event, includingMethod));
  }
  handleMatchedRoute(event, route) {
    if (route !== undefined) return route;
    const others = this.checkForAlternateVerbs(event);
    if (others.length > 0) return this.getRouteForMethods(event, others);
    throw new RouteNotFoundError(`Route ${String(event.decodedPathname)} could not be found.`);
  }
  checkForAlternateVerbs(event) {
    return HTTP_METHODS.filter(method => method.toUpperCase() !== event.method?.toUpperCase() && this.matchAgainstRoutes(this.removeInternalHeaders(this.getRoutesByMethod(method)), event, false) !== undefined);
  }
  removeInternalHeaders(routes) {
    return routes.filter(route => !route.getOption('isInternalHeader', false));
  }
  getRouteForMethods(event, methods) {
    if (event.isMethod?.('OPTIONS')) {
      return Route.create({
        method: 'OPTIONS',
        path: event.decodedPathname ?? event.pathname,
        handler: _event => ({
          statusText: '',
          statusCode: 200,
          content: {
            Allow: methods.join(',')
          }
        })
      });
    }
    throw new MethodNotAllowedError(`Method ${String(event.method)} is not supported for ${String(event.decodedPathname)}. Supported methods: ${String(methods.join(', '))}.`);
  }
}

/**
 * Class representing a Route Event.
 *
 * @extends Event
 */
class RouteEvent extends Event {
  /**
   * ROUTING Event name, fires before event match route.
   *
   * @event RouteEvent#ROUTING
   */
  static ROUTING = 'stonejs@router.routing';
  /**
   * ROUTE_MATCHED Event name, fires after event matched route.
   *
   * @event RouteEvent#ROUTE_MATCHED
   */
  static ROUTE_MATCHED = 'stonejs@router.route_matched';
  /**
   * Create a RouteEvent.
   *
   * @param options - The options to create a RouteEvent.
   * @returns A new RouteEvent instance.
   */
  static create(options) {
    return new this(options);
  }
}

/**
 * Represents a configurable router for managing HTTP routes and handling incoming events.
 *
 * @template IncomingEventType - Type of incoming events.
 * @template OutgoingResponseType - Type of outgoing responses.
 */
class Router {
  routerOptions;
  routeMapper;
  groupDefinition;
  currentRoute;
  routes;
  /**
   * Factory method for creating a router instance.
   *
   * @param options - Configuration options for the router.
   * @returns A new `Router` instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs a `Router` instance.
   *
   * @param routerOptions - Configuration options for the router.
   */
  constructor(routerOptions) {
    this.routerOptions = routerOptions;
    this.routeMapper = RouteMapper.create(routerOptions);
    this.routes = RouteCollection.create(this.routeMapper.toRoutes(routerOptions.definitions));
  }
  /**
   * Creates a route group.
   *
   * @param path - The base path for the group.
   * @param definition - Optional group-specific route definitions.
   * @returns The router instance for chaining.
   */
  group(path, definition) {
    this.groupDefinition = {
      ...definition,
      path
    };
    return this;
  }
  /**
   * Removes the current group definition, ending the grouping context.
   *
   * @returns The router instance for chaining.
   */
  noGroup() {
    this.groupDefinition = undefined;
    return this;
  }
  /**
   * Registers a route that supports the `OPTIONS` method.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  options(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [OPTIONS]);
  }
  /**
   * Registers a route that supports the `GET` and `HEAD` methods.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  get(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [GET]);
  }
  /**
   * Registers a route that supports the `GET` and `HEAD` methods.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  add(path, handlerOrDefinition) {
    return this.get(path, handlerOrDefinition);
  }
  /**
   * Registers a route that supports the `GET` and `HEAD` methods.
   * Route is considered as a page route.
   *
   * @param path - The route path.
   * @param definition - The route functional definition.
   * @returns The router instance for chaining.
   */
  page(path, definition) {
    return this.get(path, definition);
  }
  /**
   * Registers a route that supports the `POST` method.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  post(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [POST]);
  }
  /**
   * Registers a route that supports the `PUT` method.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  put(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [PUT]);
  }
  /**
   * Registers a route that supports the `PATCH` method.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  patch(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [PATCH]);
  }
  /**
   * Registers a route that supports the `DELETE` method.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  delete(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [DELETE]);
  }
  /**
   * Registers a route that supports all HTTP methods.
   *
   * @param path - The route path.
   * @param handlerOrDefinition - The route handler or functional definition.
   * @returns The router instance for chaining.
   */
  any(path, handlerOrDefinition) {
    return this.match(path, handlerOrDefinition, [GET, POST, PUT, PATCH, DELETE, OPTIONS]);
  }
  /**
   * Registers a fallback route to handle unmatched requests.
   *
   * @param action - The handler to execute for the fallback route.
   * @returns The current `Router` instance.
   */
  fallback(action) {
    return this.get('/:__fallback__(.*)*', {
      action,
      fallback: true
    });
  }
  /**
   * Adds a route to the router for specific HTTP methods.
   *
   * @param path - The path for the route.
   * @param handlerOrDefinition - The handler to execute or a route definition object.
   * @param methods - An array of HTTP methods this route should handle.
   * @returns The current `Router` instance.
   */
  match(path, handlerOrDefinition, methods) {
    const child = typeof handlerOrDefinition === 'object' ? {
      ...handlerOrDefinition,
      path,
      methods
    } : {
      path,
      handler: handlerOrDefinition,
      methods
    };
    const definition = this.groupDefinition === undefined ? child : {
      ...this.groupDefinition,
      children: [child]
    };
    this.routerOptions.definitions = this.routerOptions.definitions.concat(definition);
    this.routeMapper.toRoutes([definition]).forEach(route => this.routes.add(route));
    return this;
  }
  /**
   * Defines multiple route definitions in the router.
   *
   * @param definitions - An array of route definitions to add.
   * @returns The current `Router` instance.
   */
  define(definitions) {
    this.routerOptions.definitions = definitions;
    this.routeMapper.toRoutes(definitions).forEach(route => this.routes.add(route));
    return this;
  }
  /**
   * Sets the routes for the router using a `RouteCollection`.
   *
   * @param routes - The `RouteCollection` instance containing routes to set.
   * @returns The current `Router` instance.
   * @throws {RouterError} If the provided parameter is not an instance of `RouteCollection`.
   */
  setRoutes(routes) {
    if (!(routes instanceof RouteCollection)) {
      throw new RouterError('Parameter must be an instance of RouteCollection');
    }
    this.routes = routes;
    return this;
  }
  /**
   * Configures the router with specific options.
   *
   * @param options - A partial configuration object for the router.
   * @returns The current `Router` instance.
   */
  configure(options) {
    this.routerOptions = {
      ...this.routerOptions,
      ...options
    };
    return this;
  }
  /**
   * Adds global middleware to the router.
   *
   * @param middleware - A single middleware or an array of middleware to add.
   * @returns The current `Router` instance.
   */
  use(middleware) {
    this.routerOptions.middleware ??= [];
    this.routerOptions.middleware = this.routerOptions.middleware.concat(middleware);
    return this;
  }
  /**
   * Attaches middleware to specific routes by their name.
   *
   * @param name - A single route name or an array of route names to attach the middleware to.
   * @param middleware - A single middleware or an array of middleware to attach.
   * @returns The current `Router` instance.
   */
  useOn(name, middleware) {
    Array(name).flat().forEach(name => {
      this.routerOptions.definitions.filter(v => v.name === name).forEach(v => {
        v.middleware = (v.middleware ?? []).concat(middleware);
        this.routes.getByName(name)?.addMiddleware(middleware);
      });
    });
    return this;
  }
  /**
   * Subscribes to an event emitted by the router's event emitter.
   *
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener function to execute when the event is emitted.
   * @returns The current `Router` instance.
   */
  on(eventName, listener) {
    this.routerOptions.eventEmitter?.on(eventName, listener);
    return this;
  }
  /**
   * Dispatches an event through the router to find and execute the corresponding route.
   *
   * @param event - The incoming event to process.
   * @returns A promise resolving to the outgoing response after executing the matched route.
   */
  async dispatch(event) {
    return await this.runRoute(event, await this.findRoute(event));
  }
  /**
   * Dispatches an event to a specific route by its name.
   *
   * @param event - The incoming event to process.
   * @param name - The name of the route to execute.
   * @returns A promise resolving to the outgoing response after executing the specified route.
   * @throws {RouteNotFoundError} If no route is found with the given name.
   */
  async respondWithRouteName(event, name) {
    const route = this.routes.getByName(name);
    if (route === undefined) {
      throw new RouteNotFoundError(`No routes found with this name ${name}`);
    }
    return await this.runRoute(event, route);
  }
  /**
   * Finds and matches a route for the given event.
   *
   * @param event - The incoming event to find a route for.
   * @returns The matched route.
   * @throws {RouteNotFoundError} If no route matches the given event.
   */
  async findRoute(event) {
    await this.routerOptions.eventEmitter?.emit(RouteEvent.create({
      type: RouteEvent.ROUTING,
      source: this,
      metadata: {
        event
      }
    }));
    this.currentRoute = this.routes.match(event);
    return this.currentRoute;
  }
  /**
   * Finds a route based on the provided options.
   *
   * @param options - Options to match against the routes.
   * @returns The matched route, or `undefined` if no match is found.
  */
  findRouteByOptions(options) {
    return this.routes.matchOptions(options);
  }
  /**
   * Generates a URL based on a named route and the provided options.
   *
   * @param options - Options for generating the URL, including the route name, parameters, and query.
   * @returns The generated URL as a string.
   * @throws {RouteNotFoundError} If no route is found with the specified name.
   */
  generate(options) {
    const route = this.routes.getByName(options.name);
    if (route === undefined) {
      throw new RouteNotFoundError(`No routes found with this name ${String(options.name)}`);
    }
    return route.generate(options);
  }
  /**
   * Navigates to a specific route in the browser environment.
   *
   * @param pathOrOptions - The path or navigation options, including route name and parameters.
   * @throws {RouterError} If called outside a browser environment.
   */
  navigate(pathOrOptions) {
    if (window === undefined) {
      throw new RouterError('This method can only be used in a browser environment');
    }
    let path = pathOrOptions;
    const options = pathOrOptions;
    if (typeof options.name === 'string') {
      path = this.generate({
        ...options,
        withDomain: false
      });
    }
    window.history.pushState({
      path,
      options
    }, '', path);
    window.dispatchEvent(new CustomEvent(NAVIGATION_EVENT, {
      detail: {
        path,
        options
      }
    }));
  }
  /**
   * Collects middleware for a specific route, including global and route-specific middleware.
   *
   * @param route - The route for which middleware should be gathered.
   * @returns An array of middleware to execute for the route.
   */
  gatherRouteMiddleware(route) {
    return this.routerOptions.middleware?.concat(route.getOption('middleware', [])).filter(v => this.routerOptions.skipMiddleware !== true && v !== undefined && !route.isMiddlewareExcluded(v)).reduce((acc, middleware) => acc.includes(middleware) ? acc : acc.concat(middleware), []) ?? [];
  }
  /**
   * Checks if the router contains a route with the given name(s).
   *
   * @param name - A route name or an array of route names to check.
   * @returns `true` if at least one of the specified routes exists, `false` otherwise.
   */
  hasRoute(name) {
    return [name].flat().filter(v => this.routes.hasNamedRoute(v)).length > 0;
  }
  /**
   * Retrieves the parameters of the current route.
   *
   * @returns An object containing the parameters of the current route, or `undefined` if no route is active.
   */
  getParameters() {
    return this.currentRoute?.params;
  }
  /**
   * Retrieves a specific parameter from the current route.
   *
   * @template TReturn - The expected return type of the parameter.
   * @param name - The name of the parameter to retrieve.
   * @param fallback - An optional fallback value to return if the parameter is not found.
   * @returns The value of the parameter, or the fallback value if the parameter is not found.
   */
  getParameter(name, fallback) {
    return this.currentRoute?.getParam(name, fallback);
  }
  /**
   * Retrieves the currently active route.
   *
   * @returns The current route, or `undefined` if no route is active.
   */
  getCurrentRoute() {
    return this.currentRoute;
  }
  /**
   * Retrieves the name of the currently active route.
   *
   * @returns The name of the current route, or `undefined` if no route is active.
   */
  getCurrentRouteName() {
    return this.currentRoute?.getOption('name');
  }
  /**
   * Checks if the currently active route matches the specified name.
   *
   * @param name - The name to compare with the current route's name.
   * @returns `true` if the current route's name matches the specified name, `false` otherwise.
   */
  isCurrentRouteNamed(name) {
    return this.getCurrentRouteName() === name;
  }
  /**
   * Retrieves the collection of all routes in the router.
   *
   * @returns A `RouteCollection` containing all registered routes.
   */
  getRoutes() {
    return this.routes;
  }
  /**
   * Dumps all routes as an array of JSON objects.
   *
   * @returns An array of JSON objects representing the routes.
   */
  dumpRoutes() {
    return this.routes.dump();
  }
  async runRoute(event, route) {
    event.setRouteResolver?.(() => route);
    await this.routerOptions.eventEmitter?.emit(RouteEvent.create({
      type: RouteEvent.ROUTE_MATCHED,
      source: this,
      metadata: {
        event,
        route
      }
    }));
    return await this.runRouteWithMiddleware(event, route);
  }
  async runRouteWithMiddleware(event, route) {
    return await Pipeline.create(this.makePipelineOptions()).send(event).through(...this.gatherRouteMiddleware(route)).then(async ev => await this.bindAndRun(route, ev));
  }
  async bindAndRun(route, event) {
    await route.setDispatchers(this.routerOptions.dispatchers).setResolver(this.routerOptions.dependencyResolver).bind(event);
    return await route.run(event);
  }
  makePipelineOptions() {
    return {
      resolver: metaPipe => {
        if (isClassPipe(metaPipe) || isAliasPipe(metaPipe)) {
          return this.routerOptions.dependencyResolver?.resolve(metaPipe.module, true);
        } else if (isFactoryPipe(metaPipe)) {
          return metaPipe.module(this.routerOptions.dependencyResolver);
        }
      }
    };
  }
}

/**
 * Class representing an RouterErrorHandler.
 */
class RouterErrorHandler {
  logger;
  /**
   * Create an RouterErrorHandler.
   *
   * @param options - RouterErrorHandler options.
   */
  constructor({
    logger
  }) {
    if (logger === undefined) {
      throw new RouterError('Logger is required to create an RouterErrorHandler instance.');
    }
    this.logger = logger;
  }
  /**
   * Handle an error.
   *
   * @param error - The error to handle.
   * @param event - The incoming http event.
   * @returns The outgoing http response.
   */
  handle(error, event) {
    const message = error => event.is(['json']) === false ? error : {
      error
    };
    this.logger.error(error.message, {
      error
    });
    const response = {
      RouteNotFoundError: {
        statusCode: 404,
        content: message('Not Found')
      },
      MethodNotAllowedError: {
        statusCode: 405,
        content: message('Method Not Allowed')
      }
    }[error.name] ?? {
      statusCode: 500,
      content: message('Internal Server Error')
    };
    return response;
  }
}

/**
 * A router event handler for processing incoming events.
 *
 * @template IncomingEventType - The type representing the incoming event.
 * @template OutgoingResponseType - The type representing the outgoing response.
 */
class RouterEventHandler {
  router;
  /**
   * Factory method for creating a RouterEventHandler instance.
   *
   * @param options - Configuration options for the RouterEventHandler.
   * @returns A new `RouterEventHandler` instance.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs a `RouterEventHandler` instance.
   *
   * @param options - The RouterEventHandler options including blueprint, container, and event emitter.
   * @throws {RouterError} If the blueprint is invalid.
   */
  constructor(options) {
    this.validateOptions(options);
    this.router = Router.create(this.getRouterOptions(options));
  }
  /**
   * Handle an incoming event.
   *
   * @param event - The incoming event to process.
   * @returns The outgoing response.
   */
  async handle(event) {
    return await this.router.dispatch(event);
  }
  validateOptions(options) {
    if (options.blueprint === undefined) {
      throw new RouterError('The Blueprint is required to create a RouterEventHandler instance');
    }
    if (options.container === undefined) {
      throw new RouterError('The Container is required to create a RouterEventHandler instance');
    }
    if (options.eventEmitter === undefined) {
      throw new RouterError('The EventEmitter is required to create a RouterEventHandler instance');
    }
  }
  getRouterOptions(options) {
    const routerOptions = options.blueprint.get('stone.router', {});
    return {
      ...routerOptions,
      eventEmitter: options.eventEmitter,
      dependencyResolver: options.container
    };
  }
}

/**
 * Dispatches a callable router action.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The dispatcher options, including event, route, and callable action.
 * @returns A promise resolving to the outgoing HTTP response.
 * @throws {RouterError} If no callable function is found.
 *
 * @example
 * ```typescript
 * await callableDispatcher({
 *   event,
 *   route,
 *   callable: async (context) => { return new OutgoingResponse('Success') }
 * });
 * ```
 */
async function callableDispatcher({
  event,
  handler
}) {
  if (isFunctionModule(handler)) {
    return await handler(event);
  }
  throw new RouterError('No callable function found');
}
/**
 * Dispatch event to a handler action.
 *
 * @template IncomingEventType - The type representing the incoming HTTP event.
 * @template OutgoingResponseType - The type representing the outgoing HTTP response.
 *
 * @param options - The dispatcher options, including event, route, handler, and action.
 * @returns A promise resolving to the outgoing HTTP response.
 * @throws {RouterError} If the action is not found in the handler.
 *
 * @example
 * ```typescript
 * await handlerDispatcher({
 *   event,
 *   route,
 *   action: 'handleRequest',
 *   handler: new MyController(),
 * });
 * ```
 */
async function handlerDispatcher({
  event,
  handler,
  action
}) {
  if (isObjectLikeModule(handler) && action !== undefined && action in handler) {
    return await handler[action](event);
  }
  throw new RouterError(`Action ${String(action)} not found in handler`);
}

/**
 * Configuration for the `router` command.
 * Defines command name, alias, arguments, description, and options.
 */
const routerCommandOptions = {
  name: 'router',
  alias: 'r',
  args: ['<action>'],
  desc: 'Router utility commands',
  options: yargs => {
    return yargs.positional('action', {
      type: 'string',
      choices: ['list'],
      desc: 'Display route definitions'
    });
  }
};
/**
 * Handles router-related commands by interacting with the Router instance.
 */
class RouterCommand {
  container;
  /**
   * Initializes a new instance of `RouterCommand`.
   *
   * @param container - The dependency injection container for resolving the Router instance.
   * @throws {RouterError} If the container is not provided.
   */
  constructor(container) {
    this.container = container;
    if (container === undefined) {
      throw new RouterError('Container is required to create a RouterCommand instance.');
    }
  }
  /**
   * Processes an incoming event and executes the specified router action.
   *
   * @param event - The event containing metadata for router actions.
   * @returns A promise resolving to an `OutgoingResponse`.
   */
  handle(event) {
    const action = event.getMetadataValue('action');
    if (action === 'list') {
      console.table(Router.create(this.getRouterOptions()).dumpRoutes());
    }
  }
  getRouterOptions() {
    const routerOptions = this.container.make('blueprint').get('stone.router', {});
    return {
      ...routerOptions,
      dependencyResolver: this.container
    };
  }
}

/**
 * Constants are defined here to prevent Circular dependency between modules
 * This pattern must be applied to all Stone libraries or third party libraries.
 */
/**
 * A unique symbol key to mark classes method member as Match action.
 */
const MATCH_KEY = Symbol.for('Match');
/**
 * A unique symbol key to mark classes method member as Match controller.
 */
const GROUP_KEY = Symbol.for('Group');

/**
 * Middleware to process and register route definitions from modules.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next pipeline function to continue processing.
 * @returns The updated blueprint or a promise resolving to it.
 *
 * @example
 * ```typescript
 * RouteDefinitionsMiddleware(context, next)
 * ```
 */
async function RouteDefinitionsMiddleware(context, next) {
  context.modules.filter(module => hasMetadata(module, GROUP_KEY)).forEach(module => {
    const children = getMetadata(module, MATCH_KEY, []);
    const parent = getMetadata(module, GROUP_KEY, {
      path: '/'
    });
    parent.children = children;
    parent.handler = {
      ...parent.handler,
      module
    };
    context.blueprint.add('stone.router.definitions', parent);
  });
  return await next(context);
}
/**
 * Middleware to set the router as the main event handler for the application.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next function in the pipeline.
 * @returns The updated blueprint.
 *
 * @example
 * ```typescript
 * SetRouterEventHandlerMiddleware({ modules, blueprint }, next);
 * ```
 */
async function SetRouterEventHandlerMiddleware(context, next) {
  context.blueprint.set('stone.handler', {
    module: RouterEventHandler,
    isClass: true
  });
  return await next(context);
}
/**
 * Middleware to set router commands for Node CLI adapters.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next pipeline function to continue processing.
 * @returns The updated blueprint or a promise resolving to it.
 *
 * @example
 * ```typescript
 * SetRouterCommandsMiddleware(context, next)
 * ```
 */
const SetRouterCommandsMiddleware = async (context, next) => {
  context.blueprint.get('stone.adapters', []).filter(adapter => adapter.platform === NODE_CONSOLE_PLATFORM).map(adapter => {
    adapter.commands = [[RouterCommand, routerCommandOptions]].concat(adapter.commands);
    return adapter;
  });
  return await next(context);
};
/**
 * Configuration for route processing middleware.
 *
 * This array defines a list of middleware pipes, each with a `pipe` function and a `priority`.
 * These pipes are executed in the order of their priority values, with lower values running first.
 *
 * @example
 * ```typescript
 * const middlewares = routeConfigMiddleware;
 * middlewares.forEach(({ pipe, priority }) => {
 *   // Execute each middleware in order of priority
 * });
 * ```
 */
const routeConfigMiddleware = [{
  module: RouteDefinitionsMiddleware,
  priority: 3
}, {
  module: SetRouterCommandsMiddleware,
  priority: 5
}, {
  module: SetRouterEventHandlerMiddleware,
  priority: 2
}];

/**
 * Default blueprint configuration for the router.
 */
const routerBlueprint = {
  stone: {
    builder: {
      middleware: routeConfigMiddleware
    },
    kernel: {
      errorHandlers: [{
        isClass: true,
        module: RouterErrorHandler,
        error: ['RouterError', 'RouteNotFoundError', 'MethodNotAllowedError']
      }]
    },
    router: {
      rules: {},
      maxDepth: 5,
      defaults: {},
      bindings: {},
      strict: false,
      matchers: [uriMatcher, hostMatcher, methodMatcher, protocolMatcher],
      middleware: [],
      definitions: [],
      dispatchers: {
        handler: handlerDispatcher,
        callable: callableDispatcher
      },
      skipMiddleware: false
    }
  }
};

var src$2 = {exports: {}};

var browser$2 = {exports: {}};

var debug$1 = {exports: {}};

/**
 * Helpers.
 */
var ms$2;
var hasRequiredMs$2;
function requireMs$2() {
  if (hasRequiredMs$2) return ms$2;
  hasRequiredMs$2 = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms$2 = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  return ms$2;
}

var hasRequiredDebug$1;
function requireDebug$1() {
  if (hasRequiredDebug$1) return debug$1.exports;
  hasRequiredDebug$1 = 1;
  (function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$2();

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
        i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {
      function debug() {
        // disabled?
        if (!debug.enabled) return;
        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }
      return debug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$1, debug$1.exports);
  return debug$1.exports;
}

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function (module, exports) {
    exports = module.exports = requireDebug$1();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors) return;
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}

var node$2 = {exports: {}};

/**
 * Module dependencies.
 */
var hasRequiredNode$2;
function requireNode$2() {
  if (hasRequiredNode$2) return node$2.exports;
  hasRequiredNode$2 = 1;
  (function (module, exports) {
    var tty = require$$0$7;
    var util = require$$1$2;

    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = requireDebug$1();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // camel-case
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
        return k.toUpperCase();
      });

      // coerce string value into JS value
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});

    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */

    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    exports.formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
        return str.trim();
      }).join(' ');
    };

    /**
     * Map %o to `util.inspect()`, allowing multiple lines if needed.
     */

    exports.formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace;
      var useColors = this.useColors;
      if (useColors) {
        var c = this.color;
        var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
      } else {
        args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
      }
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to `stream`.
     */

    function log() {
      return stream.write(util.format.apply(util, arguments) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */

    function createWritableStdioStream(fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');

      // Note stream._type is used for test-module-load-list.js

      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';

          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
        case 'FILE':
          var fs = require$$3$2;
          stream = new fs.SyncWriteStream(fd, {
            autoClose: false
          });
          stream._type = 'fs';
          break;
        case 'PIPE':
        case 'TCP':
          var net = require$$4$2;
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });

          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';

          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }

      // For supporting legacy API we put the FD here.
      stream.fd = fd;
      stream._isStdio = true;
      return stream;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */

    exports.enable(load());
  })(node$2, node$2.exports);
  return node$2.exports;
}

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */
var hasRequiredSrc$2;
function requireSrc$2() {
  if (hasRequiredSrc$2) return src$2.exports;
  hasRequiredSrc$2 = 1;
  if (typeof process !== 'undefined' && process.type === 'renderer') {
    src$2.exports = requireBrowser$2();
  } else {
    src$2.exports = requireNode$2();
  }
  return src$2.exports;
}

var src$1 = {exports: {}};

var browser$1 = {exports: {}};

var debug = {exports: {}};

/**
 * Helpers.
 */
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms$1 = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  return ms$1;
}

var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug.exports;
  hasRequiredDebug = 1;
  (function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$1();

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
        i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {
      function debug() {
        // disabled?
        if (!debug.enabled) return;
        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }
      return debug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug, debug.exports);
  return debug.exports;
}

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function (module, exports) {
    exports = module.exports = requireDebug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors) return;
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}

var node$1 = {exports: {}};

/**
 * Module dependencies.
 */
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function (module, exports) {
    var tty = require$$0$7;
    var util = require$$1$2;

    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = requireDebug();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // camel-case
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
        return k.toUpperCase();
      });

      // coerce string value into JS value
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});

    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */

    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
    }
    var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    exports.formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
        return str.trim();
      }).join(' ');
    };

    /**
     * Map %o to `util.inspect()`, allowing multiple lines if needed.
     */

    exports.formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace;
      var useColors = this.useColors;
      if (useColors) {
        var c = this.color;
        var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
      } else {
        args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
      }
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to `stream`.
     */

    function log() {
      return stream.write(util.format.apply(util, arguments) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */

    function createWritableStdioStream(fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');

      // Note stream._type is used for test-module-load-list.js

      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';

          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
        case 'FILE':
          var fs = require$$3$2;
          stream = new fs.SyncWriteStream(fd, {
            autoClose: false
          });
          stream._type = 'fs';
          break;
        case 'PIPE':
        case 'TCP':
          var net = require$$4$2;
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });

          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';

          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }

      // For supporting legacy API we put the FD here.
      stream.fd = fd;
      stream._isStdio = true;
      return stream;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */

    exports.enable(load());
  })(node$1, node$1.exports);
  return node$1.exports;
}

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1) return src$1.exports;
  hasRequiredSrc$1 = 1;
  if (typeof process !== 'undefined' && process.type === 'renderer') {
    src$1.exports = requireBrowser$1();
  } else {
    src$1.exports = requireNode$1();
  }
  return src$1.exports;
}

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl$1;
var hasRequiredEncodeurl$1;
function requireEncodeurl$1() {
  if (hasRequiredEncodeurl$1) return encodeurl$1;
  hasRequiredEncodeurl$1 = 1;

  /**
   * Module exports.
   * @public
   */

  encodeurl$1 = encodeUrl;

  /**
   * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
   * and including invalid escape sequences.
   * @private
   */

  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

  /**
   * RegExp to match unmatched surrogate pair.
   * @private
   */

  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

  /**
   * String to replace unmatched surrogate pair with.
   * @private
   */

  var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

  /**
   * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
   *
   * This function will take an already-encoded URL and encode all the non-URL
   * code points. This function will not encode the "%" character unless it is
   * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
   * be encoded as `%25foo`).
   *
   * This encode is meant to be "safe" and does not throw errors. It will try as
   * hard as it can to properly encode the given URL, including replacing any raw,
   * unpaired surrogate pairs with the Unicode replacement character prior to
   * encoding.
   *
   * @param {string} url
   * @return {string}
   * @public
   */

  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl$1;
}

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1$1;
var hasRequiredEscapeHtml$1;
function requireEscapeHtml$1() {
  if (hasRequiredEscapeHtml$1) return escapeHtml_1$1;
  hasRequiredEscapeHtml$1 = 1;

  /**
   * Module variables.
   * @private
   */

  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Module exports.
   * @public
   */

  escapeHtml_1$1 = escapeHtml;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#39;';
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  return escapeHtml_1$1;
}

var onFinished$4 = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst$1;
var hasRequiredEeFirst$1;
function requireEeFirst$1() {
  if (hasRequiredEeFirst$1) return eeFirst$1;
  hasRequiredEeFirst$1 = 1;

  /**
   * Module exports.
   * @public
   */

  eeFirst$1 = first;

  /**
   * Get the first event in a set of event emitters and event pairs.
   *
   * @param {array} stuff
   * @param {function} done
   * @public
   */

  function first(stuff, done) {
    if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);

        // listen to the event
        ee.on(event, fn);
        // push this listener to the list of cleanups
        cleanups.push({
          ee: ee,
          event: event,
          fn: fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i = 0; i < cleanups.length; i++) {
        x = cleanups[i];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn) {
      done = fn;
    }
    thunk.cancel = cleanup;
    return thunk;
  }

  /**
   * Create the event listener.
   * @private
   */

  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === 'error' ? arg1 : null;

      // copy args to prevent arguments escaping scope
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee, event, args);
    };
  }
  return eeFirst$1;
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished$2;
function requireOnFinished$2() {
  if (hasRequiredOnFinished$2) return onFinished$4.exports;
  hasRequiredOnFinished$2 = 1;

  /**
   * Module exports.
   * @public
   */

  onFinished$4.exports = onFinished;
  onFinished$4.exports.isFinished = isFinished;

  /**
   * Module dependencies.
   * @private
   */

  var first = requireEeFirst$1();

  /**
   * Variables.
   * @private
   */

  /* istanbul ignore next */
  var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };

  /**
   * Invoke callback when the response has finished, useful for
   * cleaning up resources afterwards.
   *
   * @param {object} msg
   * @param {function} listener
   * @return {object}
   * @public
   */

  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }

    // attach the listener to the message
    attachListener(msg, listener);
    return msg;
  }

  /**
   * Determine if message is already finished.
   *
   * @param {object} msg
   * @return {boolean}
   * @public
   */

  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === 'boolean') {
      // OutgoingMessage
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === 'boolean') {
      // IncomingMessage
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }

    // don't know
    return undefined;
  }

  /**
   * Attach a finished listener to the message.
   *
   * @param {object} msg
   * @param {function} callback
   * @private
   */

  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }

    // finished on first message event
    eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);
    function onSocket(socket) {
      // remove listener
      msg.removeListener('socket', onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;

      // finished on first socket event
      eeSocket = first([[socket, 'error', 'close']], onFinish);
    }
    if (msg.socket) {
      // socket already assigned
      onSocket(msg.socket);
      return;
    }

    // wait for socket to be assigned
    msg.on('socket', onSocket);
    if (msg.socket === undefined) {
      // node.js 0.8 patch
      patchAssignSocket(msg, onSocket);
    }
  }

  /**
   * Attach the listener to the message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function attachListener(msg, listener) {
    var attached = msg.__onFinished;

    // create a private single listener with queue
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }

  /**
   * Create listener on message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }

  /**
   * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
   *
   * @param {ServerResponse} res
   * @param {function} callback
   * @private
   */

  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== 'function') return;

    // res.on('socket', callback) is broken in 0.8
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  return onFinished$4.exports;
}

var parseurl = {exports: {}};

/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl) return parseurl.exports;
  hasRequiredParseurl = 1;

  /**
   * Module dependencies.
   * @private
   */

  var url = require$$0$8;
  var parse = url.parse;
  var Url = url.Url;

  /**
   * Module exports.
   * @public
   */

  parseurl.exports = parseurl$1;
  parseurl.exports.original = originalurl;

  /**
   * Parse the `req` url with memoization.
   *
   * @param {ServerRequest} req
   * @return {Object}
   * @public
   */

  function parseurl$1(req) {
    var url = req.url;
    if (url === undefined) {
      // URL is undefined
      return undefined;
    }
    var parsed = req._parsedUrl;
    if (fresh(url, parsed)) {
      // Return cached URL parse
      return parsed;
    }

    // Parse the URL
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedUrl = parsed;
  }

  /**
   * Parse the `req` original url with fallback and memoization.
   *
   * @param {ServerRequest} req
   * @return {Object}
   * @public
   */

  function originalurl(req) {
    var url = req.originalUrl;
    if (typeof url !== 'string') {
      // Fallback
      return parseurl$1(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url, parsed)) {
      // Return cached URL parse
      return parsed;
    }

    // Parse the URL
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedOriginalUrl = parsed;
  }

  /**
   * Parse the `str` url with fast-path short-cut.
   *
   * @param {string} str
   * @return {Object}
   * @private
   */

  function fastparse(str) {
    if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
      return parse(str);
    }
    var pathname = str;
    var query = null;
    var search = null;

    // This takes the regexp from https://github.com/joyent/node/pull/7878
    // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
    // And unrolls it into a for loop
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 0x3f:
          /* ?  */
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 0x09: /* \t */
        case 0x0a: /* \n */
        case 0x0c: /* \f */
        case 0x0d: /* \r */
        case 0x20: /*    */
        case 0x23: /* #  */
        case 0xa0:
        case 0xfeff:
          return parse(str);
      }
    }
    var url = Url !== undefined ? new Url() : {};
    url.path = str;
    url.href = str;
    url.pathname = pathname;
    if (search !== null) {
      url.query = query;
      url.search = search;
    }
    return url;
  }

  /**
   * Determine if parsed is still fresh for url.
   *
   * @param {string} url
   * @param {object} parsedUrl
   * @return {boolean}
   * @private
   */

  function fresh(url, parsedUrl) {
    return typeof parsedUrl === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url;
  }
  return parseurl.exports;
}

var require$$0$6 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$4;
var hasRequiredStatuses$2;
function requireStatuses$2() {
  if (hasRequiredStatuses$2) return statuses$4;
  hasRequiredStatuses$2 = 1;

  /**
   * Module dependencies.
   * @private
   */

  var codes = require$$0$6;

  /**
   * Module exports.
   * @public
   */

  statuses$4 = status;

  // status code to message map
  status.STATUS_CODES = codes;

  // array of status codes
  status.codes = populateStatusesMap(status, codes);

  // status codes for redirects
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };

  // status codes for empty bodies
  status.empty = {
    204: true,
    205: true,
    304: true
  };

  // status codes for when you should retry the request
  status.retry = {
    502: true,
    503: true,
    504: true
  };

  /**
   * Populate the statuses map for given codes.
   * @private
   */

  function populateStatusesMap(statuses, codes) {
    var arr = [];
    Object.keys(codes).forEach(function forEachCode(code) {
      var message = codes[code];
      var status = Number(code);

      // Populate properties
      statuses[status] = message;
      statuses[message] = status;
      statuses[message.toLowerCase()] = status;

      // Add to array
      arr.push(status);
    });
    return arr;
  }

  /**
   * Get the status code.
   *
   * Given a number, this will throw if it is not a known status
   * code, otherwise the code will be returned. Given a string,
   * the string will be parsed for a number and return the code
   * if valid, otherwise will lookup the code assuming this is
   * the status message.
   *
   * @param {string|number} code
   * @returns {number}
   * @public
   */

  function status(code) {
    if (typeof code === 'number') {
      if (!status[code]) throw new Error('invalid status code: ' + code);
      return code;
    }
    if (typeof code !== 'string') {
      throw new TypeError('code must be a number or string');
    }

    // '403'
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      if (!status[n]) throw new Error('invalid status code: ' + n);
      return n;
    }
    n = status[code.toLowerCase()];
    if (!n) throw new Error('invalid status message: "' + code + '"');
    return n;
  }
  return statuses$4;
}

/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
  if (hasRequiredUnpipe) return unpipe_1;
  hasRequiredUnpipe = 1;

  /**
   * Module exports.
   * @public
   */

  unpipe_1 = unpipe;

  /**
   * Determine if there are Node.js pipe-like data listeners.
   * @private
   */

  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners('data');
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === 'ondata') {
        return true;
      }
    }
    return false;
  }

  /**
   * Unpipe a stream from all destinations.
   *
   * @param {object} stream
   * @public
   */

  function unpipe(stream) {
    if (!stream) {
      throw new TypeError('argument stream is required');
    }
    if (typeof stream.unpipe === 'function') {
      // new-style
      stream.unpipe();
      return;
    }

    // Node.js 0.8 hack
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners('close');
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
        continue;
      }

      // invoke the listener
      listener.call(stream);
    }
  }
  return unpipe_1;
}

/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
  if (hasRequiredFinalhandler) return finalhandler_1;
  hasRequiredFinalhandler = 1;

  /**
   * Module dependencies.
   * @private
   */

  var debug = requireSrc$1()('finalhandler');
  var encodeUrl = requireEncodeurl$1();
  var escapeHtml = requireEscapeHtml$1();
  var onFinished = requireOnFinished$2();
  var parseUrl = requireParseurl();
  var statuses = requireStatuses$2();
  var unpipe = requireUnpipe();

  /**
   * Module variables.
   * @private
   */

  var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
  var NEWLINE_REGEXP = /\n/g;

  /* istanbul ignore next */
  var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  var isFinished = onFinished.isFinished;

  /**
   * Create a minimal HTML document.
   *
   * @param {string} message
   * @private
   */

  function createHtmlDocument(message) {
    var body = escapeHtml(message).replace(NEWLINE_REGEXP, '<br>').replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');
    return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>Error</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
  }

  /**
   * Module exports.
   * @public
   */

  finalhandler_1 = finalhandler;

  /**
   * Create a function to handle the final response.
   *
   * @param {Request} req
   * @param {Response} res
   * @param {Object} [options]
   * @return {Function}
   * @public
   */

  function finalhandler(req, res, options) {
    var opts = options || {};

    // get environment
    var env = opts.env || process.env.NODE_ENV || 'development';

    // get error callback
    var onerror = opts.onerror;
    return function (err) {
      var headers;
      var msg;
      var status;

      // ignore 404 on in-flight response
      if (!err && headersSent(res)) {
        debug('cannot 404 after headers sent');
        return;
      }

      // unhandled error
      if (err) {
        // respect status code from error
        status = getErrorStatusCode(err);
        if (status === undefined) {
          // fallback to status code on response
          status = getResponseStatusCode(res);
        } else {
          // respect headers from error
          headers = getErrorHeaders(err);
        }

        // get error message
        msg = getErrorMessage(err, status, env);
      } else {
        // not found
        status = 404;
        msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
      }
      debug('default %s', status);

      // schedule onerror callback
      if (err && onerror) {
        defer(onerror, err, req, res);
      }

      // cannot actually respond
      if (headersSent(res)) {
        debug('cannot %d after headers sent', status);
        req.socket.destroy();
        return;
      }

      // send response
      send(req, res, status, headers, msg);
    };
  }

  /**
   * Get headers from Error object.
   *
   * @param {Error} err
   * @return {object}
   * @private
   */

  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== 'object') {
      return undefined;
    }
    var headers = Object.create(null);
    var keys = Object.keys(err.headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      headers[key] = err.headers[key];
    }
    return headers;
  }

  /**
   * Get message from Error object, fallback to status message.
   *
   * @param {Error} err
   * @param {number} status
   * @param {string} env
   * @return {string}
   * @private
   */

  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== 'production') {
      // use err.stack, which typically includes err.message
      msg = err.stack;

      // fallback to err.toString() when possible
      if (!msg && typeof err.toString === 'function') {
        msg = err.toString();
      }
    }
    return msg || statuses[status];
  }

  /**
   * Get status code from Error object.
   *
   * @param {Error} err
   * @return {number}
   * @private
   */

  function getErrorStatusCode(err) {
    // check err.status
    if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
      return err.status;
    }

    // check err.statusCode
    if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return undefined;
  }

  /**
   * Get resource name for the request.
   *
   * This is typically just the original pathname of the request
   * but will fallback to "resource" is that cannot be determined.
   *
   * @param {IncomingMessage} req
   * @return {string}
   * @private
   */

  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return 'resource';
    }
  }

  /**
   * Get status code from response.
   *
   * @param {OutgoingMessage} res
   * @return {number}
   * @private
   */

  function getResponseStatusCode(res) {
    var status = res.statusCode;

    // default status code to 500 if outside valid range
    if (typeof status !== 'number' || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }

  /**
   * Determine if the response headers have been sent.
   *
   * @param {object} res
   * @returns {boolean}
   * @private
   */

  function headersSent(res) {
    return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;
  }

  /**
   * Send response.
   *
   * @param {IncomingMessage} req
   * @param {OutgoingMessage} res
   * @param {number} status
   * @param {object} headers
   * @param {string} message
   * @private
   */

  function send(req, res, status, headers, message) {
    function write() {
      // response body
      var body = createHtmlDocument(message);

      // response status
      res.statusCode = status;
      res.statusMessage = statuses[status];

      // response headers
      setHeaders(res, headers);

      // security headers
      res.setHeader('Content-Security-Policy', "default-src 'none'");
      res.setHeader('X-Content-Type-Options', 'nosniff');

      // standard headers
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));
      if (req.method === 'HEAD') {
        res.end();
        return;
      }
      res.end(body, 'utf8');
    }
    if (isFinished(req)) {
      write();
      return;
    }

    // unpipe everything from the request
    unpipe(req);

    // flush the request
    onFinished(req, write);
    req.resume();
  }

  /**
   * Set response headers from an object.
   *
   * @param {OutgoingMessage} res
   * @param {object} headers
   * @private
   */

  function setHeaders(res, headers) {
    if (!headers) {
      return;
    }
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
  return finalhandler_1;
}

var utilsMerge = {exports: {}};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */
var hasRequiredUtilsMerge;
function requireUtilsMerge() {
  if (hasRequiredUtilsMerge) return utilsMerge.exports;
  hasRequiredUtilsMerge = 1;
  (function (module, exports) {
    module.exports = function (a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
  })(utilsMerge);
  return utilsMerge.exports;
}

/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var connect$1;
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect) return connect$1;
  hasRequiredConnect = 1;

  /**
   * Module dependencies.
   * @private
   */

  var debug = requireSrc$2()('connect:dispatcher');
  var EventEmitter = require$$1$3.EventEmitter;
  var finalhandler = requireFinalhandler();
  var http = require$$3$3;
  var merge = requireUtilsMerge();
  var parseUrl = requireParseurl();

  /**
   * Module exports.
   * @public
   */

  connect$1 = createServer;

  /**
   * Module variables.
   * @private
   */

  var env = process.env.NODE_ENV || 'development';
  var proto = {};

  /* istanbul ignore next */
  var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };

  /**
   * Create a new connect server.
   *
   * @return {function}
   * @public
   */

  function createServer() {
    function app(req, res, next) {
      app.handle(req, res, next);
    }
    merge(app, proto);
    merge(app, EventEmitter.prototype);
    app.route = '/';
    app.stack = [];
    return app;
  }

  /**
   * Utilize the given middleware `handle` to the given `route`,
   * defaulting to _/_. This "route" is the mount-point for the
   * middleware, when given a value other than _/_ the middleware
   * is only effective when that segment is present in the request's
   * pathname.
   *
   * For example if we were to mount a function at _/admin_, it would
   * be invoked on _/admin_, and _/admin/settings_, however it would
   * not be invoked for _/_, or _/posts_.
   *
   * @param {String|Function|Server} route, callback or server
   * @param {Function|Server} callback or server
   * @return {Server} for chaining
   * @public
   */

  proto.use = function use(route, fn) {
    var handle = fn;
    var path = route;

    // default route to '/'
    if (typeof route !== 'string') {
      handle = route;
      path = '/';
    }

    // wrap sub-apps
    if (typeof handle.handle === 'function') {
      var server = handle;
      server.route = path;
      handle = function (req, res, next) {
        server.handle(req, res, next);
      };
    }

    // wrap vanilla http.Servers
    if (handle instanceof http.Server) {
      handle = handle.listeners('request')[0];
    }

    // strip trailing slash
    if (path[path.length - 1] === '/') {
      path = path.slice(0, -1);
    }

    // add the middleware
    debug('use %s %s', path || '/', handle.name || 'anonymous');
    this.stack.push({
      route: path,
      handle: handle
    });
    return this;
  };

  /**
   * Handle server requests, punting them down
   * the middleware stack.
   *
   * @private
   */

  proto.handle = function handle(req, res, out) {
    var index = 0;
    var protohost = getProtohost(req.url) || '';
    var removed = '';
    var slashAdded = false;
    var stack = this.stack;

    // final function handler
    var done = out || finalhandler(req, res, {
      env: env,
      onerror: logerror
    });

    // store the original URL
    req.originalUrl = req.originalUrl || req.url;
    function next(err) {
      if (slashAdded) {
        req.url = req.url.substr(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.url = protohost + removed + req.url.substr(protohost.length);
        removed = '';
      }

      // next callback
      var layer = stack[index++];

      // all done
      if (!layer) {
        defer(done, err);
        return;
      }

      // route data
      var path = parseUrl(req).pathname || '/';
      var route = layer.route;

      // skip this layer if the route doesn't match
      if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
        return next(err);
      }

      // skip if route match does not border "/", ".", or end
      var c = path.length > route.length && path[route.length];
      if (c && c !== '/' && c !== '.') {
        return next(err);
      }

      // trim off the part of the url that matches the route
      if (route.length !== 0 && route !== '/') {
        removed = route;
        req.url = protohost + req.url.substr(protohost.length + removed.length);

        // ensure leading slash
        if (!protohost && req.url[0] !== '/') {
          req.url = '/' + req.url;
          slashAdded = true;
        }
      }

      // call the layer handle
      call(layer.handle, route, err, req, res, next);
    }
    next();
  };

  /**
   * Listen for connections.
   *
   * This method takes the same arguments
   * as node's `http.Server#listen()`.
   *
   * HTTP and HTTPS:
   *
   * If you run your application both as HTTP
   * and HTTPS you may wrap them individually,
   * since your Connect "server" is really just
   * a JavaScript `Function`.
   *
   *      var connect = require('connect')
   *        , http = require('http')
   *        , https = require('https');
   *
   *      var app = connect();
   *
   *      http.createServer(app).listen(80);
   *      https.createServer(options, app).listen(443);
   *
   * @return {http.Server}
   * @api public
   */

  proto.listen = function listen() {
    var server = http.createServer(this);
    return server.listen.apply(server, arguments);
  };

  /**
   * Invoke a route handle.
   * @private
   */

  function call(handle, route, err, req, res, next) {
    var arity = handle.length;
    var error = err;
    var hasError = Boolean(err);
    debug('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);
    try {
      if (hasError && arity === 4) {
        // error-handling middleware
        handle(err, req, res, next);
        return;
      } else if (!hasError && arity < 4) {
        // request-handling middleware
        handle(req, res, next);
        return;
      }
    } catch (e) {
      // replace the error
      error = e;
    }

    // continue
    next(error);
  }

  /**
   * Log error using console.error.
   *
   * @param {Error} err
   * @private
   */

  function logerror(err) {
    if (env !== 'test') console.error(err.stack || err.toString());
  }

  /**
   * Get get protocol + host for a URL.
   *
   * @param {string} url
   * @private
   */

  function getProtohost(url) {
    if (url.length === 0 || url[0] === '/') {
      return undefined;
    }
    var fqdnIndex = url.indexOf('://');
    return fqdnIndex !== -1 && url.lastIndexOf('?', fqdnIndex) === -1 ? url.substr(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;
  }
  return connect$1;
}

var connectExports = requireConnect();
var connect = /*@__PURE__*/getDefaultExportFromCjs(connectExports);

var onFinished$3 = {exports: {}};

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished$1;
function requireOnFinished$1() {
  if (hasRequiredOnFinished$1) return onFinished$3.exports;
  hasRequiredOnFinished$1 = 1;

  /**
   * Module exports.
   * @public
   */

  onFinished$3.exports = onFinished;
  onFinished$3.exports.isFinished = isFinished;

  /**
   * Module dependencies.
   * @private
   */

  var asyncHooks = tryRequireAsyncHooks();
  var first = requireEeFirst$1();

  /**
   * Variables.
   * @private
   */

  /* istanbul ignore next */
  var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };

  /**
   * Invoke callback when the response has finished, useful for
   * cleaning up resources afterwards.
   *
   * @param {object} msg
   * @param {function} listener
   * @return {object}
   * @public
   */

  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }

    // attach the listener to the message
    attachListener(msg, wrap(listener));
    return msg;
  }

  /**
   * Determine if message is already finished.
   *
   * @param {object} msg
   * @return {boolean}
   * @public
   */

  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === 'boolean') {
      // OutgoingMessage
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === 'boolean') {
      // IncomingMessage
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }

    // don't know
    return undefined;
  }

  /**
   * Attach a finished listener to the message.
   *
   * @param {object} msg
   * @param {function} callback
   * @private
   */

  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }

    // finished on first message event
    eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);
    function onSocket(socket) {
      // remove listener
      msg.removeListener('socket', onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;

      // finished on first socket event
      eeSocket = first([[socket, 'error', 'close']], onFinish);
    }
    if (msg.socket) {
      // socket already assigned
      onSocket(msg.socket);
      return;
    }

    // wait for socket to be assigned
    msg.on('socket', onSocket);
    if (msg.socket === undefined) {
      // istanbul ignore next: node.js 0.8 patch
      patchAssignSocket(msg, onSocket);
    }
  }

  /**
   * Attach the listener to the message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function attachListener(msg, listener) {
    var attached = msg.__onFinished;

    // create a private single listener with queue
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }

  /**
   * Create listener on message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }

  /**
   * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
   *
   * @param {ServerResponse} res
   * @param {function} callback
   * @private
   */

  // istanbul ignore next: node.js 0.8 patch
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== 'function') return;

    // res.on('socket', callback) is broken in 0.8
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }

  /**
   * Try to require async_hooks
   * @private
   */

  function tryRequireAsyncHooks() {
    try {
      return require('async_hooks');
    } catch (e) {
      return {};
    }
  }

  /**
   * Wrap function with async resource, if possible.
   * AsyncResource.bind static method backported.
   * @private
   */

  function wrap(fn) {
    var res;

    // create anonymous resource
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }

    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
      return fn;
    }

    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished$3.exports;
}

var onFinishedExports$1 = requireOnFinished$1();
var onFinished$2 = /*@__PURE__*/getDefaultExportFromCjs(onFinishedExports$1);

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function (module, exports) {
    /* eslint-disable node/no-deprecated-api */
    var buffer = require$$0$9;
    var Buffer = buffer.Buffer;

    // alternative to using Object.keys for old browsers
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer.prototype);

    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }
      return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      var buf = Buffer(size);
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}

var safeBufferExports = requireSafeBuffer();

var contentDisposition$1 = {exports: {}};

/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition) return contentDisposition$1.exports;
  hasRequiredContentDisposition = 1;

  /**
   * Module exports.
   * @public
   */

  contentDisposition$1.exports = contentDisposition;
  contentDisposition$1.exports.parse = parse;

  /**
   * Module dependencies.
   * @private
   */

  var basename = require$$0$a.basename;
  var Buffer = requireSafeBuffer().Buffer;

  /**
   * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
   * @private
   */

  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

  /**
   * RegExp to match percent encoding escape.
   * @private
   */

  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;

  /**
   * RegExp to match non-latin1 characters.
   * @private
   */

  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

  /**
   * RegExp to match quoted-pair in RFC 2616
   *
   * quoted-pair = "\" CHAR
   * CHAR        = <any US-ASCII character (octets 0 - 127)>
   * @private
   */

  var QESC_REGEXP = /\\([\u0000-\u007f])/g; // eslint-disable-line no-control-regex

  /**
   * RegExp to match chars that must be quoted-pair in RFC 2616
   * @private
   */

  var QUOTE_REGEXP = /([\\"])/g;

  /**
   * RegExp for various RFC 2616 grammar
   *
   * parameter     = token "=" ( token | quoted-string )
   * token         = 1*<any CHAR except CTLs or separators>
   * separators    = "(" | ")" | "<" | ">" | "@"
   *               | "," | ";" | ":" | "\" | <">
   *               | "/" | "[" | "]" | "?" | "="
   *               | "{" | "}" | SP | HT
   * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
   * qdtext        = <any TEXT except <">>
   * quoted-pair   = "\" CHAR
   * CHAR          = <any US-ASCII character (octets 0 - 127)>
   * TEXT          = <any OCTET except CTLs, but including LWS>
   * LWS           = [CRLF] 1*( SP | HT )
   * CRLF          = CR LF
   * CR            = <US-ASCII CR, carriage return (13)>
   * LF            = <US-ASCII LF, linefeed (10)>
   * SP            = <US-ASCII SP, space (32)>
   * HT            = <US-ASCII HT, horizontal-tab (9)>
   * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
   * OCTET         = <any 8-bit sequence of data>
   * @private
   */

  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

  /**
   * RegExp for various RFC 5987 grammar
   *
   * ext-value     = charset  "'" [ language ] "'" value-chars
   * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
   * mime-charset  = 1*mime-charsetc
   * mime-charsetc = ALPHA / DIGIT
   *               / "!" / "#" / "$" / "%" / "&"
   *               / "+" / "-" / "^" / "_" / "`"
   *               / "{" / "}" / "~"
   * language      = ( 2*3ALPHA [ extlang ] )
   *               / 4ALPHA
   *               / 5*8ALPHA
   * extlang       = *3( "-" 3ALPHA )
   * value-chars   = *( pct-encoded / attr-char )
   * pct-encoded   = "%" HEXDIG HEXDIG
   * attr-char     = ALPHA / DIGIT
   *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
   *               / "^" / "_" / "`" / "|" / "~"
   * @private
   */

  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

  /**
   * RegExp for various RFC 6266 grammar
   *
   * disposition-type = "inline" | "attachment" | disp-ext-type
   * disp-ext-type    = token
   * disposition-parm = filename-parm | disp-ext-parm
   * filename-parm    = "filename" "=" value
   *                  | "filename*" "=" ext-value
   * disp-ext-parm    = token "=" value
   *                  | ext-token "=" ext-value
   * ext-token        = <the characters in token, followed by "*">
   * @private
   */

  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

  /**
   * Create an attachment Content-Disposition header.
   *
   * @param {string} [filename]
   * @param {object} [options]
   * @param {string} [options.type=attachment]
   * @param {string|boolean} [options.fallback=true]
   * @return {string}
   * @public
   */

  function contentDisposition(filename, options) {
    var opts = options || {};

    // get type
    var type = opts.type || 'attachment';

    // get parameters
    var params = createparams(filename, opts.fallback);

    // format into string
    return format(new ContentDisposition(type, params));
  }

  /**
   * Create parameters object from filename and fallback.
   *
   * @param {string} [filename]
   * @param {string|boolean} [fallback=true]
   * @return {object}
   * @private
   */

  function createparams(filename, fallback) {
    if (filename === undefined) {
      return;
    }
    var params = {};
    if (typeof filename !== 'string') {
      throw new TypeError('filename must be a string');
    }

    // fallback defaults to true
    if (fallback === undefined) {
      fallback = true;
    }
    if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
      throw new TypeError('fallback must be a string or boolean');
    }
    if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError('fallback must be ISO-8859-1 string');
    }

    // restrict to file base name
    var name = basename(filename);

    // determine if name is suitable for quoted string
    var isQuotedString = TEXT_REGEXP.test(name);

    // generate fallback name
    var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

    // set extended filename parameter
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params['filename*'] = name;
    }

    // set filename parameter
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }

  /**
   * Format object to Content-Disposition header.
   *
   * @param {object} obj
   * @param {string} obj.type
   * @param {object} [obj.parameters]
   * @return {string}
   * @private
   */

  function format(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
      throw new TypeError('invalid type');
    }

    // start with normalized type
    var string = String(type).toLowerCase();

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);
        string += '; ' + param + '=' + val;
      }
    }
    return string;
  }

  /**
   * Decode a RFC 5987 field value (gracefully).
   *
   * @param {string} str
   * @return {string}
   * @private
   */

  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError('invalid extended field value');
    }
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;

    // to binary string
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset) {
      case 'iso-8859-1':
        value = getlatin1(binary);
        break;
      case 'utf-8':
        value = Buffer.from(binary, 'binary').toString('utf8');
        break;
      default:
        throw new TypeError('unsupported charset in extended field');
    }
    return value;
  }

  /**
   * Get ISO-8859-1 version of string.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function getlatin1(val) {
    // simple Unicode -> ISO-8859-1 transformation
    return String(val).replace(NON_LATIN1_REGEXP, '?');
  }

  /**
   * Parse Content-Disposition header string.
   *
   * @param {string} string
   * @return {object}
   * @public
   */

  function parse(string) {
    if (!string || typeof string !== 'string') {
      throw new TypeError('argument string is required');
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError('invalid type format');
    }

    // normalize type
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;

    // calculate index to start at
    index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;

    // match parameters
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError('invalid duplicate parameter');
      }
      names.push(key);
      if (key.indexOf('*') + 1 === key.length) {
        // decode extended value
        key = key.slice(0, -1);
        value = decodefield(value);

        // overwrite existing value
        params[key] = value;
        continue;
      }
      if (typeof params[key] === 'string') {
        continue;
      }
      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }
    return new ContentDisposition(type, params);
  }

  /**
   * Percent decode a single character.
   *
   * @param {string} str
   * @param {string} hex
   * @return {string}
   * @private
   */

  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }

  /**
   * Percent encode a single character.
   *
   * @param {string} char
   * @return {string}
   * @private
   */

  function pencode(char) {
    return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
  }

  /**
   * Quote a string for HTTP.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
  }

  /**
   * Encode a Unicode string for HTTP (RFC 5987).
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function ustring(val) {
    var str = String(val);

    // percent encode as UTF-8
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return 'UTF-8\'\'' + encoded;
  }

  /**
   * Class for parsed Content-Disposition header for v8 optimization
   *
   * @public
   * @param {string} type
   * @param {object} parameters
   * @constructor
   */

  function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
  }
  return contentDisposition$1.exports;
}

var contentDispositionExports = requireContentDisposition();
var contentDisposition = /*@__PURE__*/getDefaultExportFromCjs(contentDispositionExports);

const types$2 = {
  'application/andrew-inset': ['ez'],
  'application/appinstaller': ['appinstaller'],
  'application/applixware': ['aw'],
  'application/appx': ['appx'],
  'application/appxbundle': ['appxbundle'],
  'application/atom+xml': ['atom'],
  'application/atomcat+xml': ['atomcat'],
  'application/atomdeleted+xml': ['atomdeleted'],
  'application/atomsvc+xml': ['atomsvc'],
  'application/atsc-dwd+xml': ['dwd'],
  'application/atsc-held+xml': ['held'],
  'application/atsc-rsat+xml': ['rsat'],
  'application/automationml-aml+xml': ['aml'],
  'application/automationml-amlx+zip': ['amlx'],
  'application/bdoc': ['bdoc'],
  'application/calendar+xml': ['xcs'],
  'application/ccxml+xml': ['ccxml'],
  'application/cdfx+xml': ['cdfx'],
  'application/cdmi-capability': ['cdmia'],
  'application/cdmi-container': ['cdmic'],
  'application/cdmi-domain': ['cdmid'],
  'application/cdmi-object': ['cdmio'],
  'application/cdmi-queue': ['cdmiq'],
  'application/cpl+xml': ['cpl'],
  'application/cu-seeme': ['cu'],
  'application/cwl': ['cwl'],
  'application/dash+xml': ['mpd'],
  'application/dash-patch+xml': ['mpp'],
  'application/davmount+xml': ['davmount'],
  'application/docbook+xml': ['dbk'],
  'application/dssc+der': ['dssc'],
  'application/dssc+xml': ['xdssc'],
  'application/ecmascript': ['ecma'],
  'application/emma+xml': ['emma'],
  'application/emotionml+xml': ['emotionml'],
  'application/epub+zip': ['epub'],
  'application/exi': ['exi'],
  'application/express': ['exp'],
  'application/fdf': ['fdf'],
  'application/fdt+xml': ['fdt'],
  'application/font-tdpfr': ['pfr'],
  'application/geo+json': ['geojson'],
  'application/gml+xml': ['gml'],
  'application/gpx+xml': ['gpx'],
  'application/gxf': ['gxf'],
  'application/gzip': ['gz'],
  'application/hjson': ['hjson'],
  'application/hyperstudio': ['stk'],
  'application/inkml+xml': ['ink', 'inkml'],
  'application/ipfix': ['ipfix'],
  'application/its+xml': ['its'],
  'application/java-archive': ['jar', 'war', 'ear'],
  'application/java-serialized-object': ['ser'],
  'application/java-vm': ['class'],
  'application/javascript': ['*js'],
  'application/json': ['json', 'map'],
  'application/json5': ['json5'],
  'application/jsonml+json': ['jsonml'],
  'application/ld+json': ['jsonld'],
  'application/lgr+xml': ['lgr'],
  'application/lost+xml': ['lostxml'],
  'application/mac-binhex40': ['hqx'],
  'application/mac-compactpro': ['cpt'],
  'application/mads+xml': ['mads'],
  'application/manifest+json': ['webmanifest'],
  'application/marc': ['mrc'],
  'application/marcxml+xml': ['mrcx'],
  'application/mathematica': ['ma', 'nb', 'mb'],
  'application/mathml+xml': ['mathml'],
  'application/mbox': ['mbox'],
  'application/media-policy-dataset+xml': ['mpf'],
  'application/mediaservercontrol+xml': ['mscml'],
  'application/metalink+xml': ['metalink'],
  'application/metalink4+xml': ['meta4'],
  'application/mets+xml': ['mets'],
  'application/mmt-aei+xml': ['maei'],
  'application/mmt-usd+xml': ['musd'],
  'application/mods+xml': ['mods'],
  'application/mp21': ['m21', 'mp21'],
  'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],
  'application/msix': ['msix'],
  'application/msixbundle': ['msixbundle'],
  'application/msword': ['doc', 'dot'],
  'application/mxf': ['mxf'],
  'application/n-quads': ['nq'],
  'application/n-triples': ['nt'],
  'application/node': ['cjs'],
  'application/octet-stream': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy', 'exe', 'dll', 'deb', 'dmg', 'iso', 'img', 'msi', 'msp', 'msm', 'buffer'],
  'application/oda': ['oda'],
  'application/oebps-package+xml': ['opf'],
  'application/ogg': ['ogx'],
  'application/omdoc+xml': ['omdoc'],
  'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
  'application/oxps': ['oxps'],
  'application/p2p-overlay+xml': ['relo'],
  'application/patch-ops-error+xml': ['xer'],
  'application/pdf': ['pdf'],
  'application/pgp-encrypted': ['pgp'],
  'application/pgp-keys': ['asc'],
  'application/pgp-signature': ['sig', '*asc'],
  'application/pics-rules': ['prf'],
  'application/pkcs10': ['p10'],
  'application/pkcs7-mime': ['p7m', 'p7c'],
  'application/pkcs7-signature': ['p7s'],
  'application/pkcs8': ['p8'],
  'application/pkix-attr-cert': ['ac'],
  'application/pkix-cert': ['cer'],
  'application/pkix-crl': ['crl'],
  'application/pkix-pkipath': ['pkipath'],
  'application/pkixcmp': ['pki'],
  'application/pls+xml': ['pls'],
  'application/postscript': ['ai', 'eps', 'ps'],
  'application/provenance+xml': ['provx'],
  'application/pskc+xml': ['pskcxml'],
  'application/raml+yaml': ['raml'],
  'application/rdf+xml': ['rdf', 'owl'],
  'application/reginfo+xml': ['rif'],
  'application/relax-ng-compact-syntax': ['rnc'],
  'application/resource-lists+xml': ['rl'],
  'application/resource-lists-diff+xml': ['rld'],
  'application/rls-services+xml': ['rs'],
  'application/route-apd+xml': ['rapd'],
  'application/route-s-tsid+xml': ['sls'],
  'application/route-usd+xml': ['rusd'],
  'application/rpki-ghostbusters': ['gbr'],
  'application/rpki-manifest': ['mft'],
  'application/rpki-roa': ['roa'],
  'application/rsd+xml': ['rsd'],
  'application/rss+xml': ['rss'],
  'application/rtf': ['rtf'],
  'application/sbml+xml': ['sbml'],
  'application/scvp-cv-request': ['scq'],
  'application/scvp-cv-response': ['scs'],
  'application/scvp-vp-request': ['spq'],
  'application/scvp-vp-response': ['spp'],
  'application/sdp': ['sdp'],
  'application/senml+xml': ['senmlx'],
  'application/sensml+xml': ['sensmlx'],
  'application/set-payment-initiation': ['setpay'],
  'application/set-registration-initiation': ['setreg'],
  'application/shf+xml': ['shf'],
  'application/sieve': ['siv', 'sieve'],
  'application/smil+xml': ['smi', 'smil'],
  'application/sparql-query': ['rq'],
  'application/sparql-results+xml': ['srx'],
  'application/sql': ['sql'],
  'application/srgs': ['gram'],
  'application/srgs+xml': ['grxml'],
  'application/sru+xml': ['sru'],
  'application/ssdl+xml': ['ssdl'],
  'application/ssml+xml': ['ssml'],
  'application/swid+xml': ['swidtag'],
  'application/tei+xml': ['tei', 'teicorpus'],
  'application/thraud+xml': ['tfi'],
  'application/timestamped-data': ['tsd'],
  'application/toml': ['toml'],
  'application/trig': ['trig'],
  'application/ttml+xml': ['ttml'],
  'application/ubjson': ['ubj'],
  'application/urc-ressheet+xml': ['rsheet'],
  'application/urc-targetdesc+xml': ['td'],
  'application/voicexml+xml': ['vxml'],
  'application/wasm': ['wasm'],
  'application/watcherinfo+xml': ['wif'],
  'application/widget': ['wgt'],
  'application/winhlp': ['hlp'],
  'application/wsdl+xml': ['wsdl'],
  'application/wspolicy+xml': ['wspolicy'],
  'application/xaml+xml': ['xaml'],
  'application/xcap-att+xml': ['xav'],
  'application/xcap-caps+xml': ['xca'],
  'application/xcap-diff+xml': ['xdf'],
  'application/xcap-el+xml': ['xel'],
  'application/xcap-ns+xml': ['xns'],
  'application/xenc+xml': ['xenc'],
  'application/xfdf': ['xfdf'],
  'application/xhtml+xml': ['xhtml', 'xht'],
  'application/xliff+xml': ['xlf'],
  'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
  'application/xml-dtd': ['dtd'],
  'application/xop+xml': ['xop'],
  'application/xproc+xml': ['xpl'],
  'application/xslt+xml': ['*xsl', 'xslt'],
  'application/xspf+xml': ['xspf'],
  'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
  'application/yang': ['yang'],
  'application/yin+xml': ['yin'],
  'application/zip': ['zip'],
  'audio/3gpp': ['*3gpp'],
  'audio/aac': ['adts', 'aac'],
  'audio/adpcm': ['adp'],
  'audio/amr': ['amr'],
  'audio/basic': ['au', 'snd'],
  'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
  'audio/mobile-xmf': ['mxmf'],
  'audio/mp3': ['*mp3'],
  'audio/mp4': ['m4a', 'mp4a'],
  'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
  'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
  'audio/s3m': ['s3m'],
  'audio/silk': ['sil'],
  'audio/wav': ['wav'],
  'audio/wave': ['*wav'],
  'audio/webm': ['weba'],
  'audio/xm': ['xm'],
  'font/collection': ['ttc'],
  'font/otf': ['otf'],
  'font/ttf': ['ttf'],
  'font/woff': ['woff'],
  'font/woff2': ['woff2'],
  'image/aces': ['exr'],
  'image/apng': ['apng'],
  'image/avci': ['avci'],
  'image/avcs': ['avcs'],
  'image/avif': ['avif'],
  'image/bmp': ['bmp', 'dib'],
  'image/cgm': ['cgm'],
  'image/dicom-rle': ['drle'],
  'image/dpx': ['dpx'],
  'image/emf': ['emf'],
  'image/fits': ['fits'],
  'image/g3fax': ['g3'],
  'image/gif': ['gif'],
  'image/heic': ['heic'],
  'image/heic-sequence': ['heics'],
  'image/heif': ['heif'],
  'image/heif-sequence': ['heifs'],
  'image/hej2k': ['hej2'],
  'image/hsj2': ['hsj2'],
  'image/ief': ['ief'],
  'image/jls': ['jls'],
  'image/jp2': ['jp2', 'jpg2'],
  'image/jpeg': ['jpeg', 'jpg', 'jpe'],
  'image/jph': ['jph'],
  'image/jphc': ['jhc'],
  'image/jpm': ['jpm', 'jpgm'],
  'image/jpx': ['jpx', 'jpf'],
  'image/jxl': ['jxl'],
  'image/jxr': ['jxr'],
  'image/jxra': ['jxra'],
  'image/jxrs': ['jxrs'],
  'image/jxs': ['jxs'],
  'image/jxsc': ['jxsc'],
  'image/jxsi': ['jxsi'],
  'image/jxss': ['jxss'],
  'image/ktx': ['ktx'],
  'image/ktx2': ['ktx2'],
  'image/png': ['png'],
  'image/sgi': ['sgi'],
  'image/svg+xml': ['svg', 'svgz'],
  'image/t38': ['t38'],
  'image/tiff': ['tif', 'tiff'],
  'image/tiff-fx': ['tfx'],
  'image/webp': ['webp'],
  'image/wmf': ['wmf'],
  'message/disposition-notification': ['disposition-notification'],
  'message/global': ['u8msg'],
  'message/global-delivery-status': ['u8dsn'],
  'message/global-disposition-notification': ['u8mdn'],
  'message/global-headers': ['u8hdr'],
  'message/rfc822': ['eml', 'mime'],
  'model/3mf': ['3mf'],
  'model/gltf+json': ['gltf'],
  'model/gltf-binary': ['glb'],
  'model/iges': ['igs', 'iges'],
  'model/jt': ['jt'],
  'model/mesh': ['msh', 'mesh', 'silo'],
  'model/mtl': ['mtl'],
  'model/obj': ['obj'],
  'model/prc': ['prc'],
  'model/step+xml': ['stpx'],
  'model/step+zip': ['stpz'],
  'model/step-xml+zip': ['stpxz'],
  'model/stl': ['stl'],
  'model/u3d': ['u3d'],
  'model/vrml': ['wrl', 'vrml'],
  'model/x3d+binary': ['*x3db', 'x3dbz'],
  'model/x3d+fastinfoset': ['x3db'],
  'model/x3d+vrml': ['*x3dv', 'x3dvz'],
  'model/x3d+xml': ['x3d', 'x3dz'],
  'model/x3d-vrml': ['x3dv'],
  'text/cache-manifest': ['appcache', 'manifest'],
  'text/calendar': ['ics', 'ifb'],
  'text/coffeescript': ['coffee', 'litcoffee'],
  'text/css': ['css'],
  'text/csv': ['csv'],
  'text/html': ['html', 'htm', 'shtml'],
  'text/jade': ['jade'],
  'text/javascript': ['js', 'mjs'],
  'text/jsx': ['jsx'],
  'text/less': ['less'],
  'text/markdown': ['md', 'markdown'],
  'text/mathml': ['mml'],
  'text/mdx': ['mdx'],
  'text/n3': ['n3'],
  'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
  'text/richtext': ['rtx'],
  'text/rtf': ['*rtf'],
  'text/sgml': ['sgml', 'sgm'],
  'text/shex': ['shex'],
  'text/slim': ['slim', 'slm'],
  'text/spdx': ['spdx'],
  'text/stylus': ['stylus', 'styl'],
  'text/tab-separated-values': ['tsv'],
  'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
  'text/turtle': ['ttl'],
  'text/uri-list': ['uri', 'uris', 'urls'],
  'text/vcard': ['vcard'],
  'text/vtt': ['vtt'],
  'text/wgsl': ['wgsl'],
  'text/xml': ['*xml'],
  'text/yaml': ['yaml', 'yml'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['*jpm', '*jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts', 'm2t', 'm2ts', 'mts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/webm': ['webm']
};
Object.freeze(types$2);

var __classPrivateFieldGet$2 = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType$2, _Mime_typeToExtension$2, _Mime_typeToExtensions$2;
let Mime$2 = class Mime {
  constructor(...args) {
    _Mime_extensionToType$2.set(this, new Map());
    _Mime_typeToExtension$2.set(this, new Map());
    _Mime_typeToExtensions$2.set(this, new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type, extensions] of Object.entries(typeMap)) {
      type = type.toLowerCase();
      extensions = extensions.map(ext => ext.toLowerCase());
      if (!__classPrivateFieldGet$2(this, _Mime_typeToExtensions$2, "f").has(type)) {
        __classPrivateFieldGet$2(this, _Mime_typeToExtensions$2, "f").set(type, new Set());
      }
      const allExtensions = __classPrivateFieldGet$2(this, _Mime_typeToExtensions$2, "f").get(type);
      let first = true;
      for (let extension of extensions) {
        const starred = extension.startsWith('*');
        extension = starred ? extension.slice(1) : extension;
        allExtensions?.add(extension);
        if (first) {
          __classPrivateFieldGet$2(this, _Mime_typeToExtension$2, "f").set(type, extension);
        }
        first = false;
        if (starred) continue;
        const currentType = __classPrivateFieldGet$2(this, _Mime_extensionToType$2, "f").get(extension);
        if (currentType && currentType != type && !force) {
          throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
        }
        __classPrivateFieldGet$2(this, _Mime_extensionToType$2, "f").set(extension, type);
      }
    }
    return this;
  }
  getType(path) {
    if (typeof path !== 'string') return null;
    const last = path.replace(/^.*[/\\]/, '').toLowerCase();
    const ext = last.replace(/^.*\./, '').toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath) return null;
    return __classPrivateFieldGet$2(this, _Mime_extensionToType$2, "f").get(ext) ?? null;
  }
  getExtension(type) {
    if (typeof type !== 'string') return null;
    type = type?.split?.(';')[0];
    return (type && __classPrivateFieldGet$2(this, _Mime_typeToExtension$2, "f").get(type.trim().toLowerCase())) ?? null;
  }
  getAllExtensions(type) {
    if (typeof type !== 'string') return null;
    return __classPrivateFieldGet$2(this, _Mime_typeToExtensions$2, "f").get(type.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error('define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances');
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet$2(this, _Mime_typeToExtensions$2, "f").values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet$2(this, _Mime_extensionToType$2, "f"),
      extensions: __classPrivateFieldGet$2(this, _Mime_typeToExtension$2, "f")
    };
  }
};
_Mime_extensionToType$2 = new WeakMap(), _Mime_typeToExtension$2 = new WeakMap(), _Mime_typeToExtensions$2 = new WeakMap();

var mime$2 = new Mime$2(types$2)._freeze();

/**
 * filesize
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.1.6
 */
const ARRAY = "array";
const BIT = "bit";
const BITS = "bits";
const BYTE = "byte";
const BYTES = "bytes";
const EMPTY = "";
const EXPONENT = "exponent";
const FUNCTION = "function";
const IEC = "iec";
const INVALID_NUMBER = "Invalid number";
const INVALID_ROUND = "Invalid rounding method";
const JEDEC = "jedec";
const OBJECT = "object";
const PERIOD = ".";
const ROUND = "round";
const S = "s";
const SI = "si";
const SI_KBIT = "kbit";
const SI_KBYTE = "kB";
const SPACE = " ";
const STRING = "string";
const ZERO = "0";
const STRINGS = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY,
  localeOptions = {},
  separator = EMPTY,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e = exponent,
    num = Number(arg),
    result = [],
    val = 0,
    u = EMPTY;

  // Sync base & standard
  if (standard === SI) {
    base = 10;
    standard = JEDEC;
  } else if (standard === IEC || standard === JEDEC) {
    base = 2;
  } else if (base === 2) {
    standard = IEC;
  } else {
    base = 10;
    standard = JEDEC;
  }
  const ceil = base === 10 ? 1000 : 1024,
    full = fullform === true,
    neg = num < 0,
    roundingFunc = Math[roundingMethod];
  if (typeof arg !== "bigint" && isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }

  // Flipping a negative number to determine the size
  if (neg) {
    num = -num;
  }

  // Determining the exponent
  if (e === -1 || isNaN(e)) {
    e = Math.floor(Math.log(num) / Math.log(ceil));
    if (e < 0) {
      e = 0;
    }
  }

  // Exceeding supported length, time to reduce & multiply
  if (e > 8) {
    if (precision > 0) {
      precision += 8 - e;
    }
    e = 8;
  }
  if (output === EXPONENT) {
    return e;
  }

  // Zero is now a special case because bytes divide by 1
  if (num === 0) {
    result[0] = 0;
    u = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  } else {
    val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e < 8) {
        val = val / ceil;
        e++;
      }
    }
    const p = Math.pow(10, e > 0 ? round : 0);
    result[0] = roundingFunc(val * p) / p;
    if (result[0] === ceil && e < 8 && exponent === -1) {
      result[0] = 1;
      e++;
    }
    u = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  }

  // Decorating a 'diff'
  if (neg) {
    result[0] = -result[0];
  }

  // Setting optional precision
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }

  // Applying custom symbol
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && round > 0) {
    const i = result[0].toString(),
      x = separator || (i.match(/(\D)/g) || []).pop() || PERIOD,
      tmp = i.toString().split(x),
      s = tmp[1] || EMPTY,
      l = s.length,
      n = round - l;
    result[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
  }

  // Returning Array, Object, or String (default)
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e,
    unit: u
  } : result.join(spacer);
}

/**
 * Custom error for error operations.
 */
class FilesystemError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'FilesystemError';
  }
}

/**
 * Class representing a File.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class File {
  path;
  stats;
  /**
   * Create a File.
   *
   * @param path - The file path.
   * @param checkPath - Whether to check if the file path is valid.
   * @returns A new File instance.
   */
  static create(path, checkPath = true) {
    return new this(path, checkPath);
  }
  /**
   * Create a File.
   *
   * @param path - The file path.
   * @param checkPath - Whether to check if the file path is valid.
   */
  constructor(path, checkPath = true) {
    this.path = path;
    if (checkPath) {
      this.validateFile();
    }
  }
  /**
   * Get file content.
   *
   * @returns The content of the file as a string.
   */
  getContent(encoding = 'utf-8') {
    if (!this.isReadable()) {
      throw new FilesystemError(`Could not get the content of the file (${this.path}).`);
    }
    return readFileSync(this.path).toString(encoding);
  }
  /**
   * Write content to file.
   *
   * @param content - The content to write to the file.
   * @returns The current File instance.
   */
  write(content) {
    if (!this.isWritable()) {
      throw new FilesystemError(`Could not write content to this file (${this.path}).`);
    }
    writeFileSync(this.path, content, 'utf-8');
    return this;
  }
  /**
   * Edit file content.
   *
   * @param callback - The callback function to modify the file content.
   * @returns The current File instance.
   */
  edit(callback) {
    return this.write(callback(this.getContent()));
  }
  /**
   * Move file to a new directory.
   *
   * @param directory - The target directory.
   * @param name - The new name for the file.
   * @returns The new File instance representing the moved file.
   * @throws FileError if the file could not be moved.
   */
  move(directory, name) {
    const target = this.getTargetFile(directory, name);
    try {
      renameSync(this.getPath(), target.getPath());
    } catch (error) {
      throw new FilesystemError(`Could not move the file "${this.getPath()}" to "${target.getPath()}" (${String(error.message)}).`);
    }
    chmodSync(target.getPath(), 0o666);
    return target;
  }
  /**
   * Remove file.
   *
   * @param force - Whether to forcefully remove the file.
   * @returns The current File instance.
   */
  remove(force = false) {
    try {
      rmSync(this.path, {
        force
      });
    } catch (error) {
      throw new FilesystemError(`Could not remove this file (${this.path}) (${String(error.message)}).`);
    }
    return this;
  }
  /**
   * Get the hashed content of the file.
   *
   * @param algo - The hashing algorithm to use.
   * @returns The hashed content of the file as a hex string.
   */
  getHashedContent(algo = 'sha256') {
    return createHash(algo).update(this.getContent(), 'utf-8').digest('hex');
  }
  /**
   * Get file size.
   *
   * @param formatted - Whether to return the file size as a formatted string.
   * @returns The file size as a string or number.
   */
  getSize(formatted = false) {
    const size = this.getStats()?.size;
    return size !== undefined && formatted ? filesize(Number(size)) : size;
  }
  /**
   * Get the MIME type of the file.
   *
   * @param fallback - A fallback MIME type if detection fails.
   * @returns The MIME type of the file.
   */
  getMimeType(fallback) {
    return mime$2.getType(this.path) ?? fallback;
  }
  /**
   * Get the directory name of the file.
   *
   * @returns The directory name.
   */
  getDirname() {
    return dirname(this.path);
  }
  /**
   * Get the file path.
   *
   * @returns The file path.
   */
  getPath() {
    return this.path;
  }
  /**
   * Get the encoded file path.
   *
   * @returns The encoded file path.
   */
  getEncodedPath() {
    return encodeURI(this.getPath());
  }
  /**
  * Get the absolute file path.
  *
  * @param root - The root directory to resolve from.
  * @returns The absolute file path.
  */
  getAbsolutePath(root = '') {
    return resolve(root, this.path);
  }
  /**
   * Get the encoded absolute file path.
   *
   * @param root - The root directory to resolve from.
   * @returns The encoded absolute file path.
   */
  getEncodedAbsolutePath(root = '') {
    return encodeURI(this.getAbsolutePath(root));
  }
  /**
   * Get the basename of the file.
   *
   * @param exclude - The file extension to exclude from the basename.
   * @returns The basename of the file.
   */
  getBasename(exclude = '') {
    return basename(this.path, exclude);
  }
  /**
   * Get the filename of the file.
   *
   * @returns The filename of the file.
   */
  getFilename() {
    return this.getBasename();
  }
  /**
   * Get the name of the file without extension.
   *
   * @returns The name of the file.
   */
  getName() {
    return this.getBasename(this.getExtension());
  }
  /**
   * Get the file extension.
   *
   * @returns The file extension.
   */
  getExtension() {
    return extname(this.path);
  }
  /**
   * Get the last access time of the file.
   *
   * @returns The last access time in milliseconds.
   */
  getATime() {
    return this.getStats()?.atimeMs;
  }
  /**
   * Get the last modified time of the file.
   *
   * @returns The last modified time in milliseconds.
   */
  getMTime() {
    return this.getStats()?.mtimeMs;
  }
  /**
   * Get the created time of the file.
   *
   * @returns The created time in milliseconds.
   */
  getCTime() {
    return this.getStats()?.ctimeMs;
  }
  /**
   * Check if the file exists.
   *
   * @returns True if the file exists, otherwise false.
   */
  exists() {
    return existsSync(this.path);
  }
  /**
   * Check if the file path starts with a provided prefix.
   *
   * @returns True if the file path starts with the provided prefix, otherwise false.
   */
  isPathPrefix(prefix) {
    return this.path.startsWith(realpathSync(prefix));
  }
  /**
   * Check if the file is compressed.
   *
   * @returns True if the file is compressed, otherwise false.
   */
  isCompressed(extensions = ['.br', '.brotli', '.gz', '.gzip']) {
    return extensions.includes(this.getExtension());
  }
  /**
   * Check if the file is a directory.
   *
   * @returns True if the file is a directory, otherwise false.
   */
  isDir() {
    return this.getStats()?.isDirectory?.() ?? false;
  }
  /**
   * Check if the file is a regular file.
   *
   * @returns True if the file is a regular file, otherwise false.
   */
  isFile() {
    return this.getStats()?.isFile?.() ?? false;
  }
  /**
   * Check if the file is a symbolic link.
   *
   * @returns True if the file is a symbolic link, otherwise false.
   */
  isLink() {
    return this.getStats()?.isSymbolicLink?.() ?? false;
  }
  /**
   * Check if the file path is absolute.
   *
   * @returns True if the file path is absolute, otherwise false.
   */
  isAbsolute() {
    return isAbsolute(this.path);
  }
  /**
   * Check if the file is writable.
   *
   * @returns True if the file is writable, otherwise false.
   */
  isWritable() {
    try {
      accessSync(this.path, constants.W_OK);
      return true;
    } catch (_) {
      return false;
    }
  }
  /**
   * Check if the file is readable.
   *
   * @returns True if the file is readable, otherwise false.
   */
  isReadable() {
    try {
      accessSync(this.path, constants.R_OK);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if the file is executable.
   *
   * @returns True if the file is executable, otherwise false.
   */
  isExecutable() {
    try {
      accessSync(this.path, constants.X_OK);
      return true;
    } catch (_) {
      return false;
    }
  }
  /**
   * Get the file statistics.
   *
   * @returns The file statistics object.
   */
  getStats() {
    if (this.stats === undefined) {
      this.stats = statSync(this.path);
    }
    return this.stats;
  }
  /**
   * Validate if the file exists.
   *
   * @throws FileError if the file does not exist.
   */
  validateFile() {
    if (!this.exists()) {
      throw new FilesystemError(`File not found. (${this.path})`);
    }
  }
  /**
   * Get the target file instance for moving or copying operations.
   *
   * @param directory - The target directory.
   * @param name - The new name for the file.
   * @returns A new File instance representing the target file.
   * @throws FileError if the directory cannot be created or is not writable.
   */
  getTargetFile(directory, name = null) {
    if (!existsSync(directory)) {
      try {
        mkdirSync(directory, {
          recursive: true
        });
      } catch (_) {
        throw new FilesystemError(`Unable to create the "${directory}" directory.`);
      }
    } else {
      try {
        accessSync(directory, constants.W_OK);
      } catch (_) {
        throw new FilesystemError(`Unable to write in the "${directory}" directory.`);
      }
    }
    return new File(join(directory, name ?? this.getFilename()), false);
  }
}

/**
 * Class representing an UploadedFile.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class UploadedFile extends File {
  mimeType;
  originalName;
  /**
   * Create an UploadedFile.
   *
   * @param path - The file path.
   * @param originalName - The original name of the uploaded file.
   * @param mimeType - The MIME type of the file.
   * @returns A new UploadedFile instance.
   */
  static createFile(path, originalName, mimeType, checkPath = true) {
    return new this(path, originalName, mimeType, checkPath);
  }
  /**
   * Create an UploadedFile.
   *
   * @param path - The file path.
   * @param originalName - The original name of the uploaded file.
   * @param mimeType - The MIME type of the file.
   */
  constructor(path, originalName, mimeType, checkPath = true) {
    super(path, checkPath);
    this.originalName = basename(originalName);
    this.mimeType = mimeType ?? 'application/octet-stream';
  }
  /**
   * Get the original name of the uploaded file.
   *
   * @returns The original name of the file.
   */
  getClientOriginalName() {
    return this.originalName;
  }
  /**
   * Get the original file extension of the uploaded file.
   *
   * @returns The original file extension.
   */
  getClientOriginalExtension() {
    return extname(this.originalName);
  }
  /**
   * Get the MIME type of the uploaded file.
   *
   * @returns The MIME type of the file.
   */
  getClientMimeType() {
    return this.mimeType;
  }
  /**
   * Guess the client file extension based on the MIME type.
   *
   * @returns The guessed file extension.
   */
  guessClientExtension() {
    return mime$2.getExtension(this.getClientMimeType()) ?? undefined;
  }
  /**
   * Check if the uploaded file is valid.
   *
   * @returns True if the file exists, otherwise false.
   */
  isValid() {
    return this.exists();
  }
  /**
   * Move the uploaded file to a new directory.
   *
   * @param directory - The target directory.
   * @param name - The new name for the file.
   * @returns The current UploadedFile instance.
   * @throws FileError if the file is not valid.
   */
  move(directory, name) {
    if (this.isValid()) {
      return super.move(directory, name);
    }
    throw new FilesystemError('No file was uploaded.');
  }
}

var vary$1 = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary$1.exports;
  hasRequiredVary = 1;

  /**
   * Module exports.
   */

  vary$1.exports = vary;
  vary$1.exports.append = append;

  /**
   * RegExp to match field-name in RFC 7230 sec 3.2
   *
   * field-name    = token
   * token         = 1*tchar
   * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   *               / DIGIT / ALPHA
   *               ; any VCHAR, except delimiters
   */

  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

  /**
   * Append a field to a vary header.
   *
   * @param {String} header
   * @param {String|Array} field
   * @return {String}
   * @public
   */

  function append(header, field) {
    if (typeof header !== 'string') {
      throw new TypeError('header argument is required');
    }
    if (!field) {
      throw new TypeError('field argument is required');
    }

    // get fields array
    var fields = !Array.isArray(field) ? parse(String(field)) : field;

    // assert on invalid field names
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError('field argument contains an invalid header name');
      }
    }

    // existing, unspecified vary
    if (header === '*') {
      return header;
    }

    // enumerate current values
    var val = header;
    var vals = parse(header.toLowerCase());

    // unspecified vary
    if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
      return '*';
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();

      // append value (case-preserving)
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ', ' + fields[i] : fields[i];
      }
    }
    return val;
  }

  /**
   * Parse a vary header into an array.
   *
   * @param {String} header
   * @return {Array}
   * @private
   */

  function parse(header) {
    var end = 0;
    var list = [];
    var start = 0;

    // gather tokens
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 0x20:
          /*   */
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 0x2c:
          /* , */
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }

    // final token
    list.push(header.substring(start, end));
    return list;
  }

  /**
   * Mark that a request is varied on a header field.
   *
   * @param {Object} res
   * @param {String|Array} field
   * @public
   */

  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      // quack quack
      throw new TypeError('res argument is required');
    }

    // get existing header
    var val = res.getHeader('Vary') || '';
    var header = Array.isArray(val) ? val.join(', ') : String(val);

    // set new header
    if (val = append(header, field)) {
      res.setHeader('Vary', val);
    }
  }
  return vary$1.exports;
}

var varyExports = requireVary();
var vary = /*@__PURE__*/getDefaultExportFromCjs(varyExports);

const types$1 = {
  'application/andrew-inset': ['ez'],
  'application/appinstaller': ['appinstaller'],
  'application/applixware': ['aw'],
  'application/appx': ['appx'],
  'application/appxbundle': ['appxbundle'],
  'application/atom+xml': ['atom'],
  'application/atomcat+xml': ['atomcat'],
  'application/atomdeleted+xml': ['atomdeleted'],
  'application/atomsvc+xml': ['atomsvc'],
  'application/atsc-dwd+xml': ['dwd'],
  'application/atsc-held+xml': ['held'],
  'application/atsc-rsat+xml': ['rsat'],
  'application/automationml-aml+xml': ['aml'],
  'application/automationml-amlx+zip': ['amlx'],
  'application/bdoc': ['bdoc'],
  'application/calendar+xml': ['xcs'],
  'application/ccxml+xml': ['ccxml'],
  'application/cdfx+xml': ['cdfx'],
  'application/cdmi-capability': ['cdmia'],
  'application/cdmi-container': ['cdmic'],
  'application/cdmi-domain': ['cdmid'],
  'application/cdmi-object': ['cdmio'],
  'application/cdmi-queue': ['cdmiq'],
  'application/cpl+xml': ['cpl'],
  'application/cu-seeme': ['cu'],
  'application/cwl': ['cwl'],
  'application/dash+xml': ['mpd'],
  'application/dash-patch+xml': ['mpp'],
  'application/davmount+xml': ['davmount'],
  'application/docbook+xml': ['dbk'],
  'application/dssc+der': ['dssc'],
  'application/dssc+xml': ['xdssc'],
  'application/ecmascript': ['ecma'],
  'application/emma+xml': ['emma'],
  'application/emotionml+xml': ['emotionml'],
  'application/epub+zip': ['epub'],
  'application/exi': ['exi'],
  'application/express': ['exp'],
  'application/fdf': ['fdf'],
  'application/fdt+xml': ['fdt'],
  'application/font-tdpfr': ['pfr'],
  'application/geo+json': ['geojson'],
  'application/gml+xml': ['gml'],
  'application/gpx+xml': ['gpx'],
  'application/gxf': ['gxf'],
  'application/gzip': ['gz'],
  'application/hjson': ['hjson'],
  'application/hyperstudio': ['stk'],
  'application/inkml+xml': ['ink', 'inkml'],
  'application/ipfix': ['ipfix'],
  'application/its+xml': ['its'],
  'application/java-archive': ['jar', 'war', 'ear'],
  'application/java-serialized-object': ['ser'],
  'application/java-vm': ['class'],
  'application/javascript': ['*js'],
  'application/json': ['json', 'map'],
  'application/json5': ['json5'],
  'application/jsonml+json': ['jsonml'],
  'application/ld+json': ['jsonld'],
  'application/lgr+xml': ['lgr'],
  'application/lost+xml': ['lostxml'],
  'application/mac-binhex40': ['hqx'],
  'application/mac-compactpro': ['cpt'],
  'application/mads+xml': ['mads'],
  'application/manifest+json': ['webmanifest'],
  'application/marc': ['mrc'],
  'application/marcxml+xml': ['mrcx'],
  'application/mathematica': ['ma', 'nb', 'mb'],
  'application/mathml+xml': ['mathml'],
  'application/mbox': ['mbox'],
  'application/media-policy-dataset+xml': ['mpf'],
  'application/mediaservercontrol+xml': ['mscml'],
  'application/metalink+xml': ['metalink'],
  'application/metalink4+xml': ['meta4'],
  'application/mets+xml': ['mets'],
  'application/mmt-aei+xml': ['maei'],
  'application/mmt-usd+xml': ['musd'],
  'application/mods+xml': ['mods'],
  'application/mp21': ['m21', 'mp21'],
  'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],
  'application/msix': ['msix'],
  'application/msixbundle': ['msixbundle'],
  'application/msword': ['doc', 'dot'],
  'application/mxf': ['mxf'],
  'application/n-quads': ['nq'],
  'application/n-triples': ['nt'],
  'application/node': ['cjs'],
  'application/octet-stream': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy', 'exe', 'dll', 'deb', 'dmg', 'iso', 'img', 'msi', 'msp', 'msm', 'buffer'],
  'application/oda': ['oda'],
  'application/oebps-package+xml': ['opf'],
  'application/ogg': ['ogx'],
  'application/omdoc+xml': ['omdoc'],
  'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
  'application/oxps': ['oxps'],
  'application/p2p-overlay+xml': ['relo'],
  'application/patch-ops-error+xml': ['xer'],
  'application/pdf': ['pdf'],
  'application/pgp-encrypted': ['pgp'],
  'application/pgp-keys': ['asc'],
  'application/pgp-signature': ['sig', '*asc'],
  'application/pics-rules': ['prf'],
  'application/pkcs10': ['p10'],
  'application/pkcs7-mime': ['p7m', 'p7c'],
  'application/pkcs7-signature': ['p7s'],
  'application/pkcs8': ['p8'],
  'application/pkix-attr-cert': ['ac'],
  'application/pkix-cert': ['cer'],
  'application/pkix-crl': ['crl'],
  'application/pkix-pkipath': ['pkipath'],
  'application/pkixcmp': ['pki'],
  'application/pls+xml': ['pls'],
  'application/postscript': ['ai', 'eps', 'ps'],
  'application/provenance+xml': ['provx'],
  'application/pskc+xml': ['pskcxml'],
  'application/raml+yaml': ['raml'],
  'application/rdf+xml': ['rdf', 'owl'],
  'application/reginfo+xml': ['rif'],
  'application/relax-ng-compact-syntax': ['rnc'],
  'application/resource-lists+xml': ['rl'],
  'application/resource-lists-diff+xml': ['rld'],
  'application/rls-services+xml': ['rs'],
  'application/route-apd+xml': ['rapd'],
  'application/route-s-tsid+xml': ['sls'],
  'application/route-usd+xml': ['rusd'],
  'application/rpki-ghostbusters': ['gbr'],
  'application/rpki-manifest': ['mft'],
  'application/rpki-roa': ['roa'],
  'application/rsd+xml': ['rsd'],
  'application/rss+xml': ['rss'],
  'application/rtf': ['rtf'],
  'application/sbml+xml': ['sbml'],
  'application/scvp-cv-request': ['scq'],
  'application/scvp-cv-response': ['scs'],
  'application/scvp-vp-request': ['spq'],
  'application/scvp-vp-response': ['spp'],
  'application/sdp': ['sdp'],
  'application/senml+xml': ['senmlx'],
  'application/sensml+xml': ['sensmlx'],
  'application/set-payment-initiation': ['setpay'],
  'application/set-registration-initiation': ['setreg'],
  'application/shf+xml': ['shf'],
  'application/sieve': ['siv', 'sieve'],
  'application/smil+xml': ['smi', 'smil'],
  'application/sparql-query': ['rq'],
  'application/sparql-results+xml': ['srx'],
  'application/sql': ['sql'],
  'application/srgs': ['gram'],
  'application/srgs+xml': ['grxml'],
  'application/sru+xml': ['sru'],
  'application/ssdl+xml': ['ssdl'],
  'application/ssml+xml': ['ssml'],
  'application/swid+xml': ['swidtag'],
  'application/tei+xml': ['tei', 'teicorpus'],
  'application/thraud+xml': ['tfi'],
  'application/timestamped-data': ['tsd'],
  'application/toml': ['toml'],
  'application/trig': ['trig'],
  'application/ttml+xml': ['ttml'],
  'application/ubjson': ['ubj'],
  'application/urc-ressheet+xml': ['rsheet'],
  'application/urc-targetdesc+xml': ['td'],
  'application/voicexml+xml': ['vxml'],
  'application/wasm': ['wasm'],
  'application/watcherinfo+xml': ['wif'],
  'application/widget': ['wgt'],
  'application/winhlp': ['hlp'],
  'application/wsdl+xml': ['wsdl'],
  'application/wspolicy+xml': ['wspolicy'],
  'application/xaml+xml': ['xaml'],
  'application/xcap-att+xml': ['xav'],
  'application/xcap-caps+xml': ['xca'],
  'application/xcap-diff+xml': ['xdf'],
  'application/xcap-el+xml': ['xel'],
  'application/xcap-ns+xml': ['xns'],
  'application/xenc+xml': ['xenc'],
  'application/xfdf': ['xfdf'],
  'application/xhtml+xml': ['xhtml', 'xht'],
  'application/xliff+xml': ['xlf'],
  'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
  'application/xml-dtd': ['dtd'],
  'application/xop+xml': ['xop'],
  'application/xproc+xml': ['xpl'],
  'application/xslt+xml': ['*xsl', 'xslt'],
  'application/xspf+xml': ['xspf'],
  'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
  'application/yang': ['yang'],
  'application/yin+xml': ['yin'],
  'application/zip': ['zip'],
  'audio/3gpp': ['*3gpp'],
  'audio/aac': ['adts', 'aac'],
  'audio/adpcm': ['adp'],
  'audio/amr': ['amr'],
  'audio/basic': ['au', 'snd'],
  'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
  'audio/mobile-xmf': ['mxmf'],
  'audio/mp3': ['*mp3'],
  'audio/mp4': ['m4a', 'mp4a'],
  'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
  'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
  'audio/s3m': ['s3m'],
  'audio/silk': ['sil'],
  'audio/wav': ['wav'],
  'audio/wave': ['*wav'],
  'audio/webm': ['weba'],
  'audio/xm': ['xm'],
  'font/collection': ['ttc'],
  'font/otf': ['otf'],
  'font/ttf': ['ttf'],
  'font/woff': ['woff'],
  'font/woff2': ['woff2'],
  'image/aces': ['exr'],
  'image/apng': ['apng'],
  'image/avci': ['avci'],
  'image/avcs': ['avcs'],
  'image/avif': ['avif'],
  'image/bmp': ['bmp', 'dib'],
  'image/cgm': ['cgm'],
  'image/dicom-rle': ['drle'],
  'image/dpx': ['dpx'],
  'image/emf': ['emf'],
  'image/fits': ['fits'],
  'image/g3fax': ['g3'],
  'image/gif': ['gif'],
  'image/heic': ['heic'],
  'image/heic-sequence': ['heics'],
  'image/heif': ['heif'],
  'image/heif-sequence': ['heifs'],
  'image/hej2k': ['hej2'],
  'image/hsj2': ['hsj2'],
  'image/ief': ['ief'],
  'image/jls': ['jls'],
  'image/jp2': ['jp2', 'jpg2'],
  'image/jpeg': ['jpeg', 'jpg', 'jpe'],
  'image/jph': ['jph'],
  'image/jphc': ['jhc'],
  'image/jpm': ['jpm', 'jpgm'],
  'image/jpx': ['jpx', 'jpf'],
  'image/jxl': ['jxl'],
  'image/jxr': ['jxr'],
  'image/jxra': ['jxra'],
  'image/jxrs': ['jxrs'],
  'image/jxs': ['jxs'],
  'image/jxsc': ['jxsc'],
  'image/jxsi': ['jxsi'],
  'image/jxss': ['jxss'],
  'image/ktx': ['ktx'],
  'image/ktx2': ['ktx2'],
  'image/png': ['png'],
  'image/sgi': ['sgi'],
  'image/svg+xml': ['svg', 'svgz'],
  'image/t38': ['t38'],
  'image/tiff': ['tif', 'tiff'],
  'image/tiff-fx': ['tfx'],
  'image/webp': ['webp'],
  'image/wmf': ['wmf'],
  'message/disposition-notification': ['disposition-notification'],
  'message/global': ['u8msg'],
  'message/global-delivery-status': ['u8dsn'],
  'message/global-disposition-notification': ['u8mdn'],
  'message/global-headers': ['u8hdr'],
  'message/rfc822': ['eml', 'mime'],
  'model/3mf': ['3mf'],
  'model/gltf+json': ['gltf'],
  'model/gltf-binary': ['glb'],
  'model/iges': ['igs', 'iges'],
  'model/jt': ['jt'],
  'model/mesh': ['msh', 'mesh', 'silo'],
  'model/mtl': ['mtl'],
  'model/obj': ['obj'],
  'model/prc': ['prc'],
  'model/step+xml': ['stpx'],
  'model/step+zip': ['stpz'],
  'model/step-xml+zip': ['stpxz'],
  'model/stl': ['stl'],
  'model/u3d': ['u3d'],
  'model/vrml': ['wrl', 'vrml'],
  'model/x3d+binary': ['*x3db', 'x3dbz'],
  'model/x3d+fastinfoset': ['x3db'],
  'model/x3d+vrml': ['*x3dv', 'x3dvz'],
  'model/x3d+xml': ['x3d', 'x3dz'],
  'model/x3d-vrml': ['x3dv'],
  'text/cache-manifest': ['appcache', 'manifest'],
  'text/calendar': ['ics', 'ifb'],
  'text/coffeescript': ['coffee', 'litcoffee'],
  'text/css': ['css'],
  'text/csv': ['csv'],
  'text/html': ['html', 'htm', 'shtml'],
  'text/jade': ['jade'],
  'text/javascript': ['js', 'mjs'],
  'text/jsx': ['jsx'],
  'text/less': ['less'],
  'text/markdown': ['md', 'markdown'],
  'text/mathml': ['mml'],
  'text/mdx': ['mdx'],
  'text/n3': ['n3'],
  'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
  'text/richtext': ['rtx'],
  'text/rtf': ['*rtf'],
  'text/sgml': ['sgml', 'sgm'],
  'text/shex': ['shex'],
  'text/slim': ['slim', 'slm'],
  'text/spdx': ['spdx'],
  'text/stylus': ['stylus', 'styl'],
  'text/tab-separated-values': ['tsv'],
  'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
  'text/turtle': ['ttl'],
  'text/uri-list': ['uri', 'uris', 'urls'],
  'text/vcard': ['vcard'],
  'text/vtt': ['vtt'],
  'text/wgsl': ['wgsl'],
  'text/xml': ['*xml'],
  'text/yaml': ['yaml', 'yml'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['*jpm', '*jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts', 'm2t', 'm2ts', 'mts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/webm': ['webm']
};
Object.freeze(types$1);

var __classPrivateFieldGet$1 = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType$1, _Mime_typeToExtension$1, _Mime_typeToExtensions$1;
let Mime$1 = class Mime {
  constructor(...args) {
    _Mime_extensionToType$1.set(this, new Map());
    _Mime_typeToExtension$1.set(this, new Map());
    _Mime_typeToExtensions$1.set(this, new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type, extensions] of Object.entries(typeMap)) {
      type = type.toLowerCase();
      extensions = extensions.map(ext => ext.toLowerCase());
      if (!__classPrivateFieldGet$1(this, _Mime_typeToExtensions$1, "f").has(type)) {
        __classPrivateFieldGet$1(this, _Mime_typeToExtensions$1, "f").set(type, new Set());
      }
      const allExtensions = __classPrivateFieldGet$1(this, _Mime_typeToExtensions$1, "f").get(type);
      let first = true;
      for (let extension of extensions) {
        const starred = extension.startsWith('*');
        extension = starred ? extension.slice(1) : extension;
        allExtensions?.add(extension);
        if (first) {
          __classPrivateFieldGet$1(this, _Mime_typeToExtension$1, "f").set(type, extension);
        }
        first = false;
        if (starred) continue;
        const currentType = __classPrivateFieldGet$1(this, _Mime_extensionToType$1, "f").get(extension);
        if (currentType && currentType != type && !force) {
          throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
        }
        __classPrivateFieldGet$1(this, _Mime_extensionToType$1, "f").set(extension, type);
      }
    }
    return this;
  }
  getType(path) {
    if (typeof path !== 'string') return null;
    const last = path.replace(/^.*[/\\]/, '').toLowerCase();
    const ext = last.replace(/^.*\./, '').toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath) return null;
    return __classPrivateFieldGet$1(this, _Mime_extensionToType$1, "f").get(ext) ?? null;
  }
  getExtension(type) {
    if (typeof type !== 'string') return null;
    type = type?.split?.(';')[0];
    return (type && __classPrivateFieldGet$1(this, _Mime_typeToExtension$1, "f").get(type.trim().toLowerCase())) ?? null;
  }
  getAllExtensions(type) {
    if (typeof type !== 'string') return null;
    return __classPrivateFieldGet$1(this, _Mime_typeToExtensions$1, "f").get(type.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error('define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances');
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet$1(this, _Mime_typeToExtensions$1, "f").values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet$1(this, _Mime_extensionToType$1, "f"),
      extensions: __classPrivateFieldGet$1(this, _Mime_typeToExtension$1, "f")
    };
  }
};
_Mime_extensionToType$1 = new WeakMap(), _Mime_typeToExtension$1 = new WeakMap(), _Mime_typeToExtensions$1 = new WeakMap();

var mime$1 = new Mime$1(types$1)._freeze();

var require$$0$5 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$3;
var hasRequiredStatuses$1;
function requireStatuses$1() {
  if (hasRequiredStatuses$1) return statuses$3;
  hasRequiredStatuses$1 = 1;

  /**
   * Module dependencies.
   * @private
   */

  var codes = require$$0$5;

  /**
   * Module exports.
   * @public
   */

  statuses$3 = status;

  // status code to message map
  status.message = codes;

  // status message (lower-case) to code map
  status.code = createMessageToStatusCodeMap(codes);

  // array of status codes
  status.codes = createStatusCodeList(codes);

  // status codes for redirects
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };

  // status codes for empty bodies
  status.empty = {
    204: true,
    205: true,
    304: true
  };

  // status codes for when you should retry the request
  status.retry = {
    502: true,
    503: true,
    504: true
  };

  /**
   * Create a map of message to status code.
   * @private
   */

  function createMessageToStatusCodeMap(codes) {
    var map = {};
    Object.keys(codes).forEach(function forEachCode(code) {
      var message = codes[code];
      var status = Number(code);

      // populate map
      map[message.toLowerCase()] = status;
    });
    return map;
  }

  /**
   * Create a list of all status codes.
   * @private
   */

  function createStatusCodeList(codes) {
    return Object.keys(codes).map(function mapCode(code) {
      return Number(code);
    });
  }

  /**
   * Get the status code for given message.
   * @private
   */

  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }

  /**
   * Get the status message for given code.
   * @private
   */

  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error('invalid status code: ' + code);
    }
    return status.message[code];
  }

  /**
   * Get the status code.
   *
   * Given a number, this will throw if it is not a known status
   * code, otherwise the code will be returned. Given a string,
   * the string will be parsed for a number and return the code
   * if valid, otherwise will lookup the code assuming this is
   * the status message.
   *
   * @param {string|number} code
   * @returns {number}
   * @public
   */

  function status(code) {
    if (typeof code === 'number') {
      return getStatusMessage(code);
    }
    if (typeof code !== 'string') {
      throw new TypeError('code must be a number or string');
    }

    // '403'
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses$3;
}

var statusesExports$1 = requireStatuses$1();
var statuses$2 = /*@__PURE__*/getDefaultExportFromCjs(statusesExports$1);

var contentType = {};

/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;

  /**
   * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
   *
   * parameter     = token "=" ( token / quoted-string )
   * token         = 1*tchar
   * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   *               / DIGIT / ALPHA
   *               ; any VCHAR, except delimiters
   * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
   * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
   * obs-text      = %x80-FF
   * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
   */
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/; // eslint-disable-line no-control-regex
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

  /**
   * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
   *
   * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
   * obs-text    = %x80-FF
   */
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g; // eslint-disable-line no-control-regex

  /**
   * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
   */
  var QUOTE_REGEXP = /([\\"])/g;

  /**
   * RegExp to match type in RFC 7231 sec 3.1.1.1
   *
   * media-type = type "/" subtype
   * type       = token
   * subtype    = token
   */
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

  /**
   * Module exports.
   * @public
   */

  contentType.format = format;
  contentType.parse = parse;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @public
   */

  function format(obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
      throw new TypeError('invalid type');
    }
    var string = type;

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError('invalid parameter name');
        }
        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }
    return string;
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @public
   */

  function parse(string) {
    if (!string) {
      throw new TypeError('argument string is required');
    }

    // support req/res-like objects as argument
    var header = typeof string === 'object' ? getcontenttype(string) : string;
    if (typeof header !== 'string') {
      throw new TypeError('argument string is required to be a string');
    }
    var index = header.indexOf(';');
    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
      throw new TypeError('invalid media type');
    }
    var obj = new ContentType(type.toLowerCase());

    // parse parameters
    if (index !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 0x22 /* " */) {
          // remove quotes
          value = value.slice(1, -1);

          // remove escapes
          if (value.indexOf('\\') !== -1) {
            value = value.replace(QESC_REGEXP, '$1');
          }
        }
        obj.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError('invalid parameter format');
      }
    }
    return obj;
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @private
   */

  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === 'function') {
      // res-like
      header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
      // req-like
      header = obj.headers && obj.headers['content-type'];
    }
    if (typeof header !== 'string') {
      throw new TypeError('content-type header is missing from object');
    }
    return header;
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function qstring(val) {
    var str = String(val);

    // no need to quote tokens
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
  }

  /**
   * Class to represent a content type.
   * @private
   */
  function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
  }
  return contentType;
}

var contentTypeExports = requireContentType();
var contentTypeLib = /*@__PURE__*/getDefaultExportFromCjs(contentTypeExports);

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$6.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$5.call(value, symToStringTag$1),
    tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$5.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
  undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
  symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
  funcTag = '[object Function]',
  genTag = '[object GeneratorFunction]',
  proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
  objectProto$4 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
    index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$1 || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function (string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -Infinity ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
    length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$1(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
    length = path.length,
    result = false;
  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

var dist = {};

var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", {
    value: true
  });
  dist.parse = parse;
  dist.serialize = serialize;
  /**
   * RegExp to match cookie-name in RFC 6265 sec 4.1.1
   * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
   * which has been replaced by the token definition in RFC 7230 appendix B.
   *
   * cookie-name       = token
   * token             = 1*tchar
   * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
   *                     "*" / "+" / "-" / "." / "^" / "_" /
   *                     "`" / "|" / "~" / DIGIT / ALPHA
   *
   * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
   * Allow same range as cookie value, except `=`, which delimits end of name.
   */
  const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  /**
   * RegExp to match cookie-value in RFC 6265 sec 4.1.1
   *
   * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
   * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
   *                     ; US-ASCII characters excluding CTLs,
   *                     ; whitespace DQUOTE, comma, semicolon,
   *                     ; and backslash
   *
   * Allowing more characters: https://github.com/jshttp/cookie/issues/191
   * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
   */
  const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  /**
   * RegExp to match domain-value in RFC 6265 sec 4.1.1
   *
   * domain-value      = <subdomain>
   *                     ; defined in [RFC1034], Section 3.5, as
   *                     ; enhanced by [RFC1123], Section 2.1
   * <subdomain>       = <label> | <subdomain> "." <label>
   * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
   *                     Labels must be 63 characters or less.
   *                     'let-dig' not 'letter' in the first char, per RFC1123
   * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
   * <let-dig-hyp>     = <let-dig> | "-"
   * <let-dig>         = <letter> | <digit>
   * <letter>          = any one of the 52 alphabetic characters A through Z in
   *                     upper case and a through z in lower case
   * <digit>           = any one of the ten digits 0 through 9
   *
   * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
   *
   * > (Note that a leading %x2E ("."), if present, is ignored even though that
   * character is not permitted, but a trailing %x2E ("."), if present, will
   * cause the user agent to ignore the attribute.)
   */
  const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  /**
   * RegExp to match path-value in RFC 6265 sec 4.1.1
   *
   * path-value        = <any CHAR except CTLs or ";">
   * CHAR              = %x01-7F
   *                     ; defined in RFC 5234 appendix B.1
   */
  const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  const __toString = Object.prototype.toString;
  const NullObject = /* @__PURE__ */(() => {
    const C = function () {};
    C.prototype = Object.create(null);
    return C;
  })();
  /**
   * Parse a cookie header.
   *
   * Parse the given cookie header string into an object
   * The object has the various cookies as keys(names) => values
   */
  function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2) return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) break; // No more cookie pairs.
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        // backtrack on prior semicolon
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      // only assign once
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
    }
    return min;
  }
  /**
   * Serialize data into a cookie header.
   *
   * Serialize a name value pair into a cookie string suitable for
   * http headers. An optional options object specifies cookie parameters.
   *
   * serialize('foo', 'bar', { httpOnly: true })
   *   => "foo=bar; httpOnly"
   */
  function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options) return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  /**
   * URL-decode string value. Optimized to skip native call when no %.
   */
  function decode(str) {
    if (str.indexOf("%") === -1) return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  /**
   * Determine if value is a Date.
   */
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  return dist;
}

var distExports = requireDist();

var cookieSignature = {};

/**
 * Module dependencies.
 */
var hasRequiredCookieSignature;
function requireCookieSignature() {
  if (hasRequiredCookieSignature) return cookieSignature;
  hasRequiredCookieSignature = 1;
  (function (exports) {
    var crypto = require$$0$b;

    /**
     * Sign the given `val` with `secret`.
     *
     * @param {String} val
     * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
     * @return {String}
     * @api private
     */

    exports.sign = function (val, secret) {
      if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
    };

    /**
     * Unsign and decode the given `input` with `secret`,
     * returning `false` if the signature is invalid.
     *
     * @param {String} input
     * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
     * @return {String|Boolean}
     * @api private
     */

    exports.unsign = function (input, secret) {
      if ('string' != typeof input) throw new TypeError("Signed cookie string must be provided.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf('.')),
        expectedInput = exports.sign(tentativeValue, secret),
        expectedBuffer = Buffer.from(expectedInput),
        inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
    };
  })(cookieSignature);
  return cookieSignature;
}

var cookieSignatureExports = requireCookieSignature();

/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh) return fresh_1;
  hasRequiredFresh = 1;

  /**
   * RegExp to check for no-cache token in Cache-Control.
   * @private
   */

  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;

  /**
   * Module exports.
   * @public
   */

  fresh_1 = fresh;

  /**
   * Check freshness of the response using request and response headers.
   *
   * @param {Object} reqHeaders
   * @param {Object} resHeaders
   * @return {Boolean}
   * @public
   */

  function fresh(reqHeaders, resHeaders) {
    // fields
    var modifiedSince = reqHeaders['if-modified-since'];
    var noneMatch = reqHeaders['if-none-match'];

    // unconditional request
    if (!modifiedSince && !noneMatch) {
      return false;
    }

    // Always return stale when Cache-Control: no-cache
    // to support end-to-end reload requests
    // https://tools.ietf.org/html/rfc2616#section-14.9.4
    var cacheControl = reqHeaders['cache-control'];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }

    // if-none-match
    if (noneMatch && noneMatch !== '*') {
      var etag = resHeaders['etag'];
      if (!etag) {
        return false;
      }
      var etagStale = true;
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
          etagStale = false;
          break;
        }
      }
      if (etagStale) {
        return false;
      }
    }

    // if-modified-since
    if (modifiedSince) {
      var lastModified = resHeaders['last-modified'];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }

  /**
   * Parse an HTTP Date into a number.
   *
   * @param {string} date
   * @private
   */

  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);

    // istanbul ignore next: guard against date.js Date.parse patching
    return typeof timestamp === 'number' ? timestamp : NaN;
  }

  /**
   * Parse a HTTP token list.
   *
   * @param {string} str
   * @private
   */

  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;

    // gather tokens
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 0x20:
          /*   */
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 0x2c:
          /* , */
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }

    // final token
    list.push(str.substring(start, end));
    return list;
  }
  return fresh_1;
}

var freshExports = requireFresh();
var fresh = /*@__PURE__*/getDefaultExportFromCjs(freshExports);

var typeIs$3 = {exports: {}};

var mediaTyper$1 = {};

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper$1;
function requireMediaTyper$1() {
  if (hasRequiredMediaTyper$1) return mediaTyper$1;
  hasRequiredMediaTyper$1 = 1;
  /**
   * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
   *
   * parameter     = token "=" ( token | quoted-string )
   * token         = 1*<any CHAR except CTLs or separators>
   * separators    = "(" | ")" | "<" | ">" | "@"
   *               | "," | ";" | ":" | "\" | <">
   *               | "/" | "[" | "]" | "?" | "="
   *               | "{" | "}" | SP | HT
   * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
   * qdtext        = <any TEXT except <">>
   * quoted-pair   = "\" CHAR
   * CHAR          = <any US-ASCII character (octets 0 - 127)>
   * TEXT          = <any OCTET except CTLs, but including LWS>
   * LWS           = [CRLF] 1*( SP | HT )
   * CRLF          = CR LF
   * CR            = <US-ASCII CR, carriage return (13)>
   * LF            = <US-ASCII LF, linefeed (10)>
   * SP            = <US-ASCII SP, space (32)>
   * SHT           = <US-ASCII HT, horizontal-tab (9)>
   * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
   * OCTET         = <any 8-bit sequence of data>
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

  /**
   * RegExp to match quoted-pair in RFC 2616
   *
   * quoted-pair = "\" CHAR
   * CHAR        = <any US-ASCII character (octets 0 - 127)>
   */
  var qescRegExp = /\\([\u0000-\u007f])/g;

  /**
   * RegExp to match chars that must be quoted-pair in RFC 2616
   */
  var quoteRegExp = /([\\"])/g;

  /**
   * RegExp to match type in RFC 6838
   *
   * type-name = restricted-name
   * subtype-name = restricted-name
   * restricted-name = restricted-name-first *126restricted-name-chars
   * restricted-name-first  = ALPHA / DIGIT
   * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
   *                          "$" / "&" / "-" / "^" / "_"
   * restricted-name-chars =/ "." ; Characters before first dot always
   *                              ; specify a facet name
   * restricted-name-chars =/ "+" ; Characters after last plus always
   *                              ; specify a structured syntax suffix
   * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
   * DIGIT =  %x30-39             ; 0-9
   */
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

  /**
   * Module exports.
   */

  mediaTyper$1.format = format;
  mediaTyper$1.parse = parse;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @api public
   */

  function format(obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError('invalid type');
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError('invalid subtype');
    }

    // format as type/subtype
    var string = type + '/' + subtype;

    // append +suffix
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError('invalid suffix');
      }
      string += '+' + suffix;
    }

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError('invalid parameter name');
        }
        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }
    return string;
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @api public
   */

  function parse(string) {
    if (!string) {
      throw new TypeError('argument string is required');
    }

    // support req/res-like objects as argument
    if (typeof string === 'object') {
      string = getcontenttype(string);
    }
    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string');
    }
    var index = string.indexOf(';');
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }
    obj.parameters = params;
    return obj;
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @api private
   */

  function getcontenttype(obj) {
    if (typeof obj.getHeader === 'function') {
      // res-like
      return obj.getHeader('content-type');
    }
    if (typeof obj.headers === 'object') {
      // req-like
      return obj.headers && obj.headers['content-type'];
    }
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @api private
   */

  function qstring(val) {
    var str = String(val);

    // no need to quote tokens
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(quoteRegExp, '\\$1') + '"';
  }

  /**
   * Simply "type/subtype+siffx" into parts.
   *
   * @param {string} string
   * @return {Object}
   * @api private
   */

  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError('invalid media type');
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;

    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type: type,
      subtype: subtype,
      suffix: suffix
    };
    return obj;
  }
  return mediaTyper$1;
}

var mimeTypes$1 = {};

var require$$0$4 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb$1;
var hasRequiredMimeDb$1;
function requireMimeDb$1() {
  if (hasRequiredMimeDb$1) return mimeDb$1;
  hasRequiredMimeDb$1 = 1;
  /**
   * Module exports.
   */

  mimeDb$1 = require$$0$4;
  return mimeDb$1;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes$1;
function requireMimeTypes$1() {
  if (hasRequiredMimeTypes$1) return mimeTypes$1;
  hasRequiredMimeTypes$1 = 1;
  (function (exports) {

    /**
     * Module dependencies.
     * @private
     */
    var db = requireMimeDb$1();
    var extname = require$$0$a.extname;

    /**
     * Module variables.
     * @private
     */

    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;

    /**
     * Module exports.
     * @public
     */

    exports.charset = charset;
    exports.charsets = {
      lookup: charset
    };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);

    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types);

    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }

      // default text/* to utf-8
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
      }
      return false;
    }

    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */

    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false;
      }
      var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }

      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
      }
      return mime;
    }

    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      var match = EXTRACT_TYPE_REGEXP.exec(type);

      // get extensions
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }

    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */

    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false;
      }

      // get the extension ("ext" or ".ext" or full path)
      var extension = extname('x.' + path).toLowerCase().substr(1);
      if (!extension) {
        return false;
      }
      return exports.types[extension] || false;
    }

    /**
     * Populate the extensions and types maps.
     * @private
     */

    function populateMaps(extensions, types) {
      // source preference (least -> most)
      var preference = ['nginx', 'apache', undefined, 'iana'];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }

        // mime -> extensions
        extensions[type] = exts;

        // extension -> mime
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i];
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
              // skip the remapping
              continue;
            }
          }

          // set the extension -> mime
          types[extension] = type;
        }
      });
    }
  })(mimeTypes$1);
  return mimeTypes$1;
}

/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs$1;
function requireTypeIs$1() {
  if (hasRequiredTypeIs$1) return typeIs$3.exports;
  hasRequiredTypeIs$1 = 1;

  /**
   * Module dependencies.
   * @private
   */

  var typer = requireMediaTyper$1();
  var mime = requireMimeTypes$1();

  /**
   * Module exports.
   * @public
   */

  typeIs$3.exports = typeofrequest;
  typeIs$3.exports.is = typeis;
  typeIs$3.exports.hasBody = hasbody;
  typeIs$3.exports.normalize = normalize;
  typeIs$3.exports.match = mimeMatch;

  /**
   * Compare a `value` content-type with `types`.
   * Each `type` can be an extension like `html`,
   * a special shortcut like `multipart` or `urlencoded`,
   * or a mime type.
   *
   * If no types match, `false` is returned.
   * Otherwise, the first `type` that matches is returned.
   *
   * @param {String} value
   * @param {Array} types
   * @public
   */

  function typeis(value, types_) {
    var i;
    var types = types_;

    // remove parameters and normalize
    var val = tryNormalizeType(value);

    // no type or invalid
    if (!val) {
      return false;
    }

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // no types, return the content type
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0; i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
      }
    }

    // no matches
    return false;
  }

  /**
   * Check if a request has a request body.
   * A request with a body __must__ either have `transfer-encoding`
   * or `content-length` headers set.
   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
   *
   * @param {Object} request
   * @return {Boolean}
   * @public
   */

  function hasbody(req) {
    return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
  }

  /**
   * Check if the incoming request contains the "Content-Type"
   * header field, and it contains any of the give mime `type`s.
   * If there is no request body, `null` is returned.
   * If there is no content type, `false` is returned.
   * Otherwise, it returns the first `type` that matches.
   *
   * Examples:
   *
   *     // With Content-Type: text/html; charset=utf-8
   *     this.is('html'); // => 'html'
   *     this.is('text/html'); // => 'text/html'
   *     this.is('text/*', 'application/json'); // => 'text/html'
   *
   *     // When Content-Type is application/json
   *     this.is('json', 'urlencoded'); // => 'json'
   *     this.is('application/json'); // => 'application/json'
   *     this.is('html', 'application/*'); // => 'application/json'
   *
   *     this.is('html'); // => false
   *
   * @param {String|Array} types...
   * @return {String|false|null}
   * @public
   */

  function typeofrequest(req, types_) {
    var types = types_;

    // no body
    if (!hasbody(req)) {
      return null;
    }

    // support flattened arguments
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // request content type
    var value = req.headers['content-type'];
    return typeis(value, types);
  }

  /**
   * Normalize a mime type.
   * If it's a shorthand, expand it to a valid mime type.
   *
   * In general, you probably want:
   *
   *   var type = is(req, ['urlencoded', 'json', 'multipart']);
   *
   * Then use the appropriate body parsers.
   * These three are the most common request body types
   * and are thus ensured to work.
   *
   * @param {String} type
   * @private
   */

  function normalize(type) {
    if (typeof type !== 'string') {
      // invalid type
      return false;
    }
    switch (type) {
      case 'urlencoded':
        return 'application/x-www-form-urlencoded';
      case 'multipart':
        return 'multipart/*';
    }
    if (type[0] === '+') {
      // "+json" -> "*/*+json" expando
      return '*/*' + type;
    }
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if `expected` mime type
   * matches `actual` mime type with
   * wildcard and +suffix support.
   *
   * @param {String} expected
   * @param {String} actual
   * @return {Boolean}
   * @private
   */

  function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false) {
      return false;
    }

    // split types
    var actualParts = actual.split('/');
    var expectedParts = expected.split('/');

    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }

    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
      return false;
    }

    // validate suffix wildcard
    if (expectedParts[1].substr(0, 2) === '*+') {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }

    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }

  /**
   * Normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function normalizeType(value) {
    // parse the type
    var type = typer.parse(value);

    // remove the parameters
    type.parameters = undefined;

    // reformat it
    return typer.format(type);
  }

  /**
   * Try to normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
  return typeIs$3.exports;
}

var typeIsExports$1 = requireTypeIs$1();
var typeIs$2 = /*@__PURE__*/getDefaultExportFromCjs(typeIsExports$1);

var negotiator$1 = {exports: {}};

var charset$1 = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredCharset$1;
function requireCharset$1() {
  if (hasRequiredCharset$1) return charset$1.exports;
  hasRequiredCharset$1 = 1;

  /**
   * Module exports.
   * @public
   */

  charset$1.exports = preferredCharsets;
  charset$1.exports.preferredCharsets = preferredCharsets;

  /**
   * Module variables.
   * @private
   */

  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Charset header.
   * @private
   */

  function parseAcceptCharset(accept) {
    var accepts = accept.split(',');
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a charset from the Accept-Charset header.
   * @private
   */

  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of a charset.
   * @private
   */

  function getCharsetPriority(charset, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the charset.
   * @private
   */

  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred charsets from an Accept-Charset header.
   * @public
   */

  function preferredCharsets(accept, provided) {
    // RFC 2616 sec 14.2: no header = *
    var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    if (!provided) {
      // sorted list of all charsets
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });

    // sorted list of accepted charsets
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full charset string.
   * @private
   */

  function getFullCharset(spec) {
    return spec.charset;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset$1.exports;
}

var encoding$1 = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredEncoding$1;
function requireEncoding$1() {
  if (hasRequiredEncoding$1) return encoding$1.exports;
  hasRequiredEncoding$1 = 1;

  /**
   * Module exports.
   * @public
   */

  encoding$1.exports = preferredEncodings;
  encoding$1.exports.preferredEncodings = preferredEncodings;

  /**
   * Module variables.
   * @private
   */

  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Encoding header.
   * @private
   */

  function parseAcceptEncoding(accept) {
    var accepts = accept.split(',');
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify('identity', encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      /*
       * If identity doesn't explicitly appear in the accept-encoding header,
       * it's added to the list of acceptable encoding with the lowest q
       */
      accepts[j++] = {
        encoding: 'identity',
        q: minQuality,
        i: i
      };
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse an encoding from the Accept-Encoding header.
   * @private
   */

  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of an encoding.
   * @private
   */

  function getEncodingPriority(encoding, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the encoding.
   * @private
   */

  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred encodings from an Accept-Encoding header.
   * @public
   */

  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || '');
    if (!provided) {
      // sorted list of all encodings
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });

    // sorted list of accepted encodings
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full encoding string.
   * @private
   */

  function getFullEncoding(spec) {
    return spec.encoding;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding$1.exports;
}

var language$1 = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredLanguage$1;
function requireLanguage$1() {
  if (hasRequiredLanguage$1) return language$1.exports;
  hasRequiredLanguage$1 = 1;

  /**
   * Module exports.
   * @public
   */

  language$1.exports = preferredLanguages;
  language$1.exports.preferredLanguages = preferredLanguages;

  /**
   * Module variables.
   * @private
   */

  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Language header.
   * @private
   */

  function parseAcceptLanguage(accept) {
    var accepts = accept.split(',');
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j++] = language;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a language from the Accept-Language header.
   * @private
   */

  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split('=');
        if (p[0] === 'q') q = parseFloat(p[1]);
      }
    }
    return {
      prefix: prefix,
      suffix: suffix,
      q: q,
      i: i,
      full: full
    };
  }

  /**
   * Get the priority of a language.
   * @private
   */

  function getLanguagePriority(language, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the language.
   * @private
   */

  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred languages from an Accept-Language header.
   * @public
   */

  function preferredLanguages(accept, provided) {
    // RFC 2616 sec 14.4: no header = *
    var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    if (!provided) {
      // sorted list of all languages
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });

    // sorted list of accepted languages
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full language string.
   * @private
   */

  function getFullLanguage(spec) {
    return spec.full;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return language$1.exports;
}

var mediaType$1 = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaType$1;
function requireMediaType$1() {
  if (hasRequiredMediaType$1) return mediaType$1.exports;
  hasRequiredMediaType$1 = 1;

  /**
   * Module exports.
   * @public
   */

  mediaType$1.exports = preferredMediaTypes;
  mediaType$1.exports.preferredMediaTypes = preferredMediaTypes;

  /**
   * Module variables.
   * @private
   */

  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept header.
   * @private
   */

  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a media type from the Accept header.
   * @private
   */

  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];

        // get the value, unwrapping quotes
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === 'q') {
          q = parseFloat(value);
          break;
        }

        // store parameter
        params[key] = value;
      }
    }
    return {
      type: type,
      subtype: subtype,
      params: params,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of a media type.
   * @private
   */

  function getMediaTypePriority(type, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the media type.
   * @private
   */

  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != '*') {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != '*') {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function (k) {
        return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred media types from an Accept header.
   * @public
   */

  function preferredMediaTypes(accept, provided) {
    // RFC 2616 sec 14.2: no header = */*
    var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    if (!provided) {
      // sorted list of all types
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });

    // sorted list of accepted types
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full type string.
   * @private
   */

  function getFullType(spec) {
    return spec.type + '/' + spec.subtype;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }

  /**
   * Count the number of quotes in a string.
   * @private
   */

  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }

  /**
   * Split a key value pair.
   * @private
   */

  function splitKeyValuePair(str) {
    var index = str.indexOf('=');
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }

  /**
   * Split an Accept header into media types.
   * @private
   */

  function splitMediaTypes(accept) {
    var accepts = accept.split(',');
    for (var i = 1, j = 0; i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += ',' + accepts[i];
      }
    }

    // trim accepts
    accepts.length = j + 1;
    return accepts;
  }

  /**
   * Split a string of parameters.
   * @private
   */

  function splitParameters(str) {
    var parameters = str.split(';');
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ';' + parameters[i];
      }
    }

    // trim parameters
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType$1.exports;
}

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator$1;
function requireNegotiator$1() {
  if (hasRequiredNegotiator$1) return negotiator$1.exports;
  hasRequiredNegotiator$1 = 1;
  var preferredCharsets = requireCharset$1();
  var preferredEncodings = requireEncoding$1();
  var preferredLanguages = requireLanguage$1();
  var preferredMediaTypes = requireMediaType$1();

  /**
   * Module exports.
   * @public
   */

  negotiator$1.exports = Negotiator;
  negotiator$1.exports.Negotiator = Negotiator;

  /**
   * Create a Negotiator instance from a request.
   * @param {object} request
   * @public
   */

  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers['accept-charset'], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers['accept-encoding'], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers['accept-language'], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };

  // Backwards compatibility
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator$1.exports;
}

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts$3;
var hasRequiredAccepts$1;
function requireAccepts$1() {
  if (hasRequiredAccepts$1) return accepts$3;
  hasRequiredAccepts$1 = 1;

  /**
   * Module dependencies.
   * @private
   */

  var Negotiator = requireNegotiator$1();
  var mime = requireMimeTypes$1();

  /**
   * Module exports.
   * @public
   */

  accepts$3 = Accepts;

  /**
   * Create a new Accepts object for the given req.
   *
   * @param {object} req
   * @public
   */

  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }

  /**
   * Check if the given `type(s)` is acceptable, returning
   * the best match when true, otherwise `undefined`, in which
   * case you should respond with 406 "Not Acceptable".
   *
   * The `type` value may be a single mime type string
   * such as "application/json", the extension name
   * such as "json" or an array `["json", "html", "text/plain"]`. When a list
   * or array is given the _best_ match, if any is returned.
   *
   * Examples:
   *
   *     // Accept: text/html
   *     this.types('html');
   *     // => "html"
   *
   *     // Accept: text/*, application/json
   *     this.types('html');
   *     // => "html"
   *     this.types('text/html');
   *     // => "text/html"
   *     this.types('json', 'text');
   *     // => "json"
   *     this.types('application/json');
   *     // => "application/json"
   *
   *     // Accept: text/*, application/json
   *     this.types('image/png');
   *     this.types('png');
   *     // => undefined
   *
   *     // Accept: text/*;q=.5, application/json
   *     this.types(['html', 'json']);
   *     this.types('html', 'json');
   *     // => "json"
   *
   * @param {String|Array} types...
   * @return {String|Array|Boolean}
   * @public
   */

  Accepts.prototype.type = Accepts.prototype.types = function (types_) {
    var types = types_;

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i];
      }
    }

    // no types, return all requested types
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }

    // no accept header, return first given type
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
  };

  /**
   * Return accepted encodings or best fit based on `encodings`.
   *
   * Given `Accept-Encoding: gzip, deflate`
   * an array sorted by quality is returned:
   *
   *     ['gzip', 'deflate']
   *
   * @param {String|Array} encodings...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
    var encodings = encodings_;

    // support flattened arguments
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0; i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }

    // no encodings, return all requested encodings
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };

  /**
   * Return accepted charsets or best fit based on `charsets`.
   *
   * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
   * an array sorted by quality is returned:
   *
   *     ['utf-8', 'utf-7', 'iso-8859-1']
   *
   * @param {String|Array} charsets...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
    var charsets = charsets_;

    // support flattened arguments
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }

    // no charsets, return all requested charsets
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };

  /**
   * Return accepted languages or best fit based on `langs`.
   *
   * Given `Accept-Language: en;q=0.8, es, pt`
   * an array sorted by quality is returned:
   *
   *     ['es', 'pt', 'en']
   *
   * @param {String|Array} langs...
   * @return {Array|String}
   * @public
   */

  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
    var languages = languages_;

    // support flattened arguments
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }

    // no languages, return all requested languages
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };

  /**
   * Convert extnames to mime.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function extToMime(type) {
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if mime is valid.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function validMime(type) {
    return typeof type === 'string';
  }
  return accepts$3;
}

var acceptsExports$1 = requireAccepts$1();
var accepts$2 = /*@__PURE__*/getDefaultExportFromCjs(acceptsExports$1);

/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
  if (hasRequiredRangeParser) return rangeParser_1;
  hasRequiredRangeParser = 1;

  /**
   * Module exports.
   * @public
   */

  rangeParser_1 = rangeParser;

  /**
   * Parse "Range" header `str` relative to the given file `size`.
   *
   * @param {Number} size
   * @param {String} str
   * @param {Object} [options]
   * @return {Array}
   * @public
   */

  function rangeParser(size, str, options) {
    if (typeof str !== 'string') {
      throw new TypeError('argument str must be a string');
    }
    var index = str.indexOf('=');
    if (index === -1) {
      return -2;
    }

    // split the range string
    var arr = str.slice(index + 1).split(',');
    var ranges = [];

    // add ranges type
    ranges.type = str.slice(0, index);

    // parse all ranges
    for (var i = 0; i < arr.length; i++) {
      var range = arr[i].split('-');
      var start = parseInt(range[0], 10);
      var end = parseInt(range[1], 10);

      // -nnn
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
        // nnn-
      } else if (isNaN(end)) {
        end = size - 1;
      }

      // limit last-byte-pos to current length
      if (end > size - 1) {
        end = size - 1;
      }

      // invalid or unsatisifiable
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }

      // add range
      ranges.push({
        start: start,
        end: end
      });
    }
    if (ranges.length < 1) {
      // unsatisifiable
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }

  /**
   * Combine overlapping & adjacent ranges.
   * @private
   */

  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range = ordered[i];
      var current = ordered[j];
      if (range.start > current.end + 1) {
        // next range
        ordered[++j] = range;
      } else if (range.end > current.end) {
        // extend range
        current.end = range.end;
        current.index = Math.min(current.index, range.index);
      }
    }

    // trim ordered array
    ordered.length = j + 1;

    // generate combined range
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);

    // copy ranges type
    combined.type = ranges.type;
    return combined;
  }

  /**
   * Map function to add index value to ranges.
   * @private
   */

  function mapWithIndex(range, index) {
    return {
      start: range.start,
      end: range.end,
      index: index
    };
  }

  /**
   * Map function to remove index value from ranges.
   * @private
   */

  function mapWithoutIndex(range) {
    return {
      start: range.start,
      end: range.end
    };
  }

  /**
   * Sort function to sort ranges by index.
   * @private
   */

  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }

  /**
   * Sort function to sort ranges by start position.
   * @private
   */

  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
  return rangeParser_1;
}

var rangeParserExports = requireRangeParser();
var rangeParser = /*@__PURE__*/getDefaultExportFromCjs(rangeParserExports);

var httpErrors$1 = {exports: {}};

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var depd_1$1;
var hasRequiredDepd$1;
function requireDepd$1() {
  if (hasRequiredDepd$1) return depd_1$1;
  hasRequiredDepd$1 = 1;
  /**
   * Module dependencies.
   */

  var relative = require$$0$a.relative;

  /**
   * Module exports.
   */

  depd_1$1 = depd;

  /**
   * Get the path to base files on.
   */

  var basePath = process.cwd();

  /**
   * Determine if namespace is contained in the string.
   */

  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0; i < vals.length; i++) {
      var val = vals[i];

      // namespace contained
      if (val && (val === '*' || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Convert a data descriptor to accessor descriptor.
   */

  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }

  /**
   * Create arguments string to keep arity.
   */

  function createArgumentsString(arity) {
    var str = '';
    for (var i = 0; i < arity; i++) {
      str += ', arg' + i;
    }
    return str.substr(2);
  }

  /**
   * Create stack string from stack.
   */

  function createStackString(stack) {
    var str = this.name + ': ' + this.namespace;
    if (this.message) {
      str += ' deprecated ' + this.message;
    }
    for (var i = 0; i < stack.length; i++) {
      str += '\n    at ' + stack[i].toString();
    }
    return str;
  }

  /**
   * Create deprecate for namespace in caller.
   */

  function depd(namespace) {
    if (!namespace) {
      throw new TypeError('argument namespace is required');
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
      // call to self as log
      log.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }

  /**
   * Determine if event emitter has listeners of a given type.
   *
   * The way to do this check is done three different ways in Node.js >= 0.8
   * so this consolidates them into a minimal set using instance methods.
   *
   * @param {EventEmitter} emitter
   * @param {string} type
   * @returns {boolean}
   * @private
   */

  function eehaslisteners(emitter, type) {
    var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }

  /**
   * Determine if namespace is ignored.
   */

  function isignored(namespace) {
    if (process.noDeprecation) {
      // --no-deprecation support
      return true;
    }
    var str = process.env.NO_DEPRECATION || '';

    // namespace ignored
    return containsNamespace(str, namespace);
  }

  /**
   * Determine if namespace is traced.
   */

  function istraced(namespace) {
    if (process.traceDeprecation) {
      // --trace-deprecation support
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || '';

    // namespace traced
    return containsNamespace(str, namespace);
  }

  /**
   * Display deprecation message.
   */

  function log(message, site) {
    var haslisteners = eehaslisteners(process, 'deprecation');

    // abort early if no destination
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
      // provided site
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      // get call site
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }

    // get caller of deprecated thing in relation to file
    for (; i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;
    if (key !== undefined && key in this._warned) {
      // already warned
      return;
    }
    this._warned[key] = true;

    // generate automatic message from call site
    var msg = message;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }

    // emit deprecation if listeners exist
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit('deprecation', err);
      return;
    }

    // format and write message
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + '\n', 'utf8');
  }

  /**
   * Get call site location as array.
   */

  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || '<anonymous>';
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ', ' + file;
    }
    var site = [file, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }

  /**
   * Generate a default message from the site.
   */

  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;

    // make useful anonymous name
    if (!funcName) {
      funcName = '<anonymous@' + formatLocation(site) + '>';
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();

    // ignore useless type name
    if (typeName === 'Object') {
      typeName = undefined;
    }

    // make useful type name
    if (typeName === 'Function') {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
  }

  /**
   * Format deprecation message without color.
   */

  function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;

    // add stack trace
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    at ' + stack[i].toString();
      }
      return formatted;
    }
    if (caller) {
      formatted += ' at ' + formatLocation(caller);
    }
    return formatted;
  }

  /**
   * Format deprecation message with color.
   */

  function formatColor(msg, caller, stack) {
    var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' +
    // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' +
    // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m'; // reset

    // add stack trace
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
      }
      return formatted;
    }
    if (caller) {
      formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
    }
    return formatted;
  }

  /**
   * Format call site location.
   */

  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
  }

  /**
   * Get the stack as array of call sites.
   */

  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);

    // capture the stack
    Error.captureStackTrace(obj);

    // slice this function off the top
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
  }

  /**
   * Capture call site stack from v8.
   */

  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }

  /**
   * Return a wrapped function in a deprecation message.
   */

  function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
      throw new TypeError('argument fn must be a function');
    }
    var args = createArgumentsString(fn.length);
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;

    // eslint-disable-next-line no-new-func
    var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\n' + 'return function (' + args + ') {' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '}')(fn, log, this, message, site);
    return deprecatedfn;
  }

  /**
   * Wrap property in a deprecation message.
   */

  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
      throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
      throw new TypeError('property must be configurable');
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);

    // set site name
    site.name = prop;

    // convert data descriptor
    if ('value' in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop);
    }
    var get = descriptor.get;
    var set = descriptor.set;

    // wrap getter
    if (typeof get === 'function') {
      descriptor.get = function getter() {
        log.call(deprecate, message, site);
        return get.apply(this, arguments);
      };
    }

    // wrap setter
    if (typeof set === 'function') {
      descriptor.set = function setter() {
        log.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }

  /**
   * Create DeprecationError for deprecation
   */

  function DeprecationError(namespace, message, stack) {
    var error = new Error();
    var stackString;
    Object.defineProperty(error, 'constructor', {
      value: DeprecationError
    });
    Object.defineProperty(error, 'message', {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true
    });
    Object.defineProperty(error, 'name', {
      enumerable: false,
      configurable: true,
      value: 'DeprecationError',
      writable: true
    });
    Object.defineProperty(error, 'namespace', {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error, 'stack', {
      configurable: true,
      enumerable: false,
      get: function () {
        if (stackString !== undefined) {
          return stackString;
        }

        // prepare stack trace
        return stackString = createStackString.call(this, stack);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error;
  }
  return depd_1$1;
}

var setprototypeof$1;
var hasRequiredSetprototypeof$1;
function requireSetprototypeof$1() {
  if (hasRequiredSetprototypeof$1) return setprototypeof$1;
  hasRequiredSetprototypeof$1 = 1;
  /* eslint no-proto: 0 */
  setprototypeof$1 = Object.setPrototypeOf || ({
    __proto__: []
  } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
  return setprototypeof$1;
}

var inherits$1 = {exports: {}};

var inherits_browser$1 = {exports: {}};

var hasRequiredInherits_browser$1;
function requireInherits_browser$1() {
  if (hasRequiredInherits_browser$1) return inherits_browser$1.exports;
  hasRequiredInherits_browser$1 = 1;
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$1.exports;
}

var hasRequiredInherits$1;
function requireInherits$1() {
  if (hasRequiredInherits$1) return inherits$1.exports;
  hasRequiredInherits$1 = 1;
  try {
    var util = require('util');
    /* istanbul ignore next */
    if (typeof util.inherits !== 'function') throw '';
    inherits$1.exports = util.inherits;
  } catch (e) {
    /* istanbul ignore next */
    inherits$1.exports = requireInherits_browser$1();
  }
  return inherits$1.exports;
}

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier$1;
var hasRequiredToidentifier$1;
function requireToidentifier$1() {
  if (hasRequiredToidentifier$1) return toidentifier$1;
  hasRequiredToidentifier$1 = 1;

  /**
   * Module exports.
   * @public
   */

  toidentifier$1 = toIdentifier;

  /**
   * Trasform the given string into a JavaScript identifier
   *
   * @param {string} str
   * @returns {string}
   * @public
   */

  function toIdentifier(str) {
    return str.split(' ').map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
  }
  return toidentifier$1;
}

/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors$1;
function requireHttpErrors$1() {
  if (hasRequiredHttpErrors$1) return httpErrors$1.exports;
  hasRequiredHttpErrors$1 = 1;
  (function (module) {

    /**
     * Module dependencies.
     * @private
     */
    var deprecate = requireDepd$1()('http-errors');
    var setPrototypeOf = requireSetprototypeof$1();
    var statuses = requireStatuses$1();
    var inherits = requireInherits$1();
    var toIdentifier = requireToidentifier$1();

    /**
     * Module exports.
     * @public
     */

    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);

    // Populate exports for all constructors
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

    /**
     * Get the code class of a status code.
     * @private
     */

    function codeClass(status) {
      return Number(String(status).charAt(0) + '00');
    }

    /**
     * Create a new HTTP Error.
     *
     * @returns {Error}
     * @public
     */

    function createError() {
      // so much arity going on ~_~
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === 'object' && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === 'number' && i === 0) {
          status = arg;
        } else if (type === 'string') {
          msg = arg;
        } else if (type === 'object') {
          props = arg;
        } else {
          throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
        }
      }
      if (typeof status === 'number' && (status < 400 || status >= 600)) {
        deprecate('non-error status code; use only 4xx or 5xx status codes');
      }
      if (typeof status !== 'number' || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }

      // constructor
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        // create error
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        // add properties to generic error
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== 'status' && key !== 'statusCode') {
          err[key] = props[key];
        }
      }
      return err;
    }

    /**
     * Create HTTP error abstract base class.
     * @private
     */

    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError('cannot construct abstract class');
      }
      inherits(HttpError, Error);
      return HttpError;
    }

    /**
     * Create a constructor for a client error.
     * @private
     */

    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);

        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ClientError);

        // adjust the [[Prototype]]
        setPrototypeOf(err, ClientError.prototype);

        // redefine the error message
        Object.defineProperty(err, 'message', {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });

        // redefine the error name
        Object.defineProperty(err, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }

    /**
     * Create function to test is a value is a HttpError.
     * @private
     */

    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== 'object') {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === 'boolean' && typeof val.statusCode === 'number' && val.status === val.statusCode;
      };
    }

    /**
     * Create a constructor for a server error.
     * @private
     */

    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);

        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ServerError);

        // adjust the [[Prototype]]
        setPrototypeOf(err, ServerError.prototype);

        // redefine the error message
        Object.defineProperty(err, 'message', {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });

        // redefine the error name
        Object.defineProperty(err, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }

    /**
     * Set the name of a function, if possible.
     * @private
     */

    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, 'name');
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, 'name', desc);
      }
    }

    /**
     * Populate the exports object with constructors for every error class.
     * @private
     */

    function populateConstructorExports(exports, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          // export the constructor
          exports[code] = CodeError;
          exports[name] = CodeError;
        }
      });
    }

    /**
     * Get a class name from a name identifier.
     * @private
     */

    function toClassName(name) {
      return name.substr(-5) !== 'Error' ? name + 'Error' : name;
    }
  })(httpErrors$1);
  return httpErrors$1.exports;
}

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
  return ms;
}

var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    });

    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];

    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */
    createDebug.formatters = {};

    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;

    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        // Disabled?
        if (!debug.enabled) {
          return;
        }
        const self = debug;

        // Set `diff` timestamp
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        }

        // Apply any `formatters` transformations
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            const val = args[index];
            match = formatter.call(self, val);

            // Now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // Apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: v => {
          enableOverride = v;
        }
      });

      // Env-specific initialization logic for debug instances
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
      for (const ns of split) {
        if (ns[0] === '-') {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }

    /**
     * Checks if the given string matches a namespace template, honoring
     * asterisks as wildcards.
     *
     * @param {String} search
     * @param {String} template
     * @return {Boolean}
     */
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
          // Match character or proceed with wildcard
          if (template[templateIndex] === '*') {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++; // Skip the '*'
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          // eslint-disable-line no-negated-condition
          // Backtrack to the last '*' and try to match more characters
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false; // No match
        }
      }

      // Handle trailing '*' in template
      while (templateIndex < template.length && template[templateIndex] === '*') {
        templateIndex++;
      }
      return templateIndex === template.length;
    }

    /**
    * Disable debug output.
    *
    * @return {String} namespaces
    * @api public
    */
    function disable() {
      const namespaces = [...createDebug.names, ...createDebug.skips.map(namespace => '-' + namespace)].join(',');
      createDebug.enable('');
      return namespaces;
    }

    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }

    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }

    /**
    * XXX DO NOT USE. This is a temporary stub function.
    * XXX It WILL be removed in the next major release.
    */
    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}

/* eslint-env browser */
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    })();

    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      // eslint-disable-next-line no-return-assign
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
      // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, match => {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || (() => {});

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      let r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    module.exports = requireCommon()(exports);
    const {
      formatters
    } = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$c;
  const tty = require$$0$7;
  const hasFlag = requireHasFlag();
  const {
    env
  } = process;
  let forceColor;
  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
  }
  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
      return min;
    }
    if (process.platform === 'win32') {
      // Windows 10 build 10586 is the first Windows release that supports 256 colors.
      // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
      const osRelease = os.release().split('.');
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ('CI' in env) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
        return 1;
      }
      return min;
    }
    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
      return 3;
    }
    if ('TERM_PROGRAM' in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;
        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ('COLORTERM' in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}

/**
 * Module dependencies.
 */
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function (module, exports) {
    const tty = require$$0$7;
    const util = require$$1$2;

    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(key => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      // Camel-case
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });

      // Coerce string value into JS value
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      const {
        namespace: name,
        useColors
      } = this;
      if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return new Date().toISOString() + ' ';
    }

    /**
     * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const {
      formatters
    } = module.exports;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(str => str.trim()).join(' ');
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}

/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;

  /**
   * Module dependencies.
   * @private
   */

  var EventEmitter = require$$1$3.EventEmitter;
  var ReadStream = require$$3$2.ReadStream;
  var Stream = require$$1$4;
  var Zlib = require$$3$4;

  /**
   * Module exports.
   * @public
   */

  destroy_1 = destroy;

  /**
   * Destroy the given stream, and optionally suppress any future `error` events.
   *
   * @param {object} stream
   * @param {boolean} suppress
   * @public
   */

  function destroy(stream, suppress) {
    if (isFsReadStream(stream)) {
      destroyReadStream(stream);
    } else if (isZlibStream(stream)) {
      destroyZlibStream(stream);
    } else if (hasDestroy(stream)) {
      stream.destroy();
    }
    if (isEventEmitter(stream) && suppress) {
      stream.removeAllListeners('error');
      stream.addListener('error', noop);
    }
    return stream;
  }

  /**
   * Destroy a ReadStream.
   *
   * @param {object} stream
   * @private
   */

  function destroyReadStream(stream) {
    stream.destroy();
    if (typeof stream.close === 'function') {
      // node.js core bug work-around
      stream.on('open', onOpenClose);
    }
  }

  /**
   * Close a Zlib stream.
   *
   * Zlib streams below Node.js 4.5.5 have a buggy implementation
   * of .close() when zlib encountered an error.
   *
   * @param {object} stream
   * @private
   */

  function closeZlibStream(stream) {
    if (stream._hadError === true) {
      var prop = stream._binding === null ? '_binding' : '_handle';
      stream[prop] = {
        close: function () {
          this[prop] = null;
        }
      };
    }
    stream.close();
  }

  /**
   * Destroy a Zlib stream.
   *
   * Zlib streams don't have a destroy function in Node.js 6. On top of that
   * simply calling destroy on a zlib stream in Node.js 8+ will result in a
   * memory leak. So until that is fixed, we need to call both close AND destroy.
   *
   * PR to fix memory leak: https://github.com/nodejs/node/pull/23734
   *
   * In Node.js 6+8, it's important that destroy is called before close as the
   * stream would otherwise emit the error 'zlib binding closed'.
   *
   * @param {object} stream
   * @private
   */

  function destroyZlibStream(stream) {
    if (typeof stream.destroy === 'function') {
      // node.js core bug work-around
      // istanbul ignore if: node.js 0.8
      if (stream._binding) {
        // node.js < 0.10.0
        stream.destroy();
        if (stream._processing) {
          stream._needDrain = true;
          stream.once('drain', onDrainClearBinding);
        } else {
          stream._binding.clear();
        }
      } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
        // node.js >= 12, ^11.1.0, ^10.15.1
        stream.destroy();
      } else if (stream._destroy && typeof stream.close === 'function') {
        // node.js 7, 8
        stream.destroyed = true;
        stream.close();
      } else {
        // fallback
        // istanbul ignore next
        stream.destroy();
      }
    } else if (typeof stream.close === 'function') {
      // node.js < 8 fallback
      closeZlibStream(stream);
    }
  }

  /**
   * Determine if stream has destroy.
   * @private
   */

  function hasDestroy(stream) {
    return stream instanceof Stream && typeof stream.destroy === 'function';
  }

  /**
   * Determine if val is EventEmitter.
   * @private
   */

  function isEventEmitter(val) {
    return val instanceof EventEmitter;
  }

  /**
   * Determine if stream is fs.ReadStream stream.
   * @private
   */

  function isFsReadStream(stream) {
    return stream instanceof ReadStream;
  }

  /**
   * Determine if stream is Zlib stream.
   * @private
   */

  function isZlibStream(stream) {
    return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
  }

  /**
   * No-op function.
   * @private
   */

  function noop() {}

  /**
   * On drain handler to clear binding.
   * @private
   */

  // istanbul ignore next: node.js 0.8
  function onDrainClearBinding() {
    this._binding.clear();
  }

  /**
   * On open handler to close stream.
   * @private
   */

  function onOpenClose() {
    if (typeof this.fd === 'number') {
      // actually close down the fd
      this.close();
    }
  }
  return destroy_1;
}

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl) return encodeurl;
  hasRequiredEncodeurl = 1;

  /**
   * Module exports.
   * @public
   */

  encodeurl = encodeUrl;

  /**
   * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
   * and including invalid escape sequences.
   * @private
   */

  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

  /**
   * RegExp to match unmatched surrogate pair.
   * @private
   */

  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

  /**
   * String to replace unmatched surrogate pair with.
   * @private
   */

  var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

  /**
   * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
   *
   * This function will take an already-encoded URL and encode all the non-URL
   * code points. This function will not encode the "%" character unless it is
   * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
   * be encoded as `%25foo`).
   *
   * This encode is meant to be "safe" and does not throw errors. It will try as
   * hard as it can to properly encode the given URL, including replacing any raw,
   * unpaired surrogate pairs with the Unicode replacement character prior to
   * encoding.
   *
   * @param {string} url
   * @return {string}
   * @public
   */

  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl;
}

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;

  /**
   * Module variables.
   * @private
   */

  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Module exports.
   * @public
   */

  escapeHtml_1 = escapeHtml;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#39;';
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  return escapeHtml_1;
}

/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag) return etag_1;
  hasRequiredEtag = 1;

  /**
   * Module exports.
   * @public
   */

  etag_1 = etag;

  /**
   * Module dependencies.
   * @private
   */

  var crypto = require$$0$b;
  var Stats = require$$3$2.Stats;

  /**
   * Module variables.
   * @private
   */

  var toString = Object.prototype.toString;

  /**
   * Generate an entity tag.
   *
   * @param {Buffer|string} entity
   * @return {string}
   * @private
   */

  function entitytag(entity) {
    if (entity.length === 0) {
      // fast-path empty
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }

    // compute hash of entity
    var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);

    // compute length of entity
    var len = typeof entity === 'string' ? Buffer.byteLength(entity, 'utf8') : entity.length;
    return '"' + len.toString(16) + '-' + hash + '"';
  }

  /**
   * Create a simple ETag.
   *
   * @param {string|Buffer|Stats} entity
   * @param {object} [options]
   * @param {boolean} [options.weak]
   * @return {String}
   * @public
   */

  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError('argument entity is required');
    }

    // support fs.Stats object
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats;

    // validate argument
    if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
      throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
    }

    // generate entity tag
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? 'W/' + tag : tag;
  }

  /**
   * Determine if object is a Stats object.
   *
   * @param {object} obj
   * @return {boolean}
   * @api private
   */

  function isstats(obj) {
    // genuine fs.Stats
    if (typeof Stats === 'function' && obj instanceof Stats) {
      return true;
    }

    // quack quack
    return obj && typeof obj === 'object' && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]' && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';
  }

  /**
   * Generate a tag for a stat.
   *
   * @param {object} stat
   * @return {string}
   * @private
   */

  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + '-' + mtime + '"';
  }
  return etag_1;
}

var onFinished$1 = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst) return eeFirst;
  hasRequiredEeFirst = 1;

  /**
   * Module exports.
   * @public
   */

  eeFirst = first;

  /**
   * Get the first event in a set of event emitters and event pairs.
   *
   * @param {array} stuff
   * @param {function} done
   * @public
   */

  function first(stuff, done) {
    if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);

        // listen to the event
        ee.on(event, fn);
        // push this listener to the list of cleanups
        cleanups.push({
          ee: ee,
          event: event,
          fn: fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i = 0; i < cleanups.length; i++) {
        x = cleanups[i];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn) {
      done = fn;
    }
    thunk.cancel = cleanup;
    return thunk;
  }

  /**
   * Create the event listener.
   * @private
   */

  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === 'error' ? arg1 : null;

      // copy args to prevent arguments escaping scope
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee, event, args);
    };
  }
  return eeFirst;
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished) return onFinished$1.exports;
  hasRequiredOnFinished = 1;

  /**
   * Module exports.
   * @public
   */

  onFinished$1.exports = onFinished;
  onFinished$1.exports.isFinished = isFinished;

  /**
   * Module dependencies.
   * @private
   */

  var asyncHooks = tryRequireAsyncHooks();
  var first = requireEeFirst();

  /**
   * Variables.
   * @private
   */

  /* istanbul ignore next */
  var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };

  /**
   * Invoke callback when the response has finished, useful for
   * cleaning up resources afterwards.
   *
   * @param {object} msg
   * @param {function} listener
   * @return {object}
   * @public
   */

  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }

    // attach the listener to the message
    attachListener(msg, wrap(listener));
    return msg;
  }

  /**
   * Determine if message is already finished.
   *
   * @param {object} msg
   * @return {boolean}
   * @public
   */

  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === 'boolean') {
      // OutgoingMessage
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === 'boolean') {
      // IncomingMessage
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }

    // don't know
    return undefined;
  }

  /**
   * Attach a finished listener to the message.
   *
   * @param {object} msg
   * @param {function} callback
   * @private
   */

  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }

    // finished on first message event
    eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);
    function onSocket(socket) {
      // remove listener
      msg.removeListener('socket', onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;

      // finished on first socket event
      eeSocket = first([[socket, 'error', 'close']], onFinish);
    }
    if (msg.socket) {
      // socket already assigned
      onSocket(msg.socket);
      return;
    }

    // wait for socket to be assigned
    msg.on('socket', onSocket);
    if (msg.socket === undefined) {
      // istanbul ignore next: node.js 0.8 patch
      patchAssignSocket(msg, onSocket);
    }
  }

  /**
   * Attach the listener to the message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function attachListener(msg, listener) {
    var attached = msg.__onFinished;

    // create a private single listener with queue
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }

  /**
   * Create listener on message.
   *
   * @param {object} msg
   * @return {function}
   * @private
   */

  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }

  /**
   * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
   *
   * @param {ServerResponse} res
   * @param {function} callback
   * @private
   */

  // istanbul ignore next: node.js 0.8 patch
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== 'function') return;

    // res.on('socket', callback) is broken in 0.8
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }

  /**
   * Try to require async_hooks
   * @private
   */

  function tryRequireAsyncHooks() {
    try {
      return require('async_hooks');
    } catch (e) {
      return {};
    }
  }

  /**
   * Wrap function with async resource, if possible.
   * AsyncResource.bind static method backported.
   * @private
   */

  function wrap(fn) {
    var res;

    // create anonymous resource
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }

    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
      return fn;
    }

    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished$1.exports;
}

/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var send_1;
var hasRequiredSend;
function requireSend() {
  if (hasRequiredSend) return send_1;
  hasRequiredSend = 1;

  /**
   * Module dependencies.
   * @private
   */

  var createError = requireHttpErrors$1();
  var debug = requireSrc()('send');
  var destroy = requireDestroy();
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var etag = requireEtag();
  var fresh = requireFresh();
  var fs = require$$3$2;
  var mime = requireMimeTypes$1();
  var ms = requireMs();
  var onFinished = requireOnFinished();
  var parseRange = requireRangeParser();
  var path = require$$0$a;
  var statuses = requireStatuses$1();
  var Stream = require$$1$4;
  var util = require$$1$2;

  /**
   * Path function references.
   * @private
   */

  var extname = path.extname;
  var join = path.join;
  var normalize = path.normalize;
  var resolve = path.resolve;
  var sep = path.sep;

  /**
   * Regular expression for identifying a bytes Range header.
   * @private
   */

  var BYTES_RANGE_REGEXP = /^ *bytes=/;

  /**
   * Maximum value allowed for the max age.
   * @private
   */

  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

  /**
   * Regular expression to match a path with a directory up component.
   * @private
   */

  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;

  /**
   * Module exports.
   * @public
   */

  send_1 = send;

  /**
   * Return a `SendStream` for `req` and `path`.
   *
   * @param {object} req
   * @param {string} path
   * @param {object} [options]
   * @return {SendStream}
   * @public
   */

  function send(req, path, options) {
    return new SendStream(req, path, options);
  }

  /**
   * Initialize a `SendStream` with the given `path`.
   *
   * @param {Request} req
   * @param {String} path
   * @param {object} [options]
   * @private
   */

  function SendStream(req, path, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';
    if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, 'extensions option') : [];
    this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;
    this._index = opts.index !== undefined ? normalizeList(opts.index, 'index option') : ['index.html'];
    this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === 'string' ? ms(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
  }

  /**
   * Inherits from `Stream`.
   */

  util.inherits(SendStream, Stream);

  /**
   * Emit error with `status`.
   *
   * @param {number} status
   * @param {Error} [err]
   * @private
   */

  SendStream.prototype.error = function error(status, err) {
    // emit if listeners instead of responding
    if (hasListeners(this, 'error')) {
      return this.emit('error', createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses.message[status] || String(status);
    var doc = createHtmlDocument('Error', escapeHtml(msg));

    // clear existing headers
    clearHeaders(res);

    // add error headers
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }

    // send basic response
    res.statusCode = status;
    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
    res.setHeader('Content-Length', Buffer.byteLength(doc));
    res.setHeader('Content-Security-Policy', "default-src 'none'");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.end(doc);
  };

  /**
   * Check if the pathname ends with "/".
   *
   * @return {boolean}
   * @private
   */

  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === '/';
  };

  /**
   * Check if this is a conditional GET request.
   *
   * @return {Boolean}
   * @api private
   */

  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
  };

  /**
   * Check if the request preconditions failed.
   *
   * @return {boolean}
   * @private
   */

  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;

    // if-match
    var match = req.headers['if-match'];
    if (match) {
      var etag = res.getHeader('ETag');
      return !etag || match !== '*' && parseTokenList(match).every(function (match) {
        return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
      });
    }

    // if-unmodified-since
    var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };

  /**
   * Strip various content header fields for a change in entity.
   *
   * @private
   */

  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader('Content-Encoding');
    res.removeHeader('Content-Language');
    res.removeHeader('Content-Length');
    res.removeHeader('Content-Range');
    res.removeHeader('Content-Type');
  };

  /**
   * Respond with 304 not modified.
   *
   * @api private
   */

  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug('not modified');
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };

  /**
   * Raise error that headers already sent.
   *
   * @api private
   */

  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error('Can\'t set headers after they are sent.');
    debug('headers already sent');
    this.error(500, err);
  };

  /**
   * Check if the request is cacheable, aka
   * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
   *
   * @return {Boolean}
   * @api private
   */

  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };

  /**
   * Handle stat() error.
   *
   * @param {Error} error
   * @private
   */

  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case 'ENAMETOOLONG':
      case 'ENOENT':
      case 'ENOTDIR':
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };

  /**
   * Check if the cache is fresh.
   *
   * @return {Boolean}
   * @api private
   */

  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader('ETag'),
      'last-modified': this.res.getHeader('Last-Modified')
    });
  };

  /**
   * Check if the range is fresh.
   *
   * @return {Boolean}
   * @api private
   */

  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers['if-range'];
    if (!ifRange) {
      return true;
    }

    // if-range as etag
    if (ifRange.indexOf('"') !== -1) {
      var etag = this.res.getHeader('ETag');
      return Boolean(etag && ifRange.indexOf(etag) !== -1);
    }

    // if-range as modified date
    var lastModified = this.res.getHeader('Last-Modified');
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };

  /**
   * Redirect to path.
   *
   * @param {string} path
   * @private
   */

  SendStream.prototype.redirect = function redirect(path) {
    var res = this.res;
    if (hasListeners(this, 'directory')) {
      this.emit('directory', res, path);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));

    // redirect
    res.statusCode = 301;
    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
    res.setHeader('Content-Length', Buffer.byteLength(doc));
    res.setHeader('Content-Security-Policy', "default-src 'none'");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('Location', loc);
    res.end(doc);
  };

  /**
   * Pipe to `res.
   *
   * @param {Stream} res
   * @return {Stream} res
   * @api public
   */

  SendStream.prototype.pipe = function pipe(res) {
    // root path
    var root = this._root;

    // references
    this.res = res;

    // decode the path
    var path = decode(this.path);
    if (path === -1) {
      this.error(400);
      return res;
    }

    // null byte(s)
    if (~path.indexOf('\0')) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      // normalize
      if (path) {
        path = normalize('.' + sep + path);
      }

      // malicious path
      if (UP_PATH_REGEXP.test(path)) {
        debug('malicious path "%s"', path);
        this.error(403);
        return res;
      }

      // explode path parts
      parts = path.split(sep);

      // join / normalize from optional root dir
      path = normalize(join(root, path));
    } else {
      // ".." is malicious without "root"
      if (UP_PATH_REGEXP.test(path)) {
        debug('malicious path "%s"', path);
        this.error(403);
        return res;
      }

      // explode path parts
      parts = normalize(path).split(sep);

      // resolve the path
      path = resolve(path);
    }

    // dotfile handling
    if (containsDotFile(parts)) {
      debug('%s dotfile "%s"', this._dotfiles, path);
      switch (this._dotfiles) {
        case 'allow':
          break;
        case 'deny':
          this.error(403);
          return res;
        case 'ignore':
        default:
          this.error(404);
          return res;
      }
    }

    // index file support
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path);
      return res;
    }
    this.sendFile(path);
    return res;
  };

  /**
   * Transfer `path`.
   *
   * @param {String} path
   * @api public
   */

  SendStream.prototype.send = function send(path, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (res.headersSent) {
      // impossible to send now
      this.headersAlreadySent();
      return;
    }
    debug('pipe "%s"', path);

    // set header fields
    this.setHeader(path, stat);

    // set content-type
    this.type(path);

    // conditional GET support
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }

    // adjust len to start/end options
    len = Math.max(0, len - offset);
    if (options.end !== undefined) {
      var bytes = options.end - offset + 1;
      if (len > bytes) len = bytes;
    }

    // Range support
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      // parse
      ranges = parseRange(len, ranges, {
        combine: true
      });

      // If-Range support
      if (!this.isRangeFresh()) {
        debug('range stale');
        ranges = -2;
      }

      // unsatisfiable
      if (ranges === -1) {
        debug('range unsatisfiable');

        // Content-Range
        res.setHeader('Content-Range', contentRange('bytes', len));

        // 416 Requested Range Not Satisfiable
        return this.error(416, {
          headers: {
            'Content-Range': res.getHeader('Content-Range')
          }
        });
      }

      // valid (syntactically invalid/multiple ranges are treated as a regular response)
      if (ranges !== -2 && ranges.length === 1) {
        debug('range %j', ranges);

        // Content-Range
        res.statusCode = 206;
        res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));

        // adjust for requested range
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }

    // clone options
    for (var prop in options) {
      opts[prop] = options[prop];
    }

    // set read options
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);

    // content-length
    res.setHeader('Content-Length', len);

    // HEAD support
    if (req.method === 'HEAD') {
      res.end();
      return;
    }
    this.stream(path, opts);
  };

  /**
   * Transfer file for `path`.
   *
   * @param {String} path
   * @api private
   */
  SendStream.prototype.sendFile = function sendFile(path) {
    var i = 0;
    var self = this;
    debug('stat "%s"', path);
    fs.stat(path, function onstat(err, stat) {
      var pathEndsWithSep = path[path.length - 1] === sep;
      if (err && err.code === 'ENOENT' && !extname(path) && !pathEndsWithSep) {
        // not found, check extensions
        return next(err);
      }
      if (err) return self.onStatError(err);
      if (stat.isDirectory()) return self.redirect(path);
      if (pathEndsWithSep) return self.error(404);
      self.emit('file', path, stat);
      self.send(path, stat);
    });
    function next(err) {
      if (self._extensions.length <= i) {
        return err ? self.onStatError(err) : self.error(404);
      }
      var p = path + '.' + self._extensions[i++];
      debug('stat "%s"', p);
      fs.stat(p, function (err, stat) {
        if (err) return next(err);
        if (stat.isDirectory()) return next();
        self.emit('file', p, stat);
        self.send(p, stat);
      });
    }
  };

  /**
   * Transfer index for `path`.
   *
   * @param {String} path
   * @api private
   */
  SendStream.prototype.sendIndex = function sendIndex(path) {
    var i = -1;
    var self = this;
    function next(err) {
      if (++i >= self._index.length) {
        if (err) return self.onStatError(err);
        return self.error(404);
      }
      var p = join(path, self._index[i]);
      debug('stat "%s"', p);
      fs.stat(p, function (err, stat) {
        if (err) return next(err);
        if (stat.isDirectory()) return next();
        self.emit('file', p, stat);
        self.send(p, stat);
      });
    }
    next();
  };

  /**
   * Stream `path` to the response.
   *
   * @param {String} path
   * @param {Object} options
   * @api private
   */

  SendStream.prototype.stream = function stream(path, options) {
    var self = this;
    var res = this.res;

    // pipe
    var stream = fs.createReadStream(path, options);
    this.emit('stream', stream);
    stream.pipe(res);

    // cleanup
    function cleanup() {
      destroy(stream, true);
    }

    // response finished, cleanup
    onFinished(res, cleanup);

    // error handling
    stream.on('error', function onerror(err) {
      // clean up stream early
      cleanup();

      // error
      self.onStatError(err);
    });

    // end
    stream.on('end', function onend() {
      self.emit('end');
    });
  };

  /**
   * Set content-type based on `path`
   * if it hasn't been explicitly set.
   *
   * @param {String} path
   * @api private
   */

  SendStream.prototype.type = function type(path) {
    var res = this.res;
    if (res.getHeader('Content-Type')) return;
    var ext = extname(path);
    var type = mime.contentType(ext) || 'application/octet-stream';
    debug('content-type %s', type);
    res.setHeader('Content-Type', type);
  };

  /**
   * Set response header fields, most
   * fields may be pre-defined.
   *
   * @param {String} path
   * @param {Object} stat
   * @api private
   */

  SendStream.prototype.setHeader = function setHeader(path, stat) {
    var res = this.res;
    this.emit('headers', res, path, stat);
    if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
      debug('accept ranges');
      res.setHeader('Accept-Ranges', 'bytes');
    }
    if (this._cacheControl && !res.getHeader('Cache-Control')) {
      var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
      if (this._immutable) {
        cacheControl += ', immutable';
      }
      debug('cache-control %s', cacheControl);
      res.setHeader('Cache-Control', cacheControl);
    }
    if (this._lastModified && !res.getHeader('Last-Modified')) {
      var modified = stat.mtime.toUTCString();
      debug('modified %s', modified);
      res.setHeader('Last-Modified', modified);
    }
    if (this._etag && !res.getHeader('ETag')) {
      var val = etag(stat);
      debug('etag %s', val);
      res.setHeader('ETag', val);
    }
  };

  /**
   * Clear all headers from a response.
   *
   * @param {object} res
   * @private
   */

  function clearHeaders(res) {
    var headers = getHeaderNames(res);
    for (var i = 0; i < headers.length; i++) {
      res.removeHeader(headers[i]);
    }
  }

  /**
   * Collapse all leading slashes into a single slash
   *
   * @param {string} str
   * @private
   */
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== '/') {
        break;
      }
    }
    return i > 1 ? '/' + str.substr(i) : str;
  }

  /**
   * Determine if path parts contain a dotfile.
   *
   * @api private
   */

  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === '.') {
        return true;
      }
    }
    return false;
  }

  /**
   * Create a Content-Range header.
   *
   * @param {string} type
   * @param {number} size
   * @param {array} [range]
   */

  function contentRange(type, size, range) {
    return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
  }

  /**
   * Create a minimal HTML document.
   *
   * @param {string} title
   * @param {string} body
   * @private
   */

  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>' + title + '</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
  }

  /**
   * Create a HttpError object from simple arguments.
   *
   * @param {number} status
   * @param {Error|object} err
   * @private
   */

  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, {
      expose: false
    }) : createError(status, err);
  }

  /**
   * decodeURIComponent.
   *
   * Allows V8 to only deoptimize this fn instead of all
   * of send().
   *
   * @param {String} path
   * @api private
   */

  function decode(path) {
    try {
      return decodeURIComponent(path);
    } catch (err) {
      return -1;
    }
  }

  /**
   * Get the header names on a response.
   *
   * @param {object} res
   * @returns {array[string]}
   * @private
   */

  function getHeaderNames(res) {
    return typeof res.getHeaderNames !== 'function' ? Object.keys(res._headers || {}) : res.getHeaderNames();
  }

  /**
   * Determine if emitter has listeners of a given type.
   *
   * The way to do this check is done three different ways in Node.js >= 0.10
   * so this consolidates them into a minimal set using instance methods.
   *
   * @param {EventEmitter} emitter
   * @param {string} type
   * @returns {boolean}
   * @private
   */

  function hasListeners(emitter, type) {
    var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }

  /**
   * Normalize the index option into an array.
   *
   * @param {boolean|string|array} val
   * @param {string} name
   * @private
   */

  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== 'string') {
        throw new TypeError(name + ' must be array of strings or false');
      }
    }
    return list;
  }

  /**
   * Parse an HTTP Date into a number.
   *
   * @param {string} date
   * @private
   */

  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === 'number' ? timestamp : NaN;
  }

  /**
   * Parse a HTTP token list.
   *
   * @param {string} str
   * @private
   */

  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;

    // gather tokens
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 0x20:
          /*   */
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 0x2c:
          /* , */
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }

    // final token
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }

  /**
   * Set an object of headers on a response.
   *
   * @param {object} res
   * @param {object} headers
   * @private
   */

  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
  return send_1;
}

var sendExports = requireSend();
var send = /*@__PURE__*/getDefaultExportFromCjs(sendExports);

var bytes$3 = {exports: {}};

/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes$1;
function requireBytes$1() {
  if (hasRequiredBytes$1) return bytes$3.exports;
  hasRequiredBytes$1 = 1;

  /**
   * Module exports.
   * @public
   */

  bytes$3.exports = bytes;
  bytes$3.exports.format = format;
  bytes$3.exports.parse = parse;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

  /**
   * Convert the given value in bytes into a string or parse to string to an integer in bytes.
   *
   * @param {string|number} value
   * @param {{
   *  case: [string],
   *  decimalPlaces: [number]
   *  fixedDecimals: [boolean]
   *  thousandsSeparator: [string]
   *  unitSeparator: [string]
   *  }} [options] bytes options.
   *
   * @returns {string|number|null}
   */

  function bytes(value, options) {
    if (typeof value === 'string') {
      return parse(value);
    }
    if (typeof value === 'number') {
      return format(value, options);
    }
    return null;
  }

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unit=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || '';
    var unitSeparator = options && options.unitSeparator || '';
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || '';
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = 'PB';
      } else if (mag >= map.tb) {
        unit = 'TB';
      } else if (mag >= map.gb) {
        unit = 'GB';
      } else if (mag >= map.mb) {
        unit = 'MB';
      } else if (mag >= map.kb) {
        unit = 'KB';
      } else {
        unit = 'B';
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }
    if (thousandsSeparator) {
      str = str.split('.').map(function (s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join('.');
    }
    return str + unitSeparator + unit;
  }

  /**
   * Parse the string value into an integer in bytes.
   *
   * If no unit is given, it is assumed the value is in bytes.
   *
   * @param {number|string} val
   *
   * @returns {number|null}
   * @public
   */

  function parse(val) {
    if (typeof val === 'number' && !isNaN(val)) {
      return val;
    }
    if (typeof val !== 'string') {
      return null;
    }

    // Test if the string passed is valid
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = 'b';
    if (!results) {
      // Nothing could be extracted from the given string
      floatValue = parseInt(val, 10);
      unit = 'b';
    } else {
      // Retrieve the value and the unit
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  }
  return bytes$3.exports;
}

var bytesExports$1 = requireBytes$1();
var bytes$2 = /*@__PURE__*/getDefaultExportFromCjs(bytesExports$1);

var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  function parseContentType(str) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;

    // Parse type
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 /* '/' */ || i === 0) return;
        break;
      }
    }
    // Check for type without subtype
    if (i === str.length) return;
    const type = str.slice(0, i).toLowerCase();

    // Parse subtype
    const subtypeStart = ++i;
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        // Make sure we have a subtype
        if (i === subtypeStart) return;
        if (parseContentTypeParams(str, i, params) === undefined) return;
        break;
      }
    }
    // Make sure we have a subtype
    if (i === subtypeStart) return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return {
      type,
      subtype,
      params
    };
  }
  function parseContentTypeParams(str, i, params) {
    while (i < str.length) {
      // Consume whitespace
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 /* ' ' */ && code !== 9 /* '\t' */) break;
      }

      // Ended on whitespace
      if (i === str.length) break;

      // Check for malformed parameter
      if (str.charCodeAt(i++) !== 59 /* ';' */) return;

      // Consume whitespace
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 /* ' ' */ && code !== 9 /* '\t' */) break;
      }

      // Ended on whitespace (malformed)
      if (i === str.length) return;
      let name;
      const nameStart = i;
      // Parse parameter name
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61 /* '=' */) return;
          break;
        }
      }

      // No value (malformed)
      if (i === str.length) return;
      name = str.slice(nameStart, i);
      ++i; // Skip over '='

      // No value (malformed)
      if (i === str.length) return;
      let value = '';
      let valueStart;
      if (str.charCodeAt(i) === 34 /* '"' */) {
        valueStart = ++i;
        let escaping = false;
        // Parse quoted value
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92 /* '\\' */) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34 /* '"' */) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          // Invalid unescaped quoted character (malformed)
          if (QDTEXT[code] !== 1) return;
        }

        // No end quote (malformed)
        if (i === str.length) return;
        ++i; // Skip over double quote
      } else {
        valueStart = i;
        // Parse unquoted value
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            // No value (malformed)
            if (i === valueStart) return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined) params[name] = value;
    }
    return params;
  }
  function parseDisposition(str, defDecoder) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined) return;
        break;
      }
    }
    const type = str.slice(0, i).toLowerCase();
    return {
      type,
      params
    };
  }
  function parseDispositionParams(str, i, params, defDecoder) {
    while (i < str.length) {
      // Consume whitespace
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 /* ' ' */ && code !== 9 /* '\t' */) break;
      }

      // Ended on whitespace
      if (i === str.length) break;

      // Check for malformed parameter
      if (str.charCodeAt(i++) !== 59 /* ';' */) return;

      // Consume whitespace
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 /* ' ' */ && code !== 9 /* '\t' */) break;
      }

      // Ended on whitespace (malformed)
      if (i === str.length) return;
      let name;
      const nameStart = i;
      // Parse parameter name
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61 /* '=' */) break;
          return;
        }
      }

      // No value (malformed)
      if (i === str.length) return;
      let value = '';
      let valueStart;
      let charset;
      //~ let lang;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42 /* '*' */) {
        // Extended value

        const charsetStart = ++i;
        // Parse charset name
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39 /* '\'' */) return;
            break;
          }
        }

        // Incomplete charset (malformed)
        if (i === str.length) return;
        charset = str.slice(charsetStart, i);
        ++i; // Skip over the '\''

        //~ const langStart = ++i;
        // Parse language name
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39 /* '\'' */) break;
        }

        // Incomplete language (malformed)
        if (i === str.length) return;

        //~ lang = str.slice(langStart, i);
        ++i; // Skip over the '\''

        // No value (malformed)
        if (i === str.length) return;
        valueStart = i;
        let encode = 0;
        // Parse value
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37 /* '%' */) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128) encode = 2;else if (encode === 0) encode = 1;
                continue;
              }
              // '%' disallowed in non-percent encoded contexts (malformed)
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined) return;
      } else {
        // Non-extended value

        ++i; // Skip over '='

        // No value (malformed)
        if (i === str.length) return;
        if (str.charCodeAt(i) === 34 /* '"' */) {
          valueStart = ++i;
          let escaping = false;
          // Parse quoted value
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92 /* '\\' */) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34 /* '"' */) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            // Invalid unescaped quoted character (malformed)
            if (QDTEXT[code] !== 1) return;
          }

          // No end quote (malformed)
          if (i === str.length) return;
          ++i; // Skip over double quote
        } else {
          valueStart = i;
          // Parse unquoted value
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              // No value (malformed)
              if (i === valueStart) return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined) return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined) params[name] = value;
    }
    return params;
  }
  function getDecoder(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case 'utf-8':
        case 'utf8':
          return decoders.utf8;
        case 'latin1':
        case 'ascii': // TODO: Make these a separate, strict decoder?
        case 'us-ascii':
        case 'iso-8859-1':
        case 'iso8859-1':
        case 'iso88591':
        case 'iso_8859-1':
        case 'windows-1252':
        case 'iso_8859-1:1987':
        case 'cp1252':
        case 'x-cp1252':
          return decoders.latin1;
        case 'utf16le':
        case 'utf-16le':
        case 'ucs2':
        case 'ucs-2':
          return decoders.utf16le;
        case 'base64':
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  }
  const decoders = {
    utf8: (data, hint) => {
      if (data.length === 0) return '';
      if (typeof data === 'string') {
        // If `data` never had any percent-encoded bytes or never had any that
        // were outside of the ASCII range, then we can safely just return the
        // input since UTF-8 is ASCII compatible
        if (hint < 2) return data;
        data = Buffer.from(data, 'latin1');
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0) return '';
      if (typeof data === 'string') return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0) return '';
      if (typeof data === 'string') data = Buffer.from(data, 'latin1');
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0) return '';
      if (typeof data === 'string') data = Buffer.from(data, 'latin1');
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0) return '';
      if (typeof data === 'string') data = Buffer.from(data, 'latin1');
      try {
        const decoder = new TextDecoder(this);
        return decoder.decode(data);
      } catch {}
    }
  };
  function convertToUTF8(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode) return decode(data, hint);
  }
  function basename(path) {
    if (typeof path !== 'string') return '';
    for (let i = path.length - 1; i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 0x2F: // '/'
        case 0x5C:
          // '\'
          path = path.slice(i + 1);
          return path === '..' || path === '.' ? '' : path;
      }
    }
    return path === '..' || path === '.' ? '' : path;
  }
  const TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const QDTEXT = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  const CHARSET = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const EXTENDED_VALUE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

  /* eslint-disable no-multi-spaces */
  const HEX_VALUES = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  /* eslint-enable no-multi-spaces */

  utils$2 = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
  return utils$2;
}

var sbmh;
var hasRequiredSbmh;
function requireSbmh() {
  if (hasRequiredSbmh) return sbmh;
  hasRequiredSbmh = 1;
  /*
    Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
    by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
  */
  function memcmp(buf1, pos1, buf2, pos2, num) {
    for (let i = 0; i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;
    }
    return true;
  }
  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== 'function') throw new Error('Missing match callback');
      if (typeof needle === 'string') needle = Buffer.from(needle);else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);

      // Initialize occurrence table.
      this._occ = [needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen];

      // Populate occurrence table with analysis of the needle, ignoring the last
      // letter.
      if (needleLen > 1) {
        for (let i = 0; i < needleLen - 1; ++i) this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'latin1');
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches) result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  function feed(self, data) {
    const len = data.length;
    const needle = self._needle;
    const needleLen = needle.length;

    // Positive: points to a position in `data`
    //           pos == 3 points to data[3]
    // Negative: points to a position in the lookbehind buffer
    //           pos == -2 points to lookbehind[lookbehindSize - 2]
    let pos = -self._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self._occ;
    const lookbehind = self._lookbehind;
    if (pos < 0) {
      // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
      // search with character lookup code that considers both the
      // lookbehind buffer and the current round's haystack data.
      //
      // Loop until
      //   there is a match.
      // or until
      //   we've moved past the position that requires the
      //   lookbehind buffer. In this case we switch to the
      //   optimized loop.
      // or until
      //   the character to look at lies outside the haystack.
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {
          self._lookbehindSize = 0;
          ++self.matches;
          if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);else self._cb(true, undefined, 0, 0, true);
          return self._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }

      // No match.

      // There's too few data for Boyer-Moore-Horspool to run,
      // so let's use a different algorithm to skip as much as
      // we can.
      // Forward pos until
      //   the trailing part of lookbehind + data
      //   looks like the beginning of the needle
      // or until
      //   pos == 0
      while (pos < 0 && !matchNeedle(self, data, pos, len - pos)) ++pos;
      if (pos < 0) {
        // Cut off part of the lookbehind buffer that has
        // been processed and append the entire haystack
        // into it.
        const bytesToCutOff = self._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          // The cut off data is guaranteed not to contain the needle.
          self._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);
        lookbehind.set(data, self._lookbehindSize);
        self._lookbehindSize += len;
        self._bufPos = len;
        return len;
      }

      // Discard lookbehind buffer.
      self._cb(false, lookbehind, 0, self._lookbehindSize, false);
      self._lookbehindSize = 0;
    }
    pos += self._bufPos;
    const firstNeedleChar = needle[0];

    // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool
    // search with optimized character lookup code that only considers
    // the current round's haystack data.
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self.matches;
        if (pos > 0) self._cb(true, data, self._bufPos, pos, true);else self._cb(true, undefined, 0, 0, true);
        return self._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }

    // There was no match. If there's trailing haystack data that we cannot
    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
    // data is less than the needle size) then match using a modified
    // algorithm that starts matching from the beginning instead of the end.
    // Whatever trailing data is left after running this algorithm is added to
    // the lookbehind buffer.
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self._lookbehindSize = len - pos;
      break;
    }

    // Everything until `pos` is guaranteed not to contain needle data.
    if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);
    self._bufPos = len;
    return len;
  }
  function matchNeedle(self, data, pos, len) {
    const lb = self._lookbehind;
    const lbSize = self._lookbehindSize;
    const needle = self._needle;
    for (let i = 0; i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i]) return false;
    }
    return true;
  }
  sbmh = SBMH;
  return sbmh;
}

var multipart;
var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart) return multipart;
  hasRequiredMultipart = 1;
  const {
    Readable,
    Writable
  } = require$$1$4;
  const StreamSearch = requireSbmh();
  const {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = requireUtils$2();
  const BUF_CRLF = Buffer.from('\r\n');
  const BUF_CR = Buffer.from('\r');
  const BUF_DASH = Buffer.from('-');
  function noop() {}
  const MAX_HEADER_PAIRS = 2000; // From node
  const MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)

  const HPARSER_NAME = 0;
  const HPARSER_PRE_OWS = 1;
  const HPARSER_VALUE = 2;
  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = '';
      this.value = '';
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = '';
      this.value = '';
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME:
            {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (TOKEN[code] !== 1) {
                  if (code !== 58 /* ':' */) return -1;
                  this.name += chunk.latin1Slice(start, pos);
                  if (this.name.length === 0) return -1;
                  ++pos;
                  done = true;
                  this.state = HPARSER_PRE_OWS;
                  break;
                }
              }
              if (!done) {
                this.name += chunk.latin1Slice(start, pos);
                break;
              }
              // FALLTHROUGH
            }
          case HPARSER_PRE_OWS:
            {
              // Skip optional whitespace
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code !== 32 /* ' ' */ && code !== 9 /* '\t' */) {
                  start = pos;
                  done = true;
                  this.state = HPARSER_VALUE;
                  break;
                }
              }
              if (!done) break;
              // FALLTHROUGH
            }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                // Nothing yet
                for (; pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13 /* '\r' */) return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                // Received CR
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10 /* '\n' */) return -1;
                ++this.crlf;
                break;
              case 2:
                {
                  // Received CR LF
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (code === 32 /* ' ' */ || code === 9 /* '\t' */) {
                    // Folded value
                    start = pos;
                    this.crlf = 0;
                  } else {
                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                      this.name = this.name.toLowerCase();
                      if (this.header[this.name] === undefined) this.header[this.name] = [this.value];else this.header[this.name].push(this.value);
                    }
                    if (code === 13 /* '\r' */) {
                      ++this.crlf;
                      ++pos;
                    } else {
                      // Assume start of next header field name
                      start = pos;
                      this.crlf = 0;
                      this.state = HPARSER_NAME;
                      this.name = '';
                      this.value = '';
                    }
                  }
                  break;
                }
              case 3:
                {
                  // Received CR LF CR
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10 /* '\n' */) return -1;
                  // End of header
                  const header = this.header;
                  this.reset();
                  this.cb(header);
                  return pos;
                }
            }
            break;
        }
      }
      return pos;
    }
  }
  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once('end', () => {
        // We need to make sure that we call any outstanding _writecb() that is
        // associated with this file so that processing of the rest of the form
        // can continue. This may not happen if the file stream ends right after
        // backpressure kicks in, so we force it here.
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          // Make sure other 'end' event handlers get a chance to be executed
          // before busboy's 'finish' event is emitted
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  const ignoreData = {
    push: (chunk, pos) => {},
    destroy: () => {}
  };
  function callAndUnsetCb(self, err) {
    const cb = self._writecb;
    self._writecb = null;
    if (cb) cb();
  }
  function nullDecoder(val, hint) {
    return val;
  }
  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || 'utf8';
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;
      let parts = -1; // Account for initial boundary
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser(header => {
        this._hparser = null;
        skipPart = false;
        partType = 'text/plain';
        partCharset = defCharset;
        partEncoding = '7bit';
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header['content-disposition']) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header['content-disposition'][0], paramDecoder);
        if (!disp || disp.type !== 'form-data') {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name) partName = disp.params.name;
          if (disp.params['filename*']) filename = disp.params['filename*'];else if (disp.params.filename) filename = disp.params.filename;
          if (filename !== undefined && !preservePath) filename = basename(filename);
        }
        if (header['content-type']) {
          const conType = parseContentType(header['content-type'][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();
        if (partType === 'application/octet-stream' || filename !== undefined) {
          // File

          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit('filesLimit');
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount('file') === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit('file', partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          // Non-file

          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit('fieldsLimit');
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount('field') === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata: while (data) {
          if (this._hparser !== null) {
            const ret = this._hparser.push(data, start, end);
            if (ret === -1) {
              this._hparser = null;
              hparser.reset();
              this.emit('error', new Error('Malformed part header'));
              break;
            }
            start = ret;
          }
          if (start === end) break;
          if (matchPostBoundary !== 0) {
            if (matchPostBoundary === 1) {
              switch (data[start]) {
                case 45:
                  // '-'
                  // Try matching '--' after boundary
                  matchPostBoundary = 2;
                  ++start;
                  break;
                case 13:
                  // '\r'
                  // Try matching CR LF before header
                  matchPostBoundary = 3;
                  ++start;
                  break;
                default:
                  matchPostBoundary = 0;
              }
              if (start === end) return;
            }
            if (matchPostBoundary === 2) {
              matchPostBoundary = 0;
              if (data[start] === 45 /* '-' */) {
                // End of multipart data
                this._complete = true;
                this._bparser = ignoreData;
                return;
              }
              // We saw something other than '-', so put the dash we consumed
              // "back"
              const writecb = this._writecb;
              this._writecb = noop;
              ssCb(false, BUF_DASH, 0, 1, false);
              this._writecb = writecb;
            } else if (matchPostBoundary === 3) {
              matchPostBoundary = 0;
              if (data[start] === 10 /* '\n' */) {
                ++start;
                if (parts >= partsLimit) break;
                // Prepare the header parser
                this._hparser = hparser;
                if (start === end) break;
                // Process the remaining data as a header
                continue retrydata;
              } else {
                // We saw something other than LF, so put the CR we consumed
                // "back"
                const writecb = this._writecb;
                this._writecb = noop;
                ssCb(false, BUF_CR, 0, 1, false);
                this._writecb = writecb;
              }
            }
          }
          if (!skipPart) {
            if (this._fileStream) {
              let chunk;
              const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data.slice(start, start + actualLen);
              }
              fileSize += chunk.length;
              if (fileSize === fileSizeLimit) {
                if (chunk.length > 0) this._fileStream.push(chunk);
                this._fileStream.emit('limit');
                this._fileStream.truncated = true;
                skipPart = true;
              } else if (!this._fileStream.push(chunk)) {
                if (this._writecb) this._fileStream._readcb = this._writecb;
                this._writecb = null;
              }
            } else if (field !== undefined) {
              let chunk;
              const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data.slice(start, start + actualLen);
              }
              fieldSize += actualLen;
              field.push(chunk);
              if (fieldSize === fieldSizeLimit) {
                skipPart = true;
                partTruncated = true;
              }
            }
          }
          break;
        }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            // End the active file stream if the previous part was a file
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data;
            switch (field.length) {
              case 0:
                data = '';
                break;
              case 1:
                data = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit('field', partName, data, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit) this.emit('partsLimit');
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;

      // Just in case there is no preamble
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === 'multipart' && conType.subtype === 'form-data';
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb) callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err) err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete) return cb(new Error('Unexpected end of form'));
      if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);else finalcb(this, cb);
    }
  }
  function finalcb(self, cb, err) {
    if (err) return cb(err);
    err = checkEndState(self);
    cb(err);
  }
  function checkEndState(self) {
    if (self._hparser) return new Error('Malformed part header');
    const fileStream = self._fileStream;
    if (fileStream) {
      self._fileStream = null;
      fileStream.destroy(new Error('Unexpected end of file'));
    }
    if (!self._complete) return new Error('Unexpected end of form');
  }
  const TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const FIELD_VCHAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  multipart = Multipart;
  return multipart;
}

var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded;
  hasRequiredUrlencoded = 1;
  const {
    Writable
  } = require$$1$4;
  const {
    getDecoder
  } = requireUtils$2();
  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || 'utf8';
      if (cfg.conType.params && typeof cfg.conType.params.charset === 'string') charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = '';
      this._val = '';
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === 'application' && conType.subtype === 'x-www-form-urlencoded';
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit) return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;

      // Check if we last ended mid-percent-encoded byte
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1) return cb(new Error('Malformed urlencoded form'));
        if (i >= len) return cb();
        if (this._inKey) ++this._bytesKey;else ++this._bytesVal;
      }
      main: while (i < len) {
        if (this._inKey) {
          // Parsing key

          i = skipKeyBytes(this, chunk, i, len);
          while (i < len) {
            switch (chunk[i]) {
              case 61:
                // '='
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                this._inKey = false;
                continue main;
              case 38:
                // '&'
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0) {
                  this.emit('field', this._key, '', {
                    nameTruncated: this._keyTrunc,
                    valueTruncated: false,
                    encoding: this.charset,
                    mimeType: 'text/plain'
                  });
                }
                this._key = '';
                this._val = '';
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit('fieldsLimit');
                  return cb();
                }
                continue;
              case 43:
                // '+'
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                this._key += ' ';
                this._lastPos = i + 1;
                break;
              case 37:
                // '%'
                if (this._encode === 0) this._encode = 1;
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = i + 1;
                this._byte = -1;
                i = readPctEnc(this, chunk, i + 1, len);
                if (i === -1) return cb(new Error('Malformed urlencoded form'));
                if (i >= len) return cb();
                ++this._bytesKey;
                i = skipKeyBytes(this, chunk, i, len);
                continue;
            }
            ++i;
            ++this._bytesKey;
            i = skipKeyBytes(this, chunk, i, len);
          }
          if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
        } else {
          // Parsing value

          i = skipValBytes(this, chunk, i, len);
          while (i < len) {
            switch (chunk[i]) {
              case 38:
                // '&'
                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._inKey = true;
                this._val = this._decoder(this._val, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0 || this._bytesVal > 0) {
                  this.emit('field', this._key, this._val, {
                    nameTruncated: this._keyTrunc,
                    valueTruncated: this._valTrunc,
                    encoding: this.charset,
                    mimeType: 'text/plain'
                  });
                }
                this._key = '';
                this._val = '';
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit('fieldsLimit');
                  return cb();
                }
                continue main;
              case 43:
                // '+'
                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                this._val += ' ';
                this._lastPos = i + 1;
                break;
              case 37:
                // '%'
                if (this._encode === 0) this._encode = 1;
                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = i + 1;
                this._byte = -1;
                i = readPctEnc(this, chunk, i + 1, len);
                if (i === -1) return cb(new Error('Malformed urlencoded form'));
                if (i >= len) return cb();
                ++this._bytesVal;
                i = skipValBytes(this, chunk, i, len);
                continue;
            }
            ++i;
            ++this._bytesVal;
            i = skipValBytes(this, chunk, i, len);
          }
          if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
        }
      }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2) return cb(new Error('Malformed urlencoded form'));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey) this._key = this._decoder(this._key, this._encode);else this._val = this._decoder(this._val, this._encode);
        this.emit('field', this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: 'text/plain'
        });
      }
      cb();
    }
  }
  function readPctEnc(self, chunk, pos, len) {
    if (pos >= len) return len;
    if (self._byte === -1) {
      // We saw a '%' but no hex characters yet
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1) return -1;
      if (hexUpper >= 8) self._encode = 2; // Indicate high bits detected

      if (pos < len) {
        // Both hex characters are in this chunk
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1) return -1;
        if (self._inKey) self._key += String.fromCharCode((hexUpper << 4) + hexLower);else self._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self._byte = -2;
        self._lastPos = pos;
      } else {
        // Only one hex character was available in this chunk
        self._byte = hexUpper;
      }
    } else {
      // We saw only one hex character so far
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1) return -1;
      if (self._inKey) self._key += String.fromCharCode((self._byte << 4) + hexLower);else self._val += String.fromCharCode((self._byte << 4) + hexLower);
      self._byte = -2;
      self._lastPos = pos;
    }
    return pos;
  }
  function skipKeyBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesKey > self.fieldNameSizeLimit) {
      if (!self._keyTrunc) {
        if (self._lastPos < pos) self._key += chunk.latin1Slice(self._lastPos, pos - 1);
      }
      self._keyTrunc = true;
      for (; pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 /* '=' */ || code === 38 /* '&' */) break;
        ++self._bytesKey;
      }
      self._lastPos = pos;
    }
    return pos;
  }
  function skipValBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesVal > self.fieldSizeLimit) {
      if (!self._valTrunc) {
        if (self._lastPos < pos) self._val += chunk.latin1Slice(self._lastPos, pos - 1);
      }
      self._valTrunc = true;
      for (; pos < len; ++pos) {
        if (chunk[pos] === 38 /* '&' */) break;
        ++self._bytesVal;
      }
      self._lastPos = pos;
    }
    return pos;
  }

  /* eslint-disable no-multi-spaces */
  const HEX_VALUES = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  /* eslint-enable no-multi-spaces */

  urlencoded = URLEncoded;
  return urlencoded;
}

var lib$4;
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4;
  hasRequiredLib$4 = 1;
  const {
    parseContentType
  } = requireUtils$2();
  function getInstance(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers['content-type']);
    if (!conType) throw new Error('Malformed content type');
    for (const type of TYPES) {
      const matched = type.detect(conType);
      if (!matched) continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark) instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm) instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers['content-type']}`);
  }

  // Note: types are explicitly listed here for easier bundling
  // See: https://github.com/mscdex/busboy/issues/121
  const TYPES = [requireMultipart(), requireUrlencoded()].filter(function (typemod) {
    return typeof typemod.detect === 'function';
  });
  lib$4 = cfg => {
    if (typeof cfg !== 'object' || cfg === null) cfg = {};
    if (typeof cfg.headers !== 'object' || cfg.headers === null || typeof cfg.headers['content-type'] !== 'string') {
      throw new Error('Missing Content-Type');
    }
    return getInstance(cfg);
  };
  return lib$4;
}

var libExports = requireLib$4();
var Busboy = /*@__PURE__*/getDefaultExportFromCjs(libExports);

var onFinishedExports = requireOnFinished();
var onFinished = /*@__PURE__*/getDefaultExportFromCjs(onFinishedExports);

var ipaddr$3 = {exports: {}};

var ipaddr$2 = ipaddr$3.exports;
var hasRequiredIpaddr$1;
function requireIpaddr$1() {
  if (hasRequiredIpaddr$1) return ipaddr$3.exports;
  hasRequiredIpaddr$1 = 1;
  (function (module) {
    (function () {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (module !== null && module.exports) {
        module.exports = ipaddr;
      } else {
        root['ipaddr'] = ipaddr;
      }
      matchCIDR = function (first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function (address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = 'unicast';
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function () {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function () {
          return 'ipv4';
        };
        IPv4.prototype.toString = function () {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function () {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function () {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function (other, cidrRange) {
          var ref;
          if (cidrRange === undefined) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== 'ipv4') {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function () {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function () {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function () {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
        longValue: new RegExp("^" + ipv4Part + "$", 'i')
      };
      ipaddr.IPv4.parser = function (string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function (string) {
          if (string[0] === "0" && string[1] !== "x") {
            return parseInt(string, 8);
          } else {
            return parseInt(string);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function () {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 0xffffffff || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function () {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 0xff);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function () {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 0xffff)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function () {
          return 'ipv6';
        };
        IPv6.prototype.toString = function () {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
        };
        IPv6.prototype.toRFC5952String = function () {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function () {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 0xff);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function () {
          var addr, part, suffix;
          addr = function () {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = '';
          if (this.zoneId) {
            suffix = '%' + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function () {
          var addr, part, suffix;
          addr = function () {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, '0'));
            }
            return results;
          }.call(this).join(":");
          suffix = '';
          if (this.zoneId) {
            suffix = '%' + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function (other, cidrRange) {
          var ref;
          if (cidrRange === undefined) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== 'ipv6') {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
          rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
          '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function () {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function () {
          return this.range() === 'ipv4Mapped';
        };
        IPv6.prototype.toIPv4Address = function () {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function () {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, 'i'),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
      };
      expandIPv6 = function (string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, '');
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === '::') {
          colonCount--;
        }
        if (string.substr(-2, 2) === '::') {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ':';
        while (replacementCount--) {
          replacement += '0:';
        }
        string = string.replace('::', replacement);
        if (string[0] === ':') {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ':') {
          string = string.slice(0, -1);
        }
        parts = function () {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts: parts,
          zoneId: zoneId
        };
      };
      ipaddr.IPv6.parser = function (string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes['native'].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes['transitional'])) {
          zoneId = match[6] || '';
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function (string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function (string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function (string) {
        var addr;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr.IPv4.parse = function (string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function (string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function (string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, 'toString', {
              value: function () {
                return this.join('/');
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error('ipaddr: invalid IPv4 prefix length');
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function (string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
      };
      ipaddr.IPv6.parseCIDR = function (string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, 'toString', {
              value: function () {
                return this.join('/');
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function (string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function (string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function (string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error1) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function (bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function (string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(ipaddr$2);
  })(ipaddr$3);
  return ipaddr$3.exports;
}

var ipRangeCheck$1;
var hasRequiredIpRangeCheck;
function requireIpRangeCheck() {
  if (hasRequiredIpRangeCheck) return ipRangeCheck$1;
  hasRequiredIpRangeCheck = 1;
  var ipaddr = requireIpaddr$1();
  ipRangeCheck$1 = check_many_cidrs;
  function check_many_cidrs(addr, range) {
    if (typeof range === "string") {
      return check_single_cidr(addr, range);
    } else if (typeof range === "object")
      //list
      {
        var ip_is_in_range = false;
        for (var i = 0; i < range.length; i++) {
          if (check_single_cidr(addr, range[i])) {
            ip_is_in_range = true;
            break;
          }
        }
        return ip_is_in_range;
      }
  }
  function check_single_cidr(addr, cidr) {
    try {
      var parsed_addr = ipaddr.process(addr);
      if (cidr.indexOf('/') === -1) {
        var parsed_cidr_as_ip = ipaddr.process(cidr);
        if (parsed_addr.kind() === "ipv6" && parsed_cidr_as_ip.kind() === "ipv6") {
          return parsed_addr.toNormalizedString() === parsed_cidr_as_ip.toNormalizedString();
        }
        return parsed_addr.toString() == parsed_cidr_as_ip.toString();
      } else {
        var parsed_range = ipaddr.parseCIDR(cidr);
        return parsed_addr.match(parsed_range);
      }
    } catch (e) {
      return false;
    }
  }
  return ipRangeCheck$1;
}

var ipRangeCheckExports = requireIpRangeCheck();
var ipRangeCheck = /*@__PURE__*/getDefaultExportFromCjs(ipRangeCheckExports);

const HTTP_OK = 200;
const HTTP_NOT_MODIFIED = 304;
const HTTP_BAD_REQUEST = 400;
const HTTP_UNAUTHORIZED = 401;
const HTTP_FORBIDDEN = 403;
const HTTP_NOT_FOUND = 404;
const HTTP_METHOD_NOT_ALLOWED = 405;
const HTTP_NOT_ACCEPTABLE = 406;
const HTTP_INTERNAL_SERVER_ERROR = 500;

/**
 * Custom error for cookie operations.
 */
class CookieError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'CookieError';
  }
}

/**
 * Check if the value is serialized.
 * @param value - The value to check.
 */
const isCookieValueSerialized = value => {
  return typeof value === 'string' && value.startsWith('$$j$$:');
};
/**
 * Check if the value is signed.
 * @param value - The value to check.
 */
const isCookieValueSigned = value => {
  return typeof value === 'string' && value.startsWith('$$s$$:');
};
/**
 * Sign the cookie value.
 * @param value - The value to sign.
 * @param secret - Secret for signing.
 */
const signCookieValue = (value, secret) => {
  if (typeof value !== 'string') {
    throw new CookieError('Can only sign string value.');
  }
  if (secret === undefined) {
    throw new CookieError('A secret is required to sign the value.');
  }
  if (isCookieValueSigned(value)) {
    throw new CookieError('Cannot sign a signed value.');
  }
  return `$$s$$:${cookieSignatureExports.sign(value, secret)}`;
};
/**
 * Unsign the cookie value.
 * @param value - The signed value.
 * @param secret - Secret for unsigning.
 */
const unsignCookieValue = (value, secret) => {
  if (typeof value !== 'string') {
    throw new CookieError('Can only unsign string value.');
  }
  if (!isCookieValueSigned(value)) {
    throw new CookieError('Cannot unsign a non signed value.');
  }
  if (secret === undefined) {
    throw new CookieError('A secret is required to unsign the value.');
  }
  return cookieSignatureExports.unsign(value.replace('$$s$$:', ''), secret);
};

/**
 * Class representing a Cookie.
 */
class Cookie {
  name;
  value;
  options;
  /**
   * Create a Cookie.
   * @param name - Cookie name.
   * @param value - Cookie value.
   * @param options - Cookie options.
   */
  static create(name, value, options = {}) {
    return new this(name, value, options);
  }
  /**
   * @param name - Cookie name.
   * @param value - Cookie value.
   * @param options - Cookie options.
   */
  constructor(name, value, options = {}) {
    this.name = name;
    this.value = value;
    this.options = options;
  }
  /**
   * Set expiration date for the cookie.
   * @param value - Expiration date.
   */
  setExpires(value) {
    this.options.expires = value;
    return this;
  }
  /**
   * Set secure flag for the cookie.
   * @param value - Whether the cookie is secure.
   */
  setSecure(value) {
    this.options.secure = value;
    return this;
  }
  /**
   * Serialize the cookie value.
   * @param secret - Optional secret for signing.
   */
  serialize(secret) {
    let value = this.value;
    if (!isCookieValueSerialized(value)) {
      value = typeof value === 'object' ? `$$j$$:${JSON.stringify(value)}` : String(value);
    }
    if (!isCookieValueSigned(value) && secret !== undefined) {
      value = signCookieValue(value, secret);
    }
    return distExports.serialize(this.name, String(value), this.options);
  }
  /**
   * Clone the cookie with new name, value, and options.
   * @param value - New cookie value.
   * @param options - New cookie options.
   * @returns A new cookie instance.
   */
  cloneWith(value, options = {}) {
    return new Cookie(this.name, value, {
      ...this.options,
      ...options
    });
  }
}

/**
 * Class representing a collection of Cookies.
 */
class CookieCollection {
  secret;
  options;
  cookies;
  /**
   * Create a CookieCollection.
   *
   * @param cookie - String cookie from header.
   * @param options - Cookies options.
   * @param secret - Secret value to sign and unsign cookies.
   */
  static create(cookie, options = {}, secret) {
    return new this(cookie, options, secret);
  }
  /**
   * Create a CookieCollection.
   *
   * @param cookie - String cookie from header.
   * @param options - Cookies options.
   * @param secret - Secret value to sign and unsign cookies.
   */
  constructor(cookie, options = {}, secret) {
    this.secret = secret;
    this.options = options;
    this.cookies = this.parse(cookie);
  }
  /**
   * Add a cookie to the collection.
   *
   * @param name - Cookie name.
   * @param value - Cookie value.
   * @param options - Cookie options.
   */
  add(name, value, options = {}) {
    this.cookies.set(name, Cookie.create(name, value, {
      ...this.options,
      ...options
    }));
    return this;
  }
  /**
   * Update a cookie in the collection.
   *
   * @param name - Cookie name.
   * @param value - New cookie value.
   * @param options - Cookie options.
   */
  update(name, value, options = {}) {
    const cookie = this.cookies.get(name);
    if (cookie !== undefined) {
      this.cookies.set(name, cookie.cloneWith(value, options));
    }
    return this;
  }
  /**
   * Get a cookie from the collection.
   *
   * @param name - Cookie name.
   * @param fallback - Fallback value if the cookie does not exist.
   */
  get(name, fallback) {
    return this.cookies.get(name) ?? fallback;
  }
  /**
   * Check if the collection has a cookie.
   *
   * @param name - Cookie name.
   */
  has(name) {
    return this.cookies.has(name);
  }
  /**
   * Remove a cookie from the collection.
   *
   * @param name - Cookie name to remove.
   * @param force - If true, remove only from collection without setting expiry.
   */
  remove(name, force = false) {
    if (force) {
      this.cookies.delete(name);
    } else {
      this.update(name, '', {
        expires: new Date(1)
      });
    }
    return this;
  }
  /**
   * Get all cookies in the collection.
   *
   * @param serialize - If true, serialize the cookies.
   */
  all(serialize = false) {
    const values = Array.from(this.cookies.values());
    return serialize ? values.map(v => v.serialize(this.secret)) : Object.fromEntries(values.map(v => [v.name, v.value]));
  }
  /**
   * Check if the collection is empty.
   */
  isEmpty() {
    return this.cookies.size === 0;
  }
  /**
   * Clear all cookies from the collection.
   *
   * @param force - If true, remove only from collection without setting expiry.
   */
  clear(force = false) {
    if (force) {
      this.cookies.clear();
    } else {
      this.cookies.forEach(v => this.update(v.name, '', {
        expires: new Date(1)
      }));
    }
    return this;
  }
  /**
   * Set secure flag for all cookies in the collection.
   *
   * @param value - Whether the cookies are secure.
   */
  secure(value = false) {
    this.cookies.forEach(v => v.setSecure(value));
    return this;
  }
  /**
   * Set secret for signing and unsigning cookies.
   *
   * @param value - Secret value.
   */
  setSecret(value) {
    this.secret = value;
    return this;
  }
  /**
   * Set options for all cookies in the collection.
   *
   * @param options - Cookie options.
   */
  setOptions(options) {
    this.options = options;
    this.cookies.forEach((cookie, name) => this.cookies.set(name, cookie.cloneWith(cookie.value, options)));
    return this;
  }
  /**
   * Parse the cookies from a string.
   *
   * @param cookie - String cookie from header.
   */
  parse(cookie) {
    if (typeof cookie !== 'string') {
      return new Map();
    }
    return new Map(Object.entries(distExports.parse(cookie)).map(([name, value]) => [name, this.deserializeCookieValue(name, value, this.options, this.secret)]));
  }
  /**
   * Deserialize the cookie value.
   *
   * @param name - Cookie name.
   * @param rawValue - Cookie raw value.
   * @param secret - Optional secret for unsigning.
   * @returns A new cookie instance.
   */
  deserializeCookieValue(name, rawValue, options, secret) {
    let value = rawValue;
    if (secret !== undefined && isCookieValueSigned(value)) {
      value = unsignCookieValue(value, secret);
      if (value === false) {
        throw new CookieError('Failed to unsign the value.');
      }
    }
    if (isCookieValueSerialized(value)) {
      value = JSON.parse(value.replace('$$j$$:', ''));
    }
    return Cookie.create(name, value, options);
  }
}

/**
 * InternalServer http error.
 */
class InternalServerError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'InternalServerError';
  }
}

/**
 * Class representing an Outgoing HTTP Response.
 * Extends the OutgoingResponse class and provides additional features
 * such as setting headers, cookies, and interacting with IncomingHttpEvent.
 */
class OutgoingHttpResponse extends OutgoingResponse {
  static OUTGOING_HTTP_RESPONSE = 'stonejs@outgoing_http_response';
  _charset;
  _formats;
  _incomingEventResolver;
  _blueprintResolver;
  _headers;
  _cookieCollection;
  /**
   * Create an instance of OutgoingHttpResponse.
   *
   * @param options - Options for the outgoing HTTP response.
   * @returns A new instance of OutgoingHttpResponse.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructor for OutgoingHttpResponse.
   * Initializes headers and cookies based on the provided options.
   *
   * @param options - Options for the outgoing HTTP response.
   */
  constructor(options) {
    super({
      ...options,
      type: OutgoingHttpResponse.OUTGOING_HTTP_RESPONSE
    });
    this._headers = new Headers();
    this._cookieCollection = CookieCollection.create();
    this.setHeaders(options.headers ?? {}).setStatus(options.statusCode ?? 200);
  }
  /**
   * Get the HTTP status code.
   *
   * @returns The HTTP status code.
   */
  get status() {
    return this.statusCode;
  }
  /**
   * Get the headers of the response.
   *
   * @returns The headers of the response as a Headers object.
   */
  get headers() {
    return this._headers;
  }
  /**
   * Get the character set encoding.
   * Defaults to 'utf-8' if not explicitly set.
   *
   * @returns The character set encoding.
   */
  get charset() {
    return this._charset ?? 'utf-8';
  }
  /**
   * Get the ETag of the response.
   *
   * @returns The value of the ETag header, if present.
   */
  get etag() {
    return this.getHeader('ETag');
  }
  /**
   * Get the Vary header as an array of values.
   *
   * @returns The Vary header values split by comma, or undefined if not present.
   */
  get vary() {
    return this.getHeader('Vary', '')?.split(/[\s,]+/);
  }
  /**
   * Get the Last-Modified date of the response.
   *
   * @returns The value of the Last-Modified header, if present.
   */
  get lastModified() {
    return this.getHeader('Last-Modified');
  }
  /**
   * Get the associated IncomingHttpEvent.
   *
   * @throws InternalServerError if the IncomingHttpEvent resolver is not set.
   * @returns The associated IncomingHttpEvent.
   */
  get incomingEvent() {
    if (this._incomingEventResolver === undefined) {
      throw new InternalServerError('Must set an IncomingHttpEvent resolver.');
    }
    return this._incomingEventResolver();
  }
  /**
   * Get the blueprint associated with the response.
   *
   * @returns The blueprint or undefined if not set.
   */
  get blueprint() {
    return this._blueprintResolver?.();
  }
  /**
   * Get the regular expression for matching charset in content type.
   *
   * @protected
   * @returns The regular expression for matching charset in content type.
   */
  get charsetRegExp() {
    return /;\s*charset\s*=/;
  }
  /**
   * Set multiple headers for the response.
   *
   * @param values - A key-value pair of headers to be set.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setHeaders(values) {
    const headers = values instanceof Headers || values instanceof Map ? Array.from(values.entries()) : Object.entries(values);
    headers.forEach(([key, value]) => this.setHeader(key, value));
    return this;
  }
  /**
   * Set a single header for the response.
   * If the header is "Content-Type," ensures charset is set appropriately.
   *
   * @param key - The header name.
   * @param value - The value of the header.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setHeader(key, value) {
    if (Array.isArray(value)) {
      value.forEach(v => this.appendHeader(key, v));
    } else if (key.toLowerCase() === 'content-type') {
      this.ensureCharset(value);
    } else {
      this._headers.set(key, value);
    }
    return this;
  }
  /**
   * Append a value to an existing header or create a new header.
   *
   * @param key - The header name.
   * @param value - The value to append.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  appendHeader(key, value) {
    const existingValue = this._headers.get(key);
    if (existingValue !== null) {
      this._headers.set(key, `${existingValue}, ${value}`);
    } else {
      this._headers.set(key, value);
    }
    return this;
  }
  /**
   * Get a header value.
   *
   * @param name - The header name.
   * @param fallback - A fallback value if the header is not found.
   * @returns The header value or the fallback value.
   */
  getHeader(name, fallback) {
    return this._headers.get(name) ?? fallback;
  }
  /**
   * Get all header names.
   *
   * @returns An array of all header names.
   */
  getHeaderNames() {
    return Array.from(this._headers.keys());
  }
  /**
   * Check if a specific header exists.
   *
   * @param key - The header name to check.
   * @returns True if the header exists, false otherwise.
   */
  hasHeader(key) {
    return this._headers.has(key);
  }
  /**
   * Remove headers from the response.
   *
   * @param key - The header or headers to be removed.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  removeHeader(key) {
    [].concat(key).forEach(header => this._headers.delete(header));
    return this;
  }
  /**
   * Set the HTTP status code of the response.
   * Also sets a default status message if none is provided.
   *
   * @param code - The HTTP status code.
   * @param text - Optional status message.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   * @throws InternalServerError if the status code is invalid.
   */
  setStatus(code, text) {
    if (code < 100 || code >= 600) {
      throw new InternalServerError(`The HTTP status code "${code}" is not valid.`);
    }
    this._statusCode = code;
    this._statusMessage = text ?? statuses$2.message[code] ?? 'unknown status';
    return this;
  }
  /**
   * Set the response content.
   * If the content should be JSON, it will be converted appropriately.
   *
   * @param value - The content to set.
   * @param options - The JSON options.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setContent(value, options = {}) {
    this._content = this.shouldBeJson(value) ? this.morphToJson(value, options) : value ?? '';
    return this;
  }
  /**
   * Set a cookie for the response.
   *
   * @param name - The name of the cookie.
   * @param value - The value of the cookie.
   * @param options - Optional settings for the cookie.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setCookie(name, value, options = {}) {
    if (!isString(name)) {
      throw new InternalServerError('Cookie name must be a non-empty string.');
    }
    this._cookieCollection.add(name, value, options);
    return this;
  }
  /**
   * Clear a specific cookie from the response.
   *
   * @param name - The name of the cookie to be cleared.
   * @param force - Whether to force the removal of the cookie, even if it doesn't exist.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  clearCookie(name, force = false) {
    if (!isString(name)) {
      throw new InternalServerError('Cookie name must be a non-empty string.');
    }
    this._cookieCollection.remove(name, force);
    return this;
  }
  /**
   * Clear all cookies from the response.
   *
   * @param force - Whether to force the removal of all cookies.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  clearCookies(force = false) {
    this._cookieCollection.clear(force);
    return this;
  }
  /**
   * Secure all cookies by setting the "Secure" attribute.
   *
   * @param value - Whether to set or unset the "Secure" attribute for cookies.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  secureCookies(value = true) {
    this._cookieCollection.secure(value);
    return this;
  }
  /**
   * Set the character set for the response.
   *
   * @param value - The character encoding to use.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setCharset(value) {
    this._charset = value;
    return this;
  }
  /**
   * Set the content type of the response.
   *
   * @param value - The MIME type for the response.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   * @throws InternalServerError if the provided MIME type is invalid.
   */
  setContentType(value) {
    const mimeType = isString(value) && value.includes('/') ? value : mime$1.getType(value) ?? undefined;
    if (mimeType !== undefined) {
      return this.setHeader('Content-Type', mimeType);
    } else {
      throw new InternalServerError(`Invalid MIME type: ${value}`);
    }
  }
  /**
   * Set the content type by file extension.
   *
   * @param value - The file extension.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setType(value) {
    return this.setContentType(value);
  }
  /**
   * Set link headers for the response.
   *
   * @param links - An object representing links to set.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setLinks(links) {
    const linkHeader = Object.entries(links).map(([key, val]) => `<${val}>; rel="${key}"`).join(', ');
    return this.setHeader('Link', linkHeader);
  }
  /**
   * Handles content negotiation based on the `Accept` header of the incoming request.
   *
   * @param formats - An object where keys are MIME types and values are functions that return the content for that MIME type.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  format(formats) {
    this._formats = formats;
    return this;
  }
  /**
   * Add a field to the Vary header.
   *
   * @param field - The field to add to the Vary header.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  addVary(field) {
    vary(this, field);
    return this;
  }
  /**
   * Set the ETag for the response.
   *
   * @param etag - The ETag value to set.
   * @param weak - Whether the ETag should be marked as weak.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setEtag(etag, weak = false) {
    if (etag === undefined) {
      this.removeHeader('ETag');
    } else {
      const formattedEtag = etag.startsWith('"') ? etag : `"${etag}"`;
      this.setHeader('ETag', `${weak ? 'W/' : ''}${formattedEtag}`);
    }
    return this;
  }
  /**
   * Set the Last-Modified header for the response.
   *
   * @param date - The date to set as the Last-Modified header.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setLastModified(date) {
    if (date === undefined) {
      this.removeHeader('Last-Modified');
    } else {
      this.setHeader('Last-Modified', date.toUTCString());
    }
    return this;
  }
  /**
   * Set the resolver for the incoming HTTP event.
   *
   * @param resolver - A function that returns the incoming HTTP event.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setIncomingEventResolver(resolver) {
    this._incomingEventResolver = resolver;
    return this;
  }
  /**
   * Set the resolver for the blueprint.
   *
   * @param resolver - A function that returns the blueprint.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  setBlueprintResolver(resolver) {
    this._blueprintResolver = resolver;
    return this;
  }
  /**
   * Check if the status code falls within the specified range.
   *
   * @param start - The starting value of the range (inclusive).
   * @param end - The ending value of the range (exclusive).
   * @returns True if the status code is within the specified range, otherwise false.
   */
  isInStatusRange(start, end) {
    const code = this.statusCode ?? 500;
    return code >= start && code < end;
  }
  /**
   * Check if the status code is invalid.
   *
   * @returns True if the status code is invalid, otherwise false.
   */
  isInvalid() {
    const code = this.statusCode ?? 500;
    return code < 100 || code >= 600;
  }
  /**
   * Check if the status code represents an informational response (1xx).
   *
   * @returns True if the status code is informational, otherwise false.
   */
  is1xx() {
    return this.isInStatusRange(100, 200);
  }
  /**
   * Check if the status code represents a successful response (2xx).
   *
   * @returns True if the status code is successful, otherwise false.
   */
  is2xx() {
    return this.isInStatusRange(200, 300);
  }
  /**
   * Check if the status code represents a redirection response (3xx).
   *
   * @returns True if the status code is a redirection, otherwise false.
   */
  is3xx() {
    return this.isInStatusRange(300, 400);
  }
  /**
   * Check if the status code represents a client error response (4xx).
   *
   * @returns True if the status code is a client error, otherwise false.
   */
  is4xx() {
    return this.isInStatusRange(400, 500);
  }
  /**
   * Check if the status code represents a server error response (5xx).
   *
   * @returns True if the status code is a server error, otherwise false.
   */
  is5xx() {
    return this.isInStatusRange(500, 600);
  }
  /**
   * Check if the status code is not an error (i.e., not 4xx or 5xx).
   *
   * @returns True if the status code is not an error, otherwise false.
   */
  isNotError() {
    return !this.isError();
  }
  /**
   * Check if the status code is an error (i.e., 4xx or 5xx).
   *
   * @returns True if the status code is an error, otherwise false.
   */
  isError() {
    return this.is4xx() || this.is5xx();
  }
  /**
   * Check if the status code is 200 (OK).
   *
   * @returns True if the status code is 200, otherwise false.
   */
  isOk() {
    return this.statusCode === 200;
  }
  /**
   * Check if the status code is 205 (Reset Content).
   *
   * @returns True if the status code is 205, otherwise false.
   */
  isResetContent() {
    return this.statusCode === 205;
  }
  /**
   * Check if the response is empty.
   *
   * @returns True if the status code indicates an empty response, otherwise false.
   */
  isEmpty() {
    return [204, 304].includes(this.statusCode ?? 500);
  }
  /**
   * Check if the response is a redirect.
   *
   * @param location - The optional location to check for redirection.
   * @returns True if the status code indicates a redirect, otherwise false.
   */
  isRedirect(location) {
    const code = this.statusCode ?? 500;
    return [301, 302, 303, 307, 308].includes(code) && (location === undefined || this.getHeader('Location') === undefined);
  }
  /**
   * Check if the status code is 301 (Moved Permanently).
   *
   * @returns True if the status code is 301, otherwise false.
   */
  isMovedPermanently() {
    return this.statusCode === 301;
  }
  /**
   * Check if the status code is 401 (Unauthorized).
   *
   * @returns True if the status code is 401, otherwise false.
   */
  isUnauthorized() {
    return this.statusCode === 401;
  }
  /**
   * Check if the status code is 403 (Forbidden).
   *
   * @returns True if the status code is 403, otherwise false.
   */
  isForbidden() {
    return this.statusCode === 403;
  }
  /**
   * Check if the status code is 404 (Not Found).
   *
   * @returns True if the status code is 404, otherwise false.
   */
  isNotFound() {
    return this.statusCode === 404;
  }
  /**
   * Check if the response is validateable.
   *
   * @returns True if the response has Last-Modified or ETag headers, otherwise false.
   */
  isValidateable() {
    return this.hasHeader('Last-Modified') || this.hasHeader('ETag');
  }
  /**
   * Prepare the response before sending.
   *
   * @param event - The incoming HTTP event.
   * @param container - The service container.
   * @returns The current instance of the response for chaining.
   */
  prepare(event, container) {
    return this.setBlueprintResolver(() => container?.make('blueprint')).setIncomingEventResolver(() => event).handleContentNegotiation().prepareCookies().setContentTypeIfNeeded().handleCacheHeaders().prepareContentHeaders();
  }
  /**
   * Handles content negotiation based on the `Accept` header of the incoming request.
   *
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  handleContentNegotiation() {
    if (this._formats === undefined) return this;
    const types = Object.keys(this._formats).filter(v => v !== 'default');
    const type = types.length > 0 ? this.incomingEvent.acceptsTypes(...types) : undefined;
    if (isString(type) && this._formats[type] !== undefined) {
      this.setContentType(type).setContent(this._formats[type]());
    } else if (this._formats.default !== undefined) {
      this.setContent(this._formats.default());
    } else {
      this.setStatus(HTTP_NOT_ACCEPTABLE).setContent(`Invalid types (${types.join(',')})`);
    }
    return this.addVary('Accept');
  }
  /**
   * Set the content type if it's not already set.
   *
   * @returns The current instance of the response for chaining.
   */
  setContentTypeIfNeeded() {
    if (!this.hasHeader('Content-Type')) {
      switch (typeof this.content) {
        case 'string':
          this.setContentType('html');
          break;
        case 'object':
        case 'number':
        case 'boolean':
          if (safeBufferExports.Buffer.isBuffer(this.content)) {
            this.setContentType('bin');
          } else {
            this.setContentType('json');
            this.setContent(this.content, this.blueprint?.get('stone.http.json', {}));
          }
          break;
      }
    }
    return this;
  }
  /**
   * Handle cache headers like ETag and Last-Modified.
   *
   * @returns The current instance of the response for chaining.
   */
  handleCacheHeaders() {
    if (this.incomingEvent.isFresh(this)) {
      this.setStatus(HTTP_NOT_MODIFIED);
    }
    return this;
  }
  /**
   * Prepare content-related headers such as Content-Length and ETag.
   *
   * @returns The current instance of the response for chaining.
   */
  prepareContentHeaders() {
    if (this.is1xx() || this.isEmpty()) {
      this.setContent(undefined).removeHeader(['Content-Type', 'Content-Length', 'Transfer-Encoding']);
    } else if (this.isResetContent()) {
      this.setContent(undefined).setHeader('Content-Length', '0').removeHeader('Transfer-Encoding');
    } else {
      this.setContentHeaders();
    }
    return this;
  }
  /**
   * Set content headers such as Content-Length and ETag.
   *
   * @returns The current instance of the response for chaining.
   */
  setContentHeaders() {
    let length = 0;
    const type = this.getHeader('Content-Type');
    const etagFn = this.blueprint?.get('stone.http.etag.function', this.defaultEtagFn.bind(this));
    const generateETag = !this.hasHeader('ETag') && isFunction(etagFn);
    if (isString(this.content) && isString(type) && !this.charsetRegExp.test(type)) {
      this.setContentType(`${type}; charset=${String(this.charset)}`);
    }
    if (this.content !== undefined) {
      length = this.calculateContentLength(generateETag);
      this.setHeader('Content-Length', String(length));
    }
    if (generateETag && length > 0) {
      this.setEtag(etagFn(String(this.content), this.charset));
    }
    if (this.hasHeader('Transfer-Encoding')) {
      this.removeHeader('Content-Length');
    }
    if (this.incomingEvent.isMethod('HEAD')) {
      this.setContent(null);
    }
    return this;
  }
  /**
   * Calculate the content length.
   *
   * @param generateETag - Whether to generate an ETag for the content.
   * @returns The content length.
   */
  calculateContentLength(generateETag) {
    if (safeBufferExports.Buffer.isBuffer(this.content)) {
      return this.content.length;
    } else if (!generateETag && isString(this.content) && this.content.length < 1000) {
      return safeBufferExports.Buffer.byteLength(this.content, this.charset);
    } else {
      this._content = safeBufferExports.Buffer.from(String(this.content), this.charset);
      this._charset = undefined;
      return this._content.length;
    }
  }
  /**
   * Ensure that the "Content-Type" header has a charset specified.
   *
   * @param value - The "Content-Type" header value.
   * @returns The current instance of OutgoingHttpResponse for chaining.
   */
  ensureCharset(value) {
    if (!this.charsetRegExp.test(value)) {
      const type = value?.split(';')?.shift() ?? 'text/html';
      this.setCharset(contentTypeLib.parse(type.trim()).parameters.charset ?? 'UTF-8').setContentType(`${type}; charset=${this.charset.toLowerCase()}`);
    } else {
      this._headers.set('Content-Type', value);
    }
    return this;
  }
  /**
   * Determine if the content should be serialized as JSON.
   *
   * @param content - The content to check.
   * @returns True if the content should be serialized as JSON, otherwise false.
   */
  shouldBeJson(content) {
    return !safeBufferExports.Buffer.isBuffer(content) && ['object', 'number', 'boolean'].includes(typeof content);
  }
  /**
   * Convert the given content to a JSON string.
   *
   * @param content - The content to convert.
   * @param options - Options to customize the serialization process.
   * @returns A JSON string representation of the content.
   * @throws InternalServerError if the content cannot be converted to JSON.
   */
  morphToJson(content, options = {}) {
    try {
      return this.stringify(content, options.replacer, options.spaces, options.escape);
    } catch (error) {
      throw new InternalServerError(error.message, {
        cause: error
      });
    }
  }
  /**
   * Prepare cookies by setting the appropriate headers.
   *
   * @returns The current instance of the response for chaining.
   */
  prepareCookies() {
    if (!this._cookieCollection.isEmpty()) {
      this._cookieCollection.setSecret(this.blueprint?.get('stone.secret') ?? '').setOptions(this.blueprint?.get('stone.http.cookie.options') ?? {});
      if (this.incomingEvent.isSecure) {
        this.secureCookies(true);
      }
      this.setHeader('Set-Cookie', this._cookieCollection.all(true));
    }
    return this;
  }
  /**
   * Generate a default ETag for the given content.
   *
   * @param content - The content to generate an ETag for.
   * @param encoding - The encoding to use.
   * @returns The generated ETag as a base64 string.
   */
  defaultEtagFn(content, encoding) {
    return safeBufferExports.Buffer.from(this.getHashedContent(content, encoding)).toString('base64');
  }
  /**
   * Get the hashed content using the specified encoding.
   *
   * @param content - The content to hash.
   * @param encoding - The encoding to use for hashing.
   * @returns The hashed content as a hexadecimal string.
   */
  getHashedContent(content, encoding) {
    return createHash('sha256').update(content, encoding).digest('hex');
  }
  /**
   * Convert the given value to a JSON string with optional escaping.
   *
   * @param value - The value to convert.
   * @param replacer - A function or array that alters the behavior of the stringification process.
   * @param spaces - The number of spaces to use for pretty-printing the JSON string.
   * @param escape - Whether to escape special characters.
   * @returns The JSON string representation of the value.
   */
  stringify(value, replacer, spaces, escape) {
    const json = JSON.stringify(value, replacer, spaces);
    if (escape === true) {
      return json.replace(/[<>&]/g, c => ({
        '<': '\u003c',
        '>': '\u003e',
        '&': '\u0026'
      })[c]);
    }
    return json;
  }
}

/**
 * Class representing a BinaryFileResponse.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class BinaryFileResponse extends OutgoingHttpResponse {
  file;
  deleteFileAfterSent = false;
  /**
   * Create a BinaryFileResponse with inline content disposition.
   *
   * @param options - Options for creating the BinaryFileResponse.
   * @returns A new instance of BinaryFileResponse.
   */
  static file(options) {
    return new this({
      ...options,
      contentDispositionType: 'inline'
    });
  }
  /**
   * Create a BinaryFileResponse with attachment content disposition.
   *
   * @param options - Options for creating the BinaryFileResponse.
   * @returns A new instance of BinaryFileResponse.
   */
  static download(options) {
    return new this({
      ...options,
      contentDispositionType: 'attachment'
    });
  }
  /**
   * Create a BinaryFileResponse.
   *
   * @param options - Options for creating the BinaryFileResponse.
   */
  constructor(options) {
    super(options);
    this.file = this.getValidatedFile(options.file);
    options.autoEtag === true && this.autoEtag();
    options.autoEncoding === true && this.autoEncoding();
    options.autoLastModified === true && this.autoLastModified();
    this.setContentDisposition(options.contentDispositionType);
  }
  /**
   * Get deleteFileAfterSent.
   *
   * @returns Whether the file should be deleted after being sent.
   */
  get deleteFileAfterSentStatus() {
    return this.deleteFileAfterSent;
  }
  /**
   * Get the encoded file path.
   *
   * @returns The encoded file path.
   */
  getEncodedFilePath() {
    return this.file.getEncodedPath();
  }
  /**
   * Automatically set the ETag header based on the file's content.
   *
   * @returns The current instance for method chaining.
   */
  autoEtag() {
    return this.setEtag(safeBufferExports.Buffer.from(this.file.getHashedContent()).toString('base64'));
  }
  /**
   * Automatically set the Last-Modified header based on the file's modification time.
   *
   * @returns The current instance for method chaining.
   */
  autoLastModified() {
    return this.setLastModified(new Date(Number(this.file.getMTime() ?? Date.now())));
  }
  /**
   * Automatically set the Content-Encoding header based on the file's extension.
   *
   * @returns The current instance for method chaining.
   */
  autoEncoding() {
    const encoding = {
      '.br': 'br',
      '.brotli': 'br',
      '.gzip': 'gzip'
    };
    if (this.file.isCompressed(Object.keys(encoding))) {
      return this.setHeader('Content-Encoding', encoding[this.file.getExtension()]);
    }
    return this;
  }
  /**
   * Set the content disposition header.
   *
   * @param type - The content disposition type (e.g., 'inline', 'attachment').
   * @returns The current instance for method chaining.
   */
  setContentDisposition(type) {
    return this.setHeader('Content-Disposition', contentDisposition(this.file.getPath(), {
      type
    })).setHeader('Content-Type', this.file.getMimeType() ?? 'application/octet-stream');
  }
  /**
   * Set the content of the response.
   *
   * @param content - The content to set (should be empty for BinaryFileResponse).
   * @returns The current instance for method chaining.
   * @throws TypeError if content is provided.
   */
  setContent(content) {
    if (content !== undefined) {
      throw new FilesystemError('The content cannot be set on a BinaryFileResponse instance.');
    }
    return this;
  }
  /**
   * Get the content of the response.
   *
   * @returns False, as content cannot be set for BinaryFileResponse.
   */
  getContent() {
    return false;
  }
  /**
   * Set whether the file should be deleted after being sent.
   *
   * @param shouldDelete - Whether to delete the file after being sent.
   * @returns The current instance for method chaining.
   */
  setDeleteFileAfterSent(shouldDelete = true) {
    this.deleteFileAfterSent = shouldDelete;
    return this;
  }
  /**
   * Prepare the response before sending.
   *
   * @param event - The incoming HTTP event.
   * @param container - The service container.
   * @returns The current instance of the response for chaining.
   */
  prepare(event, container) {
    this.setBlueprintResolver(() => container?.make('blueprint')).setIncomingEventResolver(() => event).prepareCookies();
    if (this.incomingEvent.isFresh(this)) {
      this.setStatus(HTTP_NOT_MODIFIED);
    }
    if (this.is1xx() || this.isEmpty()) {
      this.removeHeader(['Content-Type', 'Content-Length', 'Transfer-Encoding']);
    } else {
      this.prepareContentHeaders();
    }
    return this;
  }
  /**
   * Prepare content-related headers.
   *
   * @returns The current instance for method chaining.
   */
  prepareContentHeaders() {
    const fileSize = this.file.getSize();
    if (fileSize === undefined) return this;
    const etagFn = this.blueprint?.get('stone.http.etag.function', this.defaultEtagFn.bind(this));
    this.removeHeader('Transfer-Encoding').setHeader('Content-Length', String(fileSize));
    if (!this.hasHeader('ETag') && typeof etagFn === 'function') {
      this.setEtag(etagFn(this.file.getContent(), 'utf-8'));
    }
    if (!this.hasHeader('Content-Type')) {
      this.setHeader('Content-Type', this.file.getMimeType() ?? 'application/octet-stream');
    }
    return this;
  }
  /**
   * Validate the file to be served.
   *
   * @param file - The file to be served.
   * @returns The validated file instance.
   */
  getValidatedFile(file) {
    if (file === undefined) {
      throw new FilesystemError('file argument is required.');
    }
    if (!(file instanceof File)) {
      file = File.create(String(file));
    }
    if (!file.isReadable()) {
      throw new FilesystemError('File must be readable.');
    }
    return file;
  }
}

/**
 * Class representing an HttpError.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class HttpError extends RuntimeError {
  statusCode;
  headers;
  statusMessage;
  /**
   * Create an HttpError.
   *
   * @param message - The message to log.
   * @param options - The error options.
   */
  constructor(message, statusCode = 500, headers = new Headers(), options = {}) {
    super(message, options);
    this.name = 'HttpError';
    this.headers = headers;
    this.statusCode = statusCode;
    this.statusMessage = statuses$2.message[this.statusCode] ?? 'Unknown Status';
  }
}

/**
 * Create an OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param statusCode - The status code of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const createHttpResponse = (content, statusCode = HTTP_OK, headers = {}) => {
  return OutgoingHttpResponse.create({
    content,
    statusCode,
    headers
  });
};
/**
 * Create a 400(Bad Request) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const badRequestHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_BAD_REQUEST, headers);
};
/**
 * Create a 401(Unauthorized) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const unauthorizedHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_UNAUTHORIZED, headers);
};
/**
 * Create a 403(Forbidden) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const forbiddenHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_FORBIDDEN, headers);
};
/**
 * Create a 404(Not Found) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const notFoundHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_NOT_FOUND, headers);
};
/**
 * Create a 405(Method Not Allowed) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const methodNotAllowedHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_METHOD_NOT_ALLOWED, headers);
};
/**
 * Create a 500(Internal Server Error) OutgoingHttpResponse.
 *
 * @param content - The content of the response.
 * @param headers - The headers for the response.
 * @returns A new instance of OutgoingHttpResponse.
 */
const serverErrorHttpResponse = (content, headers = {}) => {
  return createHttpResponse(content, HTTP_INTERNAL_SERVER_ERROR, headers);
};

/**
 * Class representing an HttpErrorHandler.
 */
class HttpErrorHandler {
  logger;
  /**
   * Create an HttpErrorHandler.
   *
   * @param options - HttpErrorHandler options.
   */
  constructor({
    logger
  }) {
    if (logger === undefined) {
      throw new IntegrationError('Logger is required to create an HttpErrorHandler instance.');
    }
    this.logger = logger;
  }
  /**
   * Handle an error.
   *
   * @param error - The error to handle.
   * @param event - The incoming http event.
   * @returns The outgoing http response.
   */
  handle(error, event) {
    const httpError = error;
    const message = error => event.is(['json']) === false ? error : {
      error
    };
    this.logger.error(error.message, {
      error
    });
    const response = {
      NotFoundError: () => notFoundHttpResponse(message('Not Found')),
      ForbiddenError: () => forbiddenHttpResponse(message('Forbidden')),
      BadRequestError: () => badRequestHttpResponse(message('Bad Request')),
      UnauthorizedError: () => unauthorizedHttpResponse(message('Unauthorized')),
      MethodNotAllowedError: () => methodNotAllowedHttpResponse(message('Method Not Allowed')),
      HttpError: () => createHttpResponse(message(httpError.statusMessage), httpError.statusCode, httpError.headers)
    }[error.name] ?? (() => serverErrorHttpResponse(message('Internal Server Error')));
    return response();
  }
}

/**
 * Enum representing possible values for the `SameSite` attribute in cookies.
 */
var CookieSameSite;
(function (CookieSameSite) {
  CookieSameSite["Lax"] = "lax";
  CookieSameSite["None"] = "none";
  CookieSameSite["Strict"] = "strict";
})(CookieSameSite || (CookieSameSite = {}));
/**
 * Enum representing standard HTTP methods.
 */
var HttpMethods;
(function (HttpMethods) {
  HttpMethods["GET"] = "GET";
  HttpMethods["PUT"] = "PUT";
  HttpMethods["HEAD"] = "HEAD";
  HttpMethods["POST"] = "POST";
  HttpMethods["PATCH"] = "PATCH";
  HttpMethods["DELETE"] = "DELETE";
  HttpMethods["OPTIONS"] = "OPTIONS";
})(HttpMethods || (HttpMethods = {}));

/**
 * Class representing an IncomingHttpEvent.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class IncomingHttpEvent extends IncomingEvent {
  static INCOMING_HTTP_EVENT = 'stonejs@incoming_http_event';
  /** The IP address of the client making the request. */
  ip;
  /** The list of IP addresses, typically for proxies. */
  ips;
  /** The URL of the request. */
  url;
  /** The body of the request. */
  body;
  /** The files included in the request. */
  files;
  /** The query parameters of the request. */
  query;
  /** The HTTP method of the request. */
  method;
  /** The content negotiation handler for the request. */
  accepts;
  /** The headers of the request. */
  _headers;
  /** The cookies included in the request. */
  cookies;
  /** The protocol used for the request (e.g., http or https). */
  protocol;
  /** The query string of the request. */
  queryString;
  userResolver;
  routeResolver;
  /**
   * Create an IncomingHttpEvent.
   *
   * @param options - The IncomingHttpEvent options.
   * @returns A new instance of IncomingHttpEvent.
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructor for IncomingHttpEvent.
   *
   * @param options - The options to create an IncomingHttpEvent instance.
   * @throws {HttpError} If the URL option is not a valid instance of URL.
   */
  constructor({
    ip,
    url,
    source,
    ips = [],
    body = {},
    files = {},
    locale = 'en',
    headers = {},
    metadata = {},
    protocol = 'http',
    cookies = undefined,
    queryString = undefined,
    method = HttpMethods.GET
  }) {
    super({
      type: IncomingHttpEvent.INCOMING_HTTP_EVENT,
      source,
      metadata,
      locale
    });
    if (!(url instanceof URL$1)) {
      throw new HttpError('The `url` option must be an instance of `URL`.');
    }
    this.ip = ip;
    this.ips = ips;
    this.url = url;
    this.body = body;
    this.files = files;
    this.method = method;
    this.protocol = protocol;
    this.queryString = queryString;
    this.cookies = cookies ?? CookieCollection.create();
    this.query = new URLSearchParams(this.queryString ?? '');
    this._headers = headers instanceof Headers ? headers : new Headers(headers);
    // Must be called after the headers are set
    this.accepts = accepts$2(this);
  }
  /** @returns The headers of the request. */
  get headers() {
    return Object.fromEntries(this._headers.entries());
  }
  /** @returns The decoded pathname of the URL. */
  get decodedPathname() {
    try {
      return decodeURIComponent(this.url.pathname);
    } catch (_) {
      return undefined;
    }
  }
  /** @returns The hash part of the URL. */
  get hash() {
    return this.url.hash;
  }
  /** @returns The host of the URL (hostname:port). */
  get host() {
    return this.url.host;
  }
  /** @returns The hostname of the URL. */
  get hostname() {
    return this.url.hostname;
  }
  /** @returns The route parameters. */
  get params() {
    return this.getRoute()?.params;
  }
  /** @returns The full path including pathname and search query. */
  get path() {
    return `${this.url.pathname}${this.url.search}`;
  }
  /** @returns The pathname of the URL. */
  get pathname() {
    return this.url.pathname;
  }
  /** @returns The full URL as a string. */
  get uri() {
    return this.url.href;
  }
  /** @returns The protocol of the URL (e.g., "http" or "https"). */
  get scheme() {
    return this.protocol;
  }
  /** @returns The URL segments split by '/'. */
  get segments() {
    return this.url.pathname.split('/');
  }
  /** @returns Whether the request was made over a secure connection. */
  get isSecure() {
    return this.protocol === 'https';
  }
  /** @returns Whether the request is an XMLHttpRequest. */
  get isXhr() {
    return this.getHeader('X-Requested-With', '')?.toLowerCase() === 'xmlhttprequest';
  }
  /** @returns Whether the request is an AJAX request. */
  get isAjax() {
    return this.isXhr;
  }
  /** @returns The user agent of the request. */
  get userAgent() {
    return this.getHeader('user-agent');
  }
  /** @returns Whether the request was prefetch. */
  get isPrefetch() {
    return ['prefetch'].includes(this.getHeader('Purpose') ?? this.getHeader('Sec-Purpose') ?? '');
  }
  /** @returns The ETag of the request, if present. */
  get etag() {
    return this.getHeader('ETag');
  }
  /** @returns An array of acceptable content types for the request. */
  get types() {
    return this.accepts.types();
  }
  /** @returns An array of acceptable character sets for the request. */
  get charsets() {
    return this.accepts.charsets();
  }
  /** @returns An array of acceptable languages for the request. */
  get languages() {
    return this.accepts.languages();
  }
  /** @returns An array of acceptable encodings for the request. */
  get encodings() {
    return this.accepts.encodings();
  }
  /** @returns The charset specified in the content-type header. */
  get charset() {
    return contentTypeLib.parse(this).parameters.charset;
  }
  /** @returns The content type specified in the headers. */
  get contentType() {
    return contentTypeLib.parse(this._headers.get('content-type') ?? 'text/html').type;
  }
  /**
   * Get data from the request.
   *
   * Priority:
   * 1. Route params
   * 2. Body
   * 3. Query params
   * 4. Headers
   * 5. Cookies
   * 6. Metadata
   * 7. Fallback value
   *
   * @param key - The key to look for.
   * @param fallback - A fallback value if the key is not found.
   * @returns The value of the key or the fallback.
  */
  get(key, fallback) {
    return this.getParam(key) ?? this.getFromBody(key) ?? this.getFromQueryParams(key) ?? this.getFromHeaders(key) ?? this.getFromCookies(key) ?? this.getMetadataValue(key, fallback);
  }
  /**
   * Get a header value.
   *
   * @param name - The header name.
   * @param fallback - A fallback value if the header is not found.
   * @returns The header value or the fallback value.
   * @throws {HttpError} If the header name is not a valid string.
   */
  getHeader(name, fallback) {
    if (!this.isValidName(name)) {
      throw new HttpError('Header name must be a non-empty string.');
    }
    const lcName = name.toLowerCase();
    if (['referer', 'referrer'].includes(lcName)) {
      return this._headers.get('referer') ?? this._headers.get('referrer') ?? fallback;
    }
    return this._headers.get(lcName) ?? fallback;
  }
  /**
   * Check if a header exists.
   *
   * @param name - The header name to check.
   * @returns True if the header exists, otherwise false.
   */
  hasHeader(name) {
    if (!this.isValidName(name)) {
      throw new HttpError('Header name must be a non-empty string.');
    }
    return this._headers.has(name.toLowerCase());
  }
  /**
   * Get a cookie value.
   *
   * @param name - The cookie name.
   * @param fallback - A fallback value if the cookie is not found.
   * @returns The cookie value or the fallback.
   */
  getCookie(name, fallback) {
    if (!this.isValidName(name)) {
      throw new HttpError('Cookie name must be a non-empty string.');
    }
    return this.cookies.get(name) ?? this.cookies.get(name.toLowerCase()) ?? fallback;
  }
  /**
   * Check if a cookie exists.
   *
   * @param name - The cookie name to check.
   * @returns True if the cookie exists, otherwise false.
   */
  hasCookie(name) {
    if (!this.isValidName(name)) {
      throw new HttpError('Cookie name must be a non-empty string.');
    }
    return this.cookies.has(name) || this.cookies.has(name.toLowerCase());
  }
  /**
   * Return the first accepted content type.
   *
   * @param values - The content types to check.
   * @returns The first accepted type, or false if none are accepted.
   */
  acceptsTypes(...values) {
    return this.accepts.type(values.flat());
  }
  /**
   * Return the first accepted encoding.
   *
   * @param values - The encodings to check.
   * @returns The first accepted encoding, or false if none are accepted.
   */
  acceptsEncodings(...values) {
    return this.accepts.encoding(values.flat());
  }
  /**
   * Return the first accepted charset.
   *
   * @param values - The charsets to check.
   * @returns The first accepted charset, or false if none are accepted.
   */
  acceptsCharsets(...values) {
    return this.accepts.charset(values.flat());
  }
  /**
   * Return the first accepted language.
   *
   * @param values - The languages to check.
   * @returns The first accepted language, or false if none are accepted.
   */
  acceptsLanguages(...values) {
    return this.accepts.language(values.flat());
  }
  /**
   * Get MIME type for a given file path or extension.
   *
   * @param format - The file path or extension.
   * @returns The corresponding MIME type, or undefined if not found.
   */
  getMimeType(format) {
    return mime$1.getType(format) ?? undefined;
  }
  /**
   * Get file extension for a given MIME type.
   *
   * @param mimeType - The MIME type.
   * @returns The corresponding file extension, or undefined if not found.
   */
  getFormat(mimeType) {
    return mime$1.getExtension(mimeType) ?? undefined;
  }
  /**
   * Check if the request matches one of the given content types.
   *
   * @param types - The content types to check.
   * @returns The best match, or false if no match is found.
   */
  is(types) {
    return typeIs$2.is(this.contentType, types.flat());
  }
  /**
   * Get request range.
   *
   * @param size - The maximum size of the resource.
   * @param combine - Specifies if overlapping & adjacent ranges should be combined.
   * @returns The parsed range, or undefined if not applicable.
   */
  range(size, combine = false) {
    if (!this.hasHeader('Range')) return;
    return rangeParser(size, this.getHeader('Range', ''), {
      combine
    });
  }
  /**
   * Get a value from the JSON body.
   *
   * @param key - The key to look for in the JSON body.
   * @param fallback - A fallback value if the key is not found.
   * @returns The value of the key or the fallback.
   */
  json(key, fallback) {
    if (this.hasJson(key)) {
      return get$1(this.body, key, fallback);
    }
    return fallback;
  }
  /**
   * Check if a key exists in the JSON body.
   *
   * @param key - The key to check for.
   * @returns True if the key exists, otherwise false.
   */
  hasJson(key) {
    return this.is(['json']) === 'json' && has(this.body, key);
  }
  /**
   * Determine if the response cache is fresh.
   *
   * @param response - The outgoing HTTP response to check freshness against.
   * @returns True if the cache is fresh, otherwise false.
   */
  isFresh(response) {
    const status = response.status ?? 500;
    return ['GET', 'HEAD'].includes(this.method) && (status >= 200 && status < 300 || status === 304) && fresh(this.headers, {
      etag: response.etag,
      'last-modified': response.lastModified
    });
  }
  /**
   * Determine if the response cache is stale.
   *
   * @param response - The outgoing HTTP response to check staleness against.
   * @returns True if the cache is stale, otherwise false.
   */
  isStale(response) {
    return !this.isFresh(response);
  }
  /**
   * Filter and return files based on their names.
   *
   * @param files - The array of file names to filter.
   * @returns An object containing the filtered files.
   */
  filterFiles(files) {
    return Object.fromEntries(Object.entries(this.files).filter(([key]) => files.includes(key)));
  }
  /**
   * Get a file by its name.
   *
   * @param name - The name of the file.
   * @returns The file if it exists, otherwise undefined.
   */
  getFile(name) {
    return this.files[name];
  }
  /**
   * Check if a file exists by its name.
   *
   * @param name - The name of the file.
   * @returns True if the file exists, otherwise false.
   */
  hasFile(name) {
    return name in this.files && this.files[name].length > 0;
  }
  /**
   * Check if the current event method matches the given method.
   *
   * @param method - The method to check.
   * @returns True if the event method matches, otherwise false.
   */
  isMethod(method) {
    return this.method.toUpperCase() === method.toUpperCase();
  }
  /**
   * Check if the current event method is considered safe.
   *
   * @returns True if the method is safe, otherwise false.
   */
  isMethodSafe() {
    return ['GET', 'HEAD', 'OPTIONS', 'TRACE'].includes(this.method);
  }
  /**
   * Check if the current event method is cacheable.
   *
   * @returns True if the method is cacheable, otherwise false.
   */
  isMethodCacheable() {
    return ['GET', 'HEAD'].includes(this.method);
  }
  /**
   * Generate a full URL for the given path.
   *
   * @param path - The path to append to the base URL.
   * @returns The full URL for the given path.
   */
  uriForPath(path) {
    return new URL$1(path, this.uri).href;
  }
  /**
   * Get the URI with or without the domain.
   *
   * @param withDomain - Whether to include the domain in the URI.
   * @returns The URI with or without the domain.
   */
  getUri(withDomain = false) {
    return withDomain ? new URL$1(this.decodedPathname ?? '/', this.uri).href : this.decodedPathname;
  }
  /**
   * Get the user instance.
   *
   * @returns The user object, resolved through a user resolver function if available.
   */
  getUser() {
    return this.userResolver?.();
  }
  /**
   * Get the user resolver function.
   *
   * @returns The user resolver function.
   */
  getUserResolver() {
    return this.userResolver ?? (() => undefined);
  }
  /**
   * Set the user resolver function.
   *
   * @param resolver - The user resolver function.
   * @returns The current instance for method chaining.
   */
  setUserResolver(resolver) {
    this.userResolver = resolver;
    return this;
  }
  /**
   * Get the route resolver function.
   *
   * @returns The route resolver function.
   */
  getRouteResolver() {
    return this.routeResolver ?? (() => undefined);
  }
  /**
   * Set the route resolver function.
   *
   * @param resolver - The route resolver function.
   * @returns The current instance for method chaining.
   */
  setRouteResolver(resolver) {
    this.routeResolver = resolver;
    return this;
  }
  /**
   * Return the current route or a route parameter.
   *
   * @returns The route parameter or the route object.
   */
  getRoute() {
    return this.routeResolver?.();
  }
  /**
   * Generate a unique fingerprint for the event.
   *
   * @returns The generated fingerprint as a base64 string.
   */
  fingerprint() {
    const route = this.getRoute();
    if (typeof route !== 'object') {
      throw new HttpError('Unable to generate fingerprint. Route unavailable.');
    }
    return Buffer.from([route.method, route.uri, this.userAgent, this.ip].join('|')).toString('base64');
  }
  /**
   * Retrieve a parameter from the route if it exists.
   *
   * @param name - The name of the parameter to retrieve.
   * @param fallback - The fallback value if the parameter does not exist.
   * @returns The value of the parameter if it exists, otherwise undefined.
   */
  getParam(name, fallback) {
    return this.getRoute()?.getParam?.(name, fallback);
  }
  /**
   * Retrieve a value from the request body.
   *
   * @param key - The key of the value to retrieve.
   * @returns The value from the body if it exists, otherwise undefined.
   */
  getFromBody(key) {
    return has(this.body, key) ? get$1(this.body, key) : undefined;
  }
  /**
   * Retrieve a value from the query parameters.
   *
   * @param key - The key of the value to retrieve.
   * @returns The value from the query parameters if it exists, otherwise undefined.
   */
  getFromQueryParams(key) {
    return this.query.get(key) ?? undefined;
  }
  /**
   * Retrieve a value from the request headers.
   *
   * @param key - The name of the header to retrieve.
   * @returns The value of the header if it exists, otherwise undefined.
   */
  getFromHeaders(key) {
    return this.hasHeader(key) ? this.getHeader(key) : undefined;
  }
  /**
   * Retrieve a value from the cookies.
   *
   * @param key - The name of the cookie to retrieve.
   * @returns The value of the cookie if it exists, otherwise undefined.
   */
  getFromCookies(key) {
    return this.getCookie(key)?.value ?? undefined;
  }
  /**
   * Validate the provided name.
   *
   * @param name - The name to validate.
   * @returns True if the name is valid, otherwise false.
   */
  isValidName(name) {
    return typeof name === 'string' && name.trim() !== '';
  }
}

/**
 * NotFound http error.
 */
class NotFoundError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'NotFoundError';
  }
}

/**
 * BadRequestError http error.
 */
class BadRequestError extends RuntimeError {
  constructor(message, options = {}) {
    super(message, options);
    this.name = 'BadRequestError';
  }
}
/**
 * Check if multipart message.
 *
 * @param value - The incoming message or content type string.
 * @returns True if the content type is multipart.
 */
function isMultipart(value) {
  return typeof value === 'string' ? typeIs$2.is(value, ['multipart']) === 'multipart' : typeIs$2(value, ['multipart']) === 'multipart';
}
/**
 * Get message content charset.
 *
 * @param value - The incoming message or content type string.
 * @param fallback - Fallback charset if parsing fails.
 * @returns The charset of the message.
 */
function getCharset(value, fallback = 'utf-8') {
  try {
    return contentTypeLib.parse(value).parameters.charset;
  } catch (_) {
    return fallback;
  }
}
/**
 * Check if IP is trusted or not.
 *
 * @param trusted - Array of trusted IPs or wildcard.
 * @param untrusted - Array of untrusted IPs or wildcard.
 * @returns A function to verify if a given IP is trusted.
 */
function isIpTrusted(trusted, untrusted = []) {
  return ip => {
    if (untrusted.includes('*') || ipRangeCheck(ip, untrusted)) {
      return false;
    }
    return trusted.includes('*') || ipRangeCheck(ip, trusted);
  };
}
/**
 * Get protocol.
 *
 * @param ip - The IP address of the request.
 * @param headers - The headers from the incoming request.
 * @param encrypted - Whether the connection is encrypted (HTTPS).
 * @param options - Options for trusted and untrusted IPs.
 * @returns The protocol (http or https).
 */
function getProtocol(ip, headers, encrypted, {
  trustedIp,
  untrustedIp
}) {
  let protocol = encrypted ? 'https' : 'http';
  if (isIpTrusted(trustedIp, untrustedIp)(ip)) {
    protocol = (headers['X-Forwarded-Proto'] ?? headers['x-forwarded-proto'])?.split(',').shift()?.trim() ?? protocol;
  }
  return protocol;
}
/**
 * Get hostname.
 *
 * @param ip - The IP address of the request.
 * @param headers - The headers from the incoming request.
 * @param options - Options for trusted IPs, fallback, etc.
 * @returns The hostname from the request.
 */
function getHostname(ip, headers, {
  trusted,
  trustedIp,
  untrustedIp
}) {
  let hostname = headers.host ?? headers.Host;
  if (isIpTrusted(trustedIp, untrustedIp)(ip)) {
    hostname = (headers['X-Forwarded-Host'] ?? headers['x-forwarded-host'])?.split(',').shift() ?? hostname;
  }
  if (hostname === undefined) return hostname;
  const match = hostname.match(/\[([0-9a-fA-F:]+)\]/) ?? undefined;
  if (match !== undefined) {
    hostname = `[${match[1]}]`;
  } else {
    hostname = hostname.trim().replace(/:\d+$/, '').toLowerCase();
  }
  if (!/^[[]?(?![0-9]+$)(?!-)(?:[a-zA-Z0-9-:\]]{1,63}\.?)+$/.test(hostname)) {
    throw new BadRequestError(`SuspiciousOperation: Invalid Host ${hostname} with ip(${ip})`);
  }
  if (trusted?.length > 0) {
    const isValid = trusted.some(pattern => pattern instanceof RegExp && pattern.test(hostname) || pattern === hostname);
    if (!isValid) {
      throw new BadRequestError(`SuspiciousOperation: Untrusted Host ${hostname} with ip(${ip})`);
    }
  }
  return hostname;
}
/**
 * Get file uploads.
 *
 * Get streamed or pre-read(not streamed) file upload.
 *
 * @param event - The incoming event containing the file data.
 * @param options - The options for file upload limits.
 * @returns A promise that resolves with the uploaded files and fields.
 */
async function getFilesUploads(event, options) {
  return await new Promise((resolve, reject) => {
    options.limits ??= {};
    options.limits.fileSize = bytes$2.parse(options.limits.fileSize) ?? Infinity;
    options.limits.fieldSize = bytes$2.parse(options.limits.fieldSize) ?? Infinity;
    options.limits.fieldNameSize = bytes$2.parse(options.limits.fieldNameSize) ?? Infinity;
    const busboy = Busboy({
      headers: event.headers,
      ...options
    });
    const result = {
      files: {},
      fields: {}
    };
    busboy.on('close', () => resolve(result)).on('error', error => reject(new FilesystemError(error.message, {
      cause: error
    }))).on('field', (fieldname, value) => {
      result.fields[fieldname] = value;
    }).on('file', (fieldname, file, info) => {
      result.files[fieldname] ??= [];
      const {
        filename,
        mimeType
      } = info;
      const filepath = join(tmpdir(), `${String(options.prefix ?? 'file')}-${randomUUID()}`);
      const writeStream = createWriteStream(filepath);
      file.on('close', () => {
        result.files[fieldname].push(UploadedFile.createFile(filepath, filename, mimeType));
      });
      writeStream.on('error', error => {
        reject(new FilesystemError(error.message, {
          cause: error
        }));
      });
      file.pipe(writeStream);
    });
    if (event instanceof IncomingMessage) {
      // Handle streamed file uploads.
      event.pipe(busboy);
      event.on('error', error => {
        reject(new InternalServerError(error.message, {
          cause: error
        }));
      });
    } else {
      // Handle pre-read file uploads.
      busboy.write(event.body);
      busboy.end();
    }
  });
}
/**
 * Stream files from the file system as an HTTP response.
 *
 * Only for node http server.
 *
 * @param message - The incoming message.
 * @param response - The outgoing response.
 * @param fileResponse - The binary file response to be streamed.
 * @param options - The options for streaming.
 * @returns A promise that resolves when the file streaming is complete.
 */
async function streamFile(message, response, fileResponse, options) {
  return await new Promise((resolve, reject) => {
    let streaming = false;
    const file = send(message, fileResponse.getEncodedPath(), options);
    const onaborted = () => reject(new BadRequestError('Request aborted.'));
    onFinished(response, error => {
      if (error !== undefined) {
        if (error.code === 'ECONNRESET') return onaborted();
        return reject(new InternalServerError(error.message, {
          cause: error
        }));
      }
      setImmediate(() => {
        streaming ? onaborted() : resolve();
      });
    });
    file.on('error', error => reject(new InternalServerError(error.message, {
      cause: error
    }))).on('headers', resp => Object.entries(options.headers).forEach(([key, value]) => resp.setHeader(key, value))).on('directory', () => reject(new NotFoundError('EISDIR, read'))).on('stream', () => {
      streaming = true;
    }).on('file', () => {
      streaming = false;
    }).on('end', () => resolve()).pipe(response);
  });
}

/**
 * Default HTTP configuration options for the application.
 */
const httpCoreBlueprint = {
  stone: {
    kernel: {
      errorHandlers: [{
        isClass: true,
        error: 'default',
        module: HttpErrorHandler
      }]
    },
    http: {
      hosts: {
        trusted: [],
        trustedPattern: [],
        onlySubdomain: true
      },
      proxies: {
        trustedIp: [],
        untrustedIp: []
      },
      body: {
        limit: '100kb',
        defaultCharset: 'utf-8',
        defaultType: 'text/plain'
      },
      cache: {},
      cookie: {
        secret: '',
        options: {}
      },
      json: {
        spaces: '',
        escape: true,
        replacer: undefined
      },
      files: {
        upload: {},
        download: {},
        defaultCompressionEncoding: {
          '.br': 'br',
          '.brotli': 'br',
          '.gzip': 'gzip',
          '.gz': 'gzip'
        }
      },
      jsonp: {
        callback: {
          name: 'callback'
        }
      },
      subdomain: {
        offset: 1
      },
      etag: {
        function: undefined
      },
      cors: {
        origin: [],
        methods: [],
        maxAge: 86400,
        credentials: false,
        exposedHeaders: [],
        allowedHeaders: [],
        successStatus: 204,
        preflightStop: false
      }
    }
  }
};

const types = {
  'application/andrew-inset': ['ez'],
  'application/appinstaller': ['appinstaller'],
  'application/applixware': ['aw'],
  'application/appx': ['appx'],
  'application/appxbundle': ['appxbundle'],
  'application/atom+xml': ['atom'],
  'application/atomcat+xml': ['atomcat'],
  'application/atomdeleted+xml': ['atomdeleted'],
  'application/atomsvc+xml': ['atomsvc'],
  'application/atsc-dwd+xml': ['dwd'],
  'application/atsc-held+xml': ['held'],
  'application/atsc-rsat+xml': ['rsat'],
  'application/automationml-aml+xml': ['aml'],
  'application/automationml-amlx+zip': ['amlx'],
  'application/bdoc': ['bdoc'],
  'application/calendar+xml': ['xcs'],
  'application/ccxml+xml': ['ccxml'],
  'application/cdfx+xml': ['cdfx'],
  'application/cdmi-capability': ['cdmia'],
  'application/cdmi-container': ['cdmic'],
  'application/cdmi-domain': ['cdmid'],
  'application/cdmi-object': ['cdmio'],
  'application/cdmi-queue': ['cdmiq'],
  'application/cpl+xml': ['cpl'],
  'application/cu-seeme': ['cu'],
  'application/cwl': ['cwl'],
  'application/dash+xml': ['mpd'],
  'application/dash-patch+xml': ['mpp'],
  'application/davmount+xml': ['davmount'],
  'application/docbook+xml': ['dbk'],
  'application/dssc+der': ['dssc'],
  'application/dssc+xml': ['xdssc'],
  'application/ecmascript': ['ecma'],
  'application/emma+xml': ['emma'],
  'application/emotionml+xml': ['emotionml'],
  'application/epub+zip': ['epub'],
  'application/exi': ['exi'],
  'application/express': ['exp'],
  'application/fdf': ['fdf'],
  'application/fdt+xml': ['fdt'],
  'application/font-tdpfr': ['pfr'],
  'application/geo+json': ['geojson'],
  'application/gml+xml': ['gml'],
  'application/gpx+xml': ['gpx'],
  'application/gxf': ['gxf'],
  'application/gzip': ['gz'],
  'application/hjson': ['hjson'],
  'application/hyperstudio': ['stk'],
  'application/inkml+xml': ['ink', 'inkml'],
  'application/ipfix': ['ipfix'],
  'application/its+xml': ['its'],
  'application/java-archive': ['jar', 'war', 'ear'],
  'application/java-serialized-object': ['ser'],
  'application/java-vm': ['class'],
  'application/javascript': ['*js'],
  'application/json': ['json', 'map'],
  'application/json5': ['json5'],
  'application/jsonml+json': ['jsonml'],
  'application/ld+json': ['jsonld'],
  'application/lgr+xml': ['lgr'],
  'application/lost+xml': ['lostxml'],
  'application/mac-binhex40': ['hqx'],
  'application/mac-compactpro': ['cpt'],
  'application/mads+xml': ['mads'],
  'application/manifest+json': ['webmanifest'],
  'application/marc': ['mrc'],
  'application/marcxml+xml': ['mrcx'],
  'application/mathematica': ['ma', 'nb', 'mb'],
  'application/mathml+xml': ['mathml'],
  'application/mbox': ['mbox'],
  'application/media-policy-dataset+xml': ['mpf'],
  'application/mediaservercontrol+xml': ['mscml'],
  'application/metalink+xml': ['metalink'],
  'application/metalink4+xml': ['meta4'],
  'application/mets+xml': ['mets'],
  'application/mmt-aei+xml': ['maei'],
  'application/mmt-usd+xml': ['musd'],
  'application/mods+xml': ['mods'],
  'application/mp21': ['m21', 'mp21'],
  'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],
  'application/msix': ['msix'],
  'application/msixbundle': ['msixbundle'],
  'application/msword': ['doc', 'dot'],
  'application/mxf': ['mxf'],
  'application/n-quads': ['nq'],
  'application/n-triples': ['nt'],
  'application/node': ['cjs'],
  'application/octet-stream': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy', 'exe', 'dll', 'deb', 'dmg', 'iso', 'img', 'msi', 'msp', 'msm', 'buffer'],
  'application/oda': ['oda'],
  'application/oebps-package+xml': ['opf'],
  'application/ogg': ['ogx'],
  'application/omdoc+xml': ['omdoc'],
  'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
  'application/oxps': ['oxps'],
  'application/p2p-overlay+xml': ['relo'],
  'application/patch-ops-error+xml': ['xer'],
  'application/pdf': ['pdf'],
  'application/pgp-encrypted': ['pgp'],
  'application/pgp-keys': ['asc'],
  'application/pgp-signature': ['sig', '*asc'],
  'application/pics-rules': ['prf'],
  'application/pkcs10': ['p10'],
  'application/pkcs7-mime': ['p7m', 'p7c'],
  'application/pkcs7-signature': ['p7s'],
  'application/pkcs8': ['p8'],
  'application/pkix-attr-cert': ['ac'],
  'application/pkix-cert': ['cer'],
  'application/pkix-crl': ['crl'],
  'application/pkix-pkipath': ['pkipath'],
  'application/pkixcmp': ['pki'],
  'application/pls+xml': ['pls'],
  'application/postscript': ['ai', 'eps', 'ps'],
  'application/provenance+xml': ['provx'],
  'application/pskc+xml': ['pskcxml'],
  'application/raml+yaml': ['raml'],
  'application/rdf+xml': ['rdf', 'owl'],
  'application/reginfo+xml': ['rif'],
  'application/relax-ng-compact-syntax': ['rnc'],
  'application/resource-lists+xml': ['rl'],
  'application/resource-lists-diff+xml': ['rld'],
  'application/rls-services+xml': ['rs'],
  'application/route-apd+xml': ['rapd'],
  'application/route-s-tsid+xml': ['sls'],
  'application/route-usd+xml': ['rusd'],
  'application/rpki-ghostbusters': ['gbr'],
  'application/rpki-manifest': ['mft'],
  'application/rpki-roa': ['roa'],
  'application/rsd+xml': ['rsd'],
  'application/rss+xml': ['rss'],
  'application/rtf': ['rtf'],
  'application/sbml+xml': ['sbml'],
  'application/scvp-cv-request': ['scq'],
  'application/scvp-cv-response': ['scs'],
  'application/scvp-vp-request': ['spq'],
  'application/scvp-vp-response': ['spp'],
  'application/sdp': ['sdp'],
  'application/senml+xml': ['senmlx'],
  'application/sensml+xml': ['sensmlx'],
  'application/set-payment-initiation': ['setpay'],
  'application/set-registration-initiation': ['setreg'],
  'application/shf+xml': ['shf'],
  'application/sieve': ['siv', 'sieve'],
  'application/smil+xml': ['smi', 'smil'],
  'application/sparql-query': ['rq'],
  'application/sparql-results+xml': ['srx'],
  'application/sql': ['sql'],
  'application/srgs': ['gram'],
  'application/srgs+xml': ['grxml'],
  'application/sru+xml': ['sru'],
  'application/ssdl+xml': ['ssdl'],
  'application/ssml+xml': ['ssml'],
  'application/swid+xml': ['swidtag'],
  'application/tei+xml': ['tei', 'teicorpus'],
  'application/thraud+xml': ['tfi'],
  'application/timestamped-data': ['tsd'],
  'application/toml': ['toml'],
  'application/trig': ['trig'],
  'application/ttml+xml': ['ttml'],
  'application/ubjson': ['ubj'],
  'application/urc-ressheet+xml': ['rsheet'],
  'application/urc-targetdesc+xml': ['td'],
  'application/voicexml+xml': ['vxml'],
  'application/wasm': ['wasm'],
  'application/watcherinfo+xml': ['wif'],
  'application/widget': ['wgt'],
  'application/winhlp': ['hlp'],
  'application/wsdl+xml': ['wsdl'],
  'application/wspolicy+xml': ['wspolicy'],
  'application/xaml+xml': ['xaml'],
  'application/xcap-att+xml': ['xav'],
  'application/xcap-caps+xml': ['xca'],
  'application/xcap-diff+xml': ['xdf'],
  'application/xcap-el+xml': ['xel'],
  'application/xcap-ns+xml': ['xns'],
  'application/xenc+xml': ['xenc'],
  'application/xfdf': ['xfdf'],
  'application/xhtml+xml': ['xhtml', 'xht'],
  'application/xliff+xml': ['xlf'],
  'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
  'application/xml-dtd': ['dtd'],
  'application/xop+xml': ['xop'],
  'application/xproc+xml': ['xpl'],
  'application/xslt+xml': ['*xsl', 'xslt'],
  'application/xspf+xml': ['xspf'],
  'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
  'application/yang': ['yang'],
  'application/yin+xml': ['yin'],
  'application/zip': ['zip'],
  'audio/3gpp': ['*3gpp'],
  'audio/aac': ['adts', 'aac'],
  'audio/adpcm': ['adp'],
  'audio/amr': ['amr'],
  'audio/basic': ['au', 'snd'],
  'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
  'audio/mobile-xmf': ['mxmf'],
  'audio/mp3': ['*mp3'],
  'audio/mp4': ['m4a', 'mp4a'],
  'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
  'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
  'audio/s3m': ['s3m'],
  'audio/silk': ['sil'],
  'audio/wav': ['wav'],
  'audio/wave': ['*wav'],
  'audio/webm': ['weba'],
  'audio/xm': ['xm'],
  'font/collection': ['ttc'],
  'font/otf': ['otf'],
  'font/ttf': ['ttf'],
  'font/woff': ['woff'],
  'font/woff2': ['woff2'],
  'image/aces': ['exr'],
  'image/apng': ['apng'],
  'image/avci': ['avci'],
  'image/avcs': ['avcs'],
  'image/avif': ['avif'],
  'image/bmp': ['bmp', 'dib'],
  'image/cgm': ['cgm'],
  'image/dicom-rle': ['drle'],
  'image/dpx': ['dpx'],
  'image/emf': ['emf'],
  'image/fits': ['fits'],
  'image/g3fax': ['g3'],
  'image/gif': ['gif'],
  'image/heic': ['heic'],
  'image/heic-sequence': ['heics'],
  'image/heif': ['heif'],
  'image/heif-sequence': ['heifs'],
  'image/hej2k': ['hej2'],
  'image/hsj2': ['hsj2'],
  'image/ief': ['ief'],
  'image/jls': ['jls'],
  'image/jp2': ['jp2', 'jpg2'],
  'image/jpeg': ['jpeg', 'jpg', 'jpe'],
  'image/jph': ['jph'],
  'image/jphc': ['jhc'],
  'image/jpm': ['jpm', 'jpgm'],
  'image/jpx': ['jpx', 'jpf'],
  'image/jxl': ['jxl'],
  'image/jxr': ['jxr'],
  'image/jxra': ['jxra'],
  'image/jxrs': ['jxrs'],
  'image/jxs': ['jxs'],
  'image/jxsc': ['jxsc'],
  'image/jxsi': ['jxsi'],
  'image/jxss': ['jxss'],
  'image/ktx': ['ktx'],
  'image/ktx2': ['ktx2'],
  'image/png': ['png'],
  'image/sgi': ['sgi'],
  'image/svg+xml': ['svg', 'svgz'],
  'image/t38': ['t38'],
  'image/tiff': ['tif', 'tiff'],
  'image/tiff-fx': ['tfx'],
  'image/webp': ['webp'],
  'image/wmf': ['wmf'],
  'message/disposition-notification': ['disposition-notification'],
  'message/global': ['u8msg'],
  'message/global-delivery-status': ['u8dsn'],
  'message/global-disposition-notification': ['u8mdn'],
  'message/global-headers': ['u8hdr'],
  'message/rfc822': ['eml', 'mime'],
  'model/3mf': ['3mf'],
  'model/gltf+json': ['gltf'],
  'model/gltf-binary': ['glb'],
  'model/iges': ['igs', 'iges'],
  'model/jt': ['jt'],
  'model/mesh': ['msh', 'mesh', 'silo'],
  'model/mtl': ['mtl'],
  'model/obj': ['obj'],
  'model/prc': ['prc'],
  'model/step+xml': ['stpx'],
  'model/step+zip': ['stpz'],
  'model/step-xml+zip': ['stpxz'],
  'model/stl': ['stl'],
  'model/u3d': ['u3d'],
  'model/vrml': ['wrl', 'vrml'],
  'model/x3d+binary': ['*x3db', 'x3dbz'],
  'model/x3d+fastinfoset': ['x3db'],
  'model/x3d+vrml': ['*x3dv', 'x3dvz'],
  'model/x3d+xml': ['x3d', 'x3dz'],
  'model/x3d-vrml': ['x3dv'],
  'text/cache-manifest': ['appcache', 'manifest'],
  'text/calendar': ['ics', 'ifb'],
  'text/coffeescript': ['coffee', 'litcoffee'],
  'text/css': ['css'],
  'text/csv': ['csv'],
  'text/html': ['html', 'htm', 'shtml'],
  'text/jade': ['jade'],
  'text/javascript': ['js', 'mjs'],
  'text/jsx': ['jsx'],
  'text/less': ['less'],
  'text/markdown': ['md', 'markdown'],
  'text/mathml': ['mml'],
  'text/mdx': ['mdx'],
  'text/n3': ['n3'],
  'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
  'text/richtext': ['rtx'],
  'text/rtf': ['*rtf'],
  'text/sgml': ['sgml', 'sgm'],
  'text/shex': ['shex'],
  'text/slim': ['slim', 'slm'],
  'text/spdx': ['spdx'],
  'text/stylus': ['stylus', 'styl'],
  'text/tab-separated-values': ['tsv'],
  'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
  'text/turtle': ['ttl'],
  'text/uri-list': ['uri', 'uris', 'urls'],
  'text/vcard': ['vcard'],
  'text/vtt': ['vtt'],
  'text/wgsl': ['wgsl'],
  'text/xml': ['*xml'],
  'text/yaml': ['yaml', 'yml'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['*jpm', '*jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts', 'm2t', 'm2ts', 'mts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/webm': ['webm']
};
Object.freeze(types);

var __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
class Mime {
  constructor(...args) {
    _Mime_extensionToType.set(this, new Map());
    _Mime_typeToExtension.set(this, new Map());
    _Mime_typeToExtensions.set(this, new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type, extensions] of Object.entries(typeMap)) {
      type = type.toLowerCase();
      extensions = extensions.map(ext => ext.toLowerCase());
      if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) {
        __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, new Set());
      }
      const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
      let first = true;
      for (let extension of extensions) {
        const starred = extension.startsWith('*');
        extension = starred ? extension.slice(1) : extension;
        allExtensions?.add(extension);
        if (first) {
          __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
        }
        first = false;
        if (starred) continue;
        const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
        if (currentType && currentType != type && !force) {
          throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
        }
        __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
      }
    }
    return this;
  }
  getType(path) {
    if (typeof path !== 'string') return null;
    const last = path.replace(/^.*[/\\]/, '').toLowerCase();
    const ext = last.replace(/^.*\./, '').toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath) return null;
    return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
  }
  getExtension(type) {
    if (typeof type !== 'string') return null;
    type = type?.split?.(';')[0];
    return (type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null;
  }
  getAllExtensions(type) {
    if (typeof type !== 'string') return null;
    return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error('define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances');
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
      extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
    };
  }
}
_Mime_extensionToType = new WeakMap(), _Mime_typeToExtension = new WeakMap(), _Mime_typeToExtensions = new WeakMap();

var mime = new Mime(types)._freeze();

var negotiator = {exports: {}};

var charset = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset) return charset.exports;
  hasRequiredCharset = 1;

  /**
   * Module exports.
   * @public
   */

  charset.exports = preferredCharsets;
  charset.exports.preferredCharsets = preferredCharsets;

  /**
   * Module variables.
   * @private
   */

  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Charset header.
   * @private
   */

  function parseAcceptCharset(accept) {
    var accepts = accept.split(',');
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a charset from the Accept-Charset header.
   * @private
   */

  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of a charset.
   * @private
   */

  function getCharsetPriority(charset, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the charset.
   * @private
   */

  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred charsets from an Accept-Charset header.
   * @public
   */

  function preferredCharsets(accept, provided) {
    // RFC 2616 sec 14.2: no header = *
    var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    if (!provided) {
      // sorted list of all charsets
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });

    // sorted list of accepted charsets
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full charset string.
   * @private
   */

  function getFullCharset(spec) {
    return spec.charset;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset.exports;
}

var encoding = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding.exports;
  hasRequiredEncoding = 1;

  /**
   * Module exports.
   * @public
   */

  encoding.exports = preferredEncodings;
  encoding.exports.preferredEncodings = preferredEncodings;

  /**
   * Module variables.
   * @private
   */

  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Encoding header.
   * @private
   */

  function parseAcceptEncoding(accept) {
    var accepts = accept.split(',');
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify('identity', encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      /*
       * If identity doesn't explicitly appear in the accept-encoding header,
       * it's added to the list of acceptable encoding with the lowest q
       */
      accepts[j++] = {
        encoding: 'identity',
        q: minQuality,
        i: i
      };
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse an encoding from the Accept-Encoding header.
   * @private
   */

  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of an encoding.
   * @private
   */

  function getEncodingPriority(encoding, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the encoding.
   * @private
   */

  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred encodings from an Accept-Encoding header.
   * @public
   */

  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || '');
    if (!provided) {
      // sorted list of all encodings
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });

    // sorted list of accepted encodings
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full encoding string.
   * @private
   */

  function getFullEncoding(spec) {
    return spec.encoding;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding.exports;
}

var language = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage) return language.exports;
  hasRequiredLanguage = 1;

  /**
   * Module exports.
   * @public
   */

  language.exports = preferredLanguages;
  language.exports.preferredLanguages = preferredLanguages;

  /**
   * Module variables.
   * @private
   */

  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

  /**
   * Parse the Accept-Language header.
   * @private
   */

  function parseAcceptLanguage(accept) {
    var accepts = accept.split(',');
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j++] = language;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a language from the Accept-Language header.
   * @private
   */

  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(';');
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split('=');
        if (p[0] === 'q') q = parseFloat(p[1]);
      }
    }
    return {
      prefix: prefix,
      suffix: suffix,
      q: q,
      i: i,
      full: full
    };
  }

  /**
   * Get the priority of a language.
   * @private
   */

  function getLanguagePriority(language, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the language.
   * @private
   */

  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred languages from an Accept-Language header.
   * @public
   */

  function preferredLanguages(accept, provided) {
    // RFC 2616 sec 14.4: no header = *
    var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    if (!provided) {
      // sorted list of all languages
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });

    // sorted list of accepted languages
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full language string.
   * @private
   */

  function getFullLanguage(spec) {
    return spec.full;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }
  return language.exports;
}

var mediaType = {exports: {}};

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType) return mediaType.exports;
  hasRequiredMediaType = 1;

  /**
   * Module exports.
   * @public
   */

  mediaType.exports = preferredMediaTypes;
  mediaType.exports.preferredMediaTypes = preferredMediaTypes;

  /**
   * Module variables.
   * @private
   */

  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

  /**
   * Parse the Accept header.
   * @private
   */

  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }

    // trim accepts
    accepts.length = j;
    return accepts;
  }

  /**
   * Parse a media type from the Accept header.
   * @private
   */

  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];

        // get the value, unwrapping quotes
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === 'q') {
          q = parseFloat(value);
          break;
        }

        // store parameter
        params[key] = value;
      }
    }
    return {
      type: type,
      subtype: subtype,
      params: params,
      q: q,
      i: i
    };
  }

  /**
   * Get the priority of a media type.
   * @private
   */

  function getMediaTypePriority(type, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }

  /**
   * Get the specificity of the media type.
   * @private
   */

  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != '*') {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != '*') {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function (k) {
        return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  /**
   * Get the preferred media types from an Accept header.
   * @public
   */

  function preferredMediaTypes(accept, provided) {
    // RFC 2616 sec 14.2: no header = */*
    var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    if (!provided) {
      // sorted list of all types
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });

    // sorted list of accepted types
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  /**
   * Compare two specs.
   * @private
   */

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  /**
   * Get full type string.
   * @private
   */

  function getFullType(spec) {
    return spec.type + '/' + spec.subtype;
  }

  /**
   * Check if a spec has any quality.
   * @private
   */

  function isQuality(spec) {
    return spec.q > 0;
  }

  /**
   * Count the number of quotes in a string.
   * @private
   */

  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }

  /**
   * Split a key value pair.
   * @private
   */

  function splitKeyValuePair(str) {
    var index = str.indexOf('=');
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }

  /**
   * Split an Accept header into media types.
   * @private
   */

  function splitMediaTypes(accept) {
    var accepts = accept.split(',');
    for (var i = 1, j = 0; i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += ',' + accepts[i];
      }
    }

    // trim accepts
    accepts.length = j + 1;
    return accepts;
  }

  /**
   * Split a string of parameters.
   * @private
   */

  function splitParameters(str) {
    var parameters = str.split(';');
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ';' + parameters[i];
      }
    }

    // trim parameters
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType.exports;
}

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator) return negotiator.exports;
  hasRequiredNegotiator = 1;
  var preferredCharsets = requireCharset();
  var preferredEncodings = requireEncoding();
  var preferredLanguages = requireLanguage();
  var preferredMediaTypes = requireMediaType();

  /**
   * Module exports.
   * @public
   */

  negotiator.exports = Negotiator;
  negotiator.exports.Negotiator = Negotiator;

  /**
   * Create a Negotiator instance from a request.
   * @param {object} request
   * @public
   */

  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers['accept-charset'], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers['accept-encoding'], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers['accept-language'], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };

  // Backwards compatibility
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator.exports;
}

var mimeTypes = {};

var require$$0$3 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  /**
   * Module exports.
   */

  mimeDb = require$$0$3;
  return mimeDb;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function (exports) {

    /**
     * Module dependencies.
     * @private
     */
    var db = requireMimeDb();
    var extname = require$$0$a.extname;

    /**
     * Module variables.
     * @private
     */

    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;

    /**
     * Module exports.
     * @public
     */

    exports.charset = charset;
    exports.charsets = {
      lookup: charset
    };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);

    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types);

    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }

      // default text/* to utf-8
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
      }
      return false;
    }

    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */

    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false;
      }
      var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }

      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
      }
      return mime;
    }

    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      var match = EXTRACT_TYPE_REGEXP.exec(type);

      // get extensions
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }

    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */

    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false;
      }

      // get the extension ("ext" or ".ext" or full path)
      var extension = extname('x.' + path).toLowerCase().substr(1);
      if (!extension) {
        return false;
      }
      return exports.types[extension] || false;
    }

    /**
     * Populate the extensions and types maps.
     * @private
     */

    function populateMaps(extensions, types) {
      // source preference (least -> most)
      var preference = ['nginx', 'apache', undefined, 'iana'];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }

        // mime -> extensions
        extensions[type] = exts;

        // extension -> mime
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i];
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
              // skip the remapping
              continue;
            }
          }

          // set the extension -> mime
          types[extension] = type;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts$1;
var hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts) return accepts$1;
  hasRequiredAccepts = 1;

  /**
   * Module dependencies.
   * @private
   */

  var Negotiator = requireNegotiator();
  var mime = requireMimeTypes();

  /**
   * Module exports.
   * @public
   */

  accepts$1 = Accepts;

  /**
   * Create a new Accepts object for the given req.
   *
   * @param {object} req
   * @public
   */

  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }

  /**
   * Check if the given `type(s)` is acceptable, returning
   * the best match when true, otherwise `undefined`, in which
   * case you should respond with 406 "Not Acceptable".
   *
   * The `type` value may be a single mime type string
   * such as "application/json", the extension name
   * such as "json" or an array `["json", "html", "text/plain"]`. When a list
   * or array is given the _best_ match, if any is returned.
   *
   * Examples:
   *
   *     // Accept: text/html
   *     this.types('html');
   *     // => "html"
   *
   *     // Accept: text/*, application/json
   *     this.types('html');
   *     // => "html"
   *     this.types('text/html');
   *     // => "text/html"
   *     this.types('json', 'text');
   *     // => "json"
   *     this.types('application/json');
   *     // => "application/json"
   *
   *     // Accept: text/*, application/json
   *     this.types('image/png');
   *     this.types('png');
   *     // => undefined
   *
   *     // Accept: text/*;q=.5, application/json
   *     this.types(['html', 'json']);
   *     this.types('html', 'json');
   *     // => "json"
   *
   * @param {String|Array} types...
   * @return {String|Array|Boolean}
   * @public
   */

  Accepts.prototype.type = Accepts.prototype.types = function (types_) {
    var types = types_;

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i];
      }
    }

    // no types, return all requested types
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }

    // no accept header, return first given type
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
  };

  /**
   * Return accepted encodings or best fit based on `encodings`.
   *
   * Given `Accept-Encoding: gzip, deflate`
   * an array sorted by quality is returned:
   *
   *     ['gzip', 'deflate']
   *
   * @param {String|Array} encodings...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
    var encodings = encodings_;

    // support flattened arguments
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0; i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }

    // no encodings, return all requested encodings
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };

  /**
   * Return accepted charsets or best fit based on `charsets`.
   *
   * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
   * an array sorted by quality is returned:
   *
   *     ['utf-8', 'utf-7', 'iso-8859-1']
   *
   * @param {String|Array} charsets...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
    var charsets = charsets_;

    // support flattened arguments
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }

    // no charsets, return all requested charsets
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };

  /**
   * Return accepted languages or best fit based on `langs`.
   *
   * Given `Accept-Language: en;q=0.8, es, pt`
   * an array sorted by quality is returned:
   *
   *     ['es', 'pt', 'en']
   *
   * @param {String|Array} langs...
   * @return {Array|String}
   * @public
   */

  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
    var languages = languages_;

    // support flattened arguments
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }

    // no languages, return all requested languages
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };

  /**
   * Convert extnames to mime.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function extToMime(type) {
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if mime is valid.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function validMime(type) {
    return typeof type === 'string';
  }
  return accepts$1;
}

var acceptsExports = requireAccepts();
var accepts = /*@__PURE__*/getDefaultExportFromCjs(acceptsExports);

var require$$0$2 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$1;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses$1;
  hasRequiredStatuses = 1;

  /**
   * Module dependencies.
   * @private
   */

  var codes = require$$0$2;

  /**
   * Module exports.
   * @public
   */

  statuses$1 = status;

  // status code to message map
  status.message = codes;

  // status message (lower-case) to code map
  status.code = createMessageToStatusCodeMap(codes);

  // array of status codes
  status.codes = createStatusCodeList(codes);

  // status codes for redirects
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };

  // status codes for empty bodies
  status.empty = {
    204: true,
    205: true,
    304: true
  };

  // status codes for when you should retry the request
  status.retry = {
    502: true,
    503: true,
    504: true
  };

  /**
   * Create a map of message to status code.
   * @private
   */

  function createMessageToStatusCodeMap(codes) {
    var map = {};
    Object.keys(codes).forEach(function forEachCode(code) {
      var message = codes[code];
      var status = Number(code);

      // populate map
      map[message.toLowerCase()] = status;
    });
    return map;
  }

  /**
   * Create a list of all status codes.
   * @private
   */

  function createStatusCodeList(codes) {
    return Object.keys(codes).map(function mapCode(code) {
      return Number(code);
    });
  }

  /**
   * Get the status code for given message.
   * @private
   */

  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }

  /**
   * Get the status message for given code.
   * @private
   */

  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error('invalid status code: ' + code);
    }
    return status.message[code];
  }

  /**
   * Get the status code.
   *
   * Given a number, this will throw if it is not a known status
   * code, otherwise the code will be returned. Given a string,
   * the string will be parsed for a number and return the code
   * if valid, otherwise will lookup the code assuming this is
   * the status message.
   *
   * @param {string|number} code
   * @returns {number}
   * @public
   */

  function status(code) {
    if (typeof code === 'number') {
      return getStatusMessage(code);
    }
    if (typeof code !== 'string') {
      throw new TypeError('code must be a number or string');
    }

    // '403'
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses$1;
}

var statusesExports = requireStatuses();
var statuses = /*@__PURE__*/getDefaultExportFromCjs(statusesExports);

var bytes$1 = {exports: {}};

/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes$1.exports;
  hasRequiredBytes = 1;

  /**
   * Module exports.
   * @public
   */

  bytes$1.exports = bytes;
  bytes$1.exports.format = format;
  bytes$1.exports.parse = parse;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

  /**
   * Convert the given value in bytes into a string or parse to string to an integer in bytes.
   *
   * @param {string|number} value
   * @param {{
   *  case: [string],
   *  decimalPlaces: [number]
   *  fixedDecimals: [boolean]
   *  thousandsSeparator: [string]
   *  unitSeparator: [string]
   *  }} [options] bytes options.
   *
   * @returns {string|number|null}
   */

  function bytes(value, options) {
    if (typeof value === 'string') {
      return parse(value);
    }
    if (typeof value === 'number') {
      return format(value, options);
    }
    return null;
  }

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unit=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || '';
    var unitSeparator = options && options.unitSeparator || '';
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || '';
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = 'PB';
      } else if (mag >= map.tb) {
        unit = 'TB';
      } else if (mag >= map.gb) {
        unit = 'GB';
      } else if (mag >= map.mb) {
        unit = 'MB';
      } else if (mag >= map.kb) {
        unit = 'KB';
      } else {
        unit = 'B';
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }
    if (thousandsSeparator) {
      str = str.split('.').map(function (s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join('.');
    }
    return str + unitSeparator + unit;
  }

  /**
   * Parse the string value into an integer in bytes.
   *
   * If no unit is given, it is assumed the value is in bytes.
   *
   * @param {number|string} val
   *
   * @returns {number|null}
   * @public
   */

  function parse(val) {
    if (typeof val === 'number' && !isNaN(val)) {
      return val;
    }
    if (typeof val !== 'string') {
      return null;
    }

    // Test if the string passed is valid
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = 'b';
    if (!results) {
      // Nothing could be extracted from the given string
      floatValue = parseInt(val, 10);
      unit = 'b';
    } else {
      // Retrieve the value and the unit
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  }
  return bytes$1.exports;
}

var bytesExports = requireBytes();
var bytes = /*@__PURE__*/getDefaultExportFromCjs(bytesExports);

var typeIs$1 = {exports: {}};

var mediaTyper = {};

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper) return mediaTyper;
  hasRequiredMediaTyper = 1;
  /**
   * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
   *
   * parameter     = token "=" ( token | quoted-string )
   * token         = 1*<any CHAR except CTLs or separators>
   * separators    = "(" | ")" | "<" | ">" | "@"
   *               | "," | ";" | ":" | "\" | <">
   *               | "/" | "[" | "]" | "?" | "="
   *               | "{" | "}" | SP | HT
   * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
   * qdtext        = <any TEXT except <">>
   * quoted-pair   = "\" CHAR
   * CHAR          = <any US-ASCII character (octets 0 - 127)>
   * TEXT          = <any OCTET except CTLs, but including LWS>
   * LWS           = [CRLF] 1*( SP | HT )
   * CRLF          = CR LF
   * CR            = <US-ASCII CR, carriage return (13)>
   * LF            = <US-ASCII LF, linefeed (10)>
   * SP            = <US-ASCII SP, space (32)>
   * SHT           = <US-ASCII HT, horizontal-tab (9)>
   * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
   * OCTET         = <any 8-bit sequence of data>
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

  /**
   * RegExp to match quoted-pair in RFC 2616
   *
   * quoted-pair = "\" CHAR
   * CHAR        = <any US-ASCII character (octets 0 - 127)>
   */
  var qescRegExp = /\\([\u0000-\u007f])/g;

  /**
   * RegExp to match chars that must be quoted-pair in RFC 2616
   */
  var quoteRegExp = /([\\"])/g;

  /**
   * RegExp to match type in RFC 6838
   *
   * type-name = restricted-name
   * subtype-name = restricted-name
   * restricted-name = restricted-name-first *126restricted-name-chars
   * restricted-name-first  = ALPHA / DIGIT
   * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
   *                          "$" / "&" / "-" / "^" / "_"
   * restricted-name-chars =/ "." ; Characters before first dot always
   *                              ; specify a facet name
   * restricted-name-chars =/ "+" ; Characters after last plus always
   *                              ; specify a structured syntax suffix
   * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
   * DIGIT =  %x30-39             ; 0-9
   */
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

  /**
   * Module exports.
   */

  mediaTyper.format = format;
  mediaTyper.parse = parse;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @api public
   */

  function format(obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError('invalid type');
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError('invalid subtype');
    }

    // format as type/subtype
    var string = type + '/' + subtype;

    // append +suffix
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError('invalid suffix');
      }
      string += '+' + suffix;
    }

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError('invalid parameter name');
        }
        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }
    return string;
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @api public
   */

  function parse(string) {
    if (!string) {
      throw new TypeError('argument string is required');
    }

    // support req/res-like objects as argument
    if (typeof string === 'object') {
      string = getcontenttype(string);
    }
    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string');
    }
    var index = string.indexOf(';');
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }
    obj.parameters = params;
    return obj;
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @api private
   */

  function getcontenttype(obj) {
    if (typeof obj.getHeader === 'function') {
      // res-like
      return obj.getHeader('content-type');
    }
    if (typeof obj.headers === 'object') {
      // req-like
      return obj.headers && obj.headers['content-type'];
    }
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @api private
   */

  function qstring(val) {
    var str = String(val);

    // no need to quote tokens
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(quoteRegExp, '\\$1') + '"';
  }

  /**
   * Simply "type/subtype+siffx" into parts.
   *
   * @param {string} string
   * @return {Object}
   * @api private
   */

  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError('invalid media type');
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;

    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type: type,
      subtype: subtype,
      suffix: suffix
    };
    return obj;
  }
  return mediaTyper;
}

/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs) return typeIs$1.exports;
  hasRequiredTypeIs = 1;

  /**
   * Module dependencies.
   * @private
   */

  var typer = requireMediaTyper();
  var mime = requireMimeTypes();

  /**
   * Module exports.
   * @public
   */

  typeIs$1.exports = typeofrequest;
  typeIs$1.exports.is = typeis;
  typeIs$1.exports.hasBody = hasbody;
  typeIs$1.exports.normalize = normalize;
  typeIs$1.exports.match = mimeMatch;

  /**
   * Compare a `value` content-type with `types`.
   * Each `type` can be an extension like `html`,
   * a special shortcut like `multipart` or `urlencoded`,
   * or a mime type.
   *
   * If no types match, `false` is returned.
   * Otherwise, the first `type` that matches is returned.
   *
   * @param {String} value
   * @param {Array} types
   * @public
   */

  function typeis(value, types_) {
    var i;
    var types = types_;

    // remove parameters and normalize
    var val = tryNormalizeType(value);

    // no type or invalid
    if (!val) {
      return false;
    }

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // no types, return the content type
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0; i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
      }
    }

    // no matches
    return false;
  }

  /**
   * Check if a request has a request body.
   * A request with a body __must__ either have `transfer-encoding`
   * or `content-length` headers set.
   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
   *
   * @param {Object} request
   * @return {Boolean}
   * @public
   */

  function hasbody(req) {
    return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
  }

  /**
   * Check if the incoming request contains the "Content-Type"
   * header field, and it contains any of the give mime `type`s.
   * If there is no request body, `null` is returned.
   * If there is no content type, `false` is returned.
   * Otherwise, it returns the first `type` that matches.
   *
   * Examples:
   *
   *     // With Content-Type: text/html; charset=utf-8
   *     this.is('html'); // => 'html'
   *     this.is('text/html'); // => 'text/html'
   *     this.is('text/*', 'application/json'); // => 'text/html'
   *
   *     // When Content-Type is application/json
   *     this.is('json', 'urlencoded'); // => 'json'
   *     this.is('application/json'); // => 'application/json'
   *     this.is('html', 'application/*'); // => 'application/json'
   *
   *     this.is('html'); // => false
   *
   * @param {String|Array} types...
   * @return {String|false|null}
   * @public
   */

  function typeofrequest(req, types_) {
    var types = types_;

    // no body
    if (!hasbody(req)) {
      return null;
    }

    // support flattened arguments
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // request content type
    var value = req.headers['content-type'];
    return typeis(value, types);
  }

  /**
   * Normalize a mime type.
   * If it's a shorthand, expand it to a valid mime type.
   *
   * In general, you probably want:
   *
   *   var type = is(req, ['urlencoded', 'json', 'multipart']);
   *
   * Then use the appropriate body parsers.
   * These three are the most common request body types
   * and are thus ensured to work.
   *
   * @param {String} type
   * @private
   */

  function normalize(type) {
    if (typeof type !== 'string') {
      // invalid type
      return false;
    }
    switch (type) {
      case 'urlencoded':
        return 'application/x-www-form-urlencoded';
      case 'multipart':
        return 'multipart/*';
    }
    if (type[0] === '+') {
      // "+json" -> "*/*+json" expando
      return '*/*' + type;
    }
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if `expected` mime type
   * matches `actual` mime type with
   * wildcard and +suffix support.
   *
   * @param {String} expected
   * @param {String} actual
   * @return {Boolean}
   * @private
   */

  function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false) {
      return false;
    }

    // split types
    var actualParts = actual.split('/');
    var expectedParts = expected.split('/');

    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }

    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
      return false;
    }

    // validate suffix wildcard
    if (expectedParts[1].substr(0, 2) === '*+') {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }

    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }

  /**
   * Normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function normalizeType(value) {
    // parse the type
    var type = typer.parse(value);

    // remove the parameters
    type.parameters = undefined;

    // reformat it
    return typer.format(type);
  }

  /**
   * Try to normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
  return typeIs$1.exports;
}

var typeIsExports = requireTypeIs();
var typeIs = /*@__PURE__*/getDefaultExportFromCjs(typeIsExports);

var httpErrors = {exports: {}};

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var depd_1;
var hasRequiredDepd;
function requireDepd() {
  if (hasRequiredDepd) return depd_1;
  hasRequiredDepd = 1;
  /**
   * Module dependencies.
   */

  var relative = require$$0$a.relative;

  /**
   * Module exports.
   */

  depd_1 = depd;

  /**
   * Get the path to base files on.
   */

  var basePath = process.cwd();

  /**
   * Determine if namespace is contained in the string.
   */

  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0; i < vals.length; i++) {
      var val = vals[i];

      // namespace contained
      if (val && (val === '*' || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Convert a data descriptor to accessor descriptor.
   */

  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }

  /**
   * Create arguments string to keep arity.
   */

  function createArgumentsString(arity) {
    var str = '';
    for (var i = 0; i < arity; i++) {
      str += ', arg' + i;
    }
    return str.substr(2);
  }

  /**
   * Create stack string from stack.
   */

  function createStackString(stack) {
    var str = this.name + ': ' + this.namespace;
    if (this.message) {
      str += ' deprecated ' + this.message;
    }
    for (var i = 0; i < stack.length; i++) {
      str += '\n    at ' + stack[i].toString();
    }
    return str;
  }

  /**
   * Create deprecate for namespace in caller.
   */

  function depd(namespace) {
    if (!namespace) {
      throw new TypeError('argument namespace is required');
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
      // call to self as log
      log.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }

  /**
   * Determine if event emitter has listeners of a given type.
   *
   * The way to do this check is done three different ways in Node.js >= 0.8
   * so this consolidates them into a minimal set using instance methods.
   *
   * @param {EventEmitter} emitter
   * @param {string} type
   * @returns {boolean}
   * @private
   */

  function eehaslisteners(emitter, type) {
    var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }

  /**
   * Determine if namespace is ignored.
   */

  function isignored(namespace) {
    if (process.noDeprecation) {
      // --no-deprecation support
      return true;
    }
    var str = process.env.NO_DEPRECATION || '';

    // namespace ignored
    return containsNamespace(str, namespace);
  }

  /**
   * Determine if namespace is traced.
   */

  function istraced(namespace) {
    if (process.traceDeprecation) {
      // --trace-deprecation support
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || '';

    // namespace traced
    return containsNamespace(str, namespace);
  }

  /**
   * Display deprecation message.
   */

  function log(message, site) {
    var haslisteners = eehaslisteners(process, 'deprecation');

    // abort early if no destination
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
      // provided site
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      // get call site
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }

    // get caller of deprecated thing in relation to file
    for (; i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;
    if (key !== undefined && key in this._warned) {
      // already warned
      return;
    }
    this._warned[key] = true;

    // generate automatic message from call site
    var msg = message;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }

    // emit deprecation if listeners exist
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit('deprecation', err);
      return;
    }

    // format and write message
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + '\n', 'utf8');
  }

  /**
   * Get call site location as array.
   */

  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || '<anonymous>';
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ', ' + file;
    }
    var site = [file, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }

  /**
   * Generate a default message from the site.
   */

  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;

    // make useful anonymous name
    if (!funcName) {
      funcName = '<anonymous@' + formatLocation(site) + '>';
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();

    // ignore useless type name
    if (typeName === 'Object') {
      typeName = undefined;
    }

    // make useful type name
    if (typeName === 'Function') {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
  }

  /**
   * Format deprecation message without color.
   */

  function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;

    // add stack trace
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    at ' + stack[i].toString();
      }
      return formatted;
    }
    if (caller) {
      formatted += ' at ' + formatLocation(caller);
    }
    return formatted;
  }

  /**
   * Format deprecation message with color.
   */

  function formatColor(msg, caller, stack) {
    var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' +
    // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' +
    // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m'; // reset

    // add stack trace
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m'; // cyan
      }
      return formatted;
    }
    if (caller) {
      formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
    }
    return formatted;
  }

  /**
   * Format call site location.
   */

  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
  }

  /**
   * Get the stack as array of call sites.
   */

  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);

    // capture the stack
    Error.captureStackTrace(obj);

    // slice this function off the top
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
  }

  /**
   * Capture call site stack from v8.
   */

  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }

  /**
   * Return a wrapped function in a deprecation message.
   */

  function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
      throw new TypeError('argument fn must be a function');
    }
    var args = createArgumentsString(fn.length);
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;

    // eslint-disable-next-line no-new-func
    var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\n' + 'return function (' + args + ') {' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '}')(fn, log, this, message, site);
    return deprecatedfn;
  }

  /**
   * Wrap property in a deprecation message.
   */

  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
      throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
      throw new TypeError('property must be configurable');
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);

    // set site name
    site.name = prop;

    // convert data descriptor
    if ('value' in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop);
    }
    var get = descriptor.get;
    var set = descriptor.set;

    // wrap getter
    if (typeof get === 'function') {
      descriptor.get = function getter() {
        log.call(deprecate, message, site);
        return get.apply(this, arguments);
      };
    }

    // wrap setter
    if (typeof set === 'function') {
      descriptor.set = function setter() {
        log.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }

  /**
   * Create DeprecationError for deprecation
   */

  function DeprecationError(namespace, message, stack) {
    var error = new Error();
    var stackString;
    Object.defineProperty(error, 'constructor', {
      value: DeprecationError
    });
    Object.defineProperty(error, 'message', {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true
    });
    Object.defineProperty(error, 'name', {
      enumerable: false,
      configurable: true,
      value: 'DeprecationError',
      writable: true
    });
    Object.defineProperty(error, 'namespace', {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error, 'stack', {
      configurable: true,
      enumerable: false,
      get: function () {
        if (stackString !== undefined) {
          return stackString;
        }

        // prepare stack trace
        return stackString = createStackString.call(this, stack);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error;
  }
  return depd_1;
}

var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof) return setprototypeof;
  hasRequiredSetprototypeof = 1;
  /* eslint no-proto: 0 */
  setprototypeof = Object.setPrototypeOf || ({
    __proto__: []
  } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
  return setprototypeof;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}

var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util = require('util');
    /* istanbul ignore next */
    if (typeof util.inherits !== 'function') throw '';
    inherits.exports = util.inherits;
  } catch (e) {
    /* istanbul ignore next */
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}

/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier) return toidentifier;
  hasRequiredToidentifier = 1;

  /**
   * Module exports.
   * @public
   */

  toidentifier = toIdentifier;

  /**
   * Trasform the given string into a JavaScript identifier
   *
   * @param {string} str
   * @returns {string}
   * @public
   */

  function toIdentifier(str) {
    return str.split(' ').map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
  }
  return toidentifier;
}

/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors) return httpErrors.exports;
  hasRequiredHttpErrors = 1;
  (function (module) {

    /**
     * Module dependencies.
     * @private
     */
    var deprecate = requireDepd()('http-errors');
    var setPrototypeOf = requireSetprototypeof();
    var statuses = requireStatuses();
    var inherits = requireInherits();
    var toIdentifier = requireToidentifier();

    /**
     * Module exports.
     * @public
     */

    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);

    // Populate exports for all constructors
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

    /**
     * Get the code class of a status code.
     * @private
     */

    function codeClass(status) {
      return Number(String(status).charAt(0) + '00');
    }

    /**
     * Create a new HTTP Error.
     *
     * @returns {Error}
     * @public
     */

    function createError() {
      // so much arity going on ~_~
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === 'object' && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === 'number' && i === 0) {
          status = arg;
        } else if (type === 'string') {
          msg = arg;
        } else if (type === 'object') {
          props = arg;
        } else {
          throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
        }
      }
      if (typeof status === 'number' && (status < 400 || status >= 600)) {
        deprecate('non-error status code; use only 4xx or 5xx status codes');
      }
      if (typeof status !== 'number' || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }

      // constructor
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        // create error
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        // add properties to generic error
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== 'status' && key !== 'statusCode') {
          err[key] = props[key];
        }
      }
      return err;
    }

    /**
     * Create HTTP error abstract base class.
     * @private
     */

    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError('cannot construct abstract class');
      }
      inherits(HttpError, Error);
      return HttpError;
    }

    /**
     * Create a constructor for a client error.
     * @private
     */

    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);

        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ClientError);

        // adjust the [[Prototype]]
        setPrototypeOf(err, ClientError.prototype);

        // redefine the error message
        Object.defineProperty(err, 'message', {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });

        // redefine the error name
        Object.defineProperty(err, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }

    /**
     * Create function to test is a value is a HttpError.
     * @private
     */

    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== 'object') {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === 'boolean' && typeof val.statusCode === 'number' && val.status === val.statusCode;
      };
    }

    /**
     * Create a constructor for a server error.
     * @private
     */

    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        // create the error object
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);

        // capture a stack trace to the construction point
        Error.captureStackTrace(err, ServerError);

        // adjust the [[Prototype]]
        setPrototypeOf(err, ServerError.prototype);

        // redefine the error message
        Object.defineProperty(err, 'message', {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });

        // redefine the error name
        Object.defineProperty(err, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }

    /**
     * Set the name of a function, if possible.
     * @private
     */

    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, 'name');
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, 'name', desc);
      }
    }

    /**
     * Populate the exports object with constructors for every error class.
     * @private
     */

    function populateConstructorExports(exports, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          // export the constructor
          exports[code] = CodeError;
          exports[name] = CodeError;
        }
      });
    }

    /**
     * Get a class name from a name identifier.
     * @private
     */

    function toClassName(name) {
      return name.substr(-5) !== 'Error' ? name + 'Error' : name;
    }
  })(httpErrors);
  return httpErrors.exports;
}

var lib$3 = {exports: {}};

/* eslint-disable node/no-deprecated-api */
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$9;
  var Buffer = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === 'SlowBuffer' || key === 'Buffer') continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer) {
    if (!Buffer.hasOwnProperty(key)) continue;
    if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
    Safer[key] = Buffer[key];
  }
  safer.Buffer.prototype = Buffer.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function (value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === 'undefined') {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
      }
      return Buffer(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
    } catch (e) {
      // we can't determine kStringMaxLength in environments where process.binding
      // is unsupported, so let's not set it
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}

var bomHandling$1 = {};

var hasRequiredBomHandling$1;
function requireBomHandling$1() {
  if (hasRequiredBomHandling$1) return bomHandling$1;
  hasRequiredBomHandling$1 = 1;
  var BOMChar = '\uFEFF';
  bomHandling$1.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function (str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function () {
    return this.encoder.end();
  };

  //------------------------------------------------------------------------------

  bomHandling$1.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function (buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function () {
    return this.decoder.end();
  };
  return bomHandling$1;
}

var encodings$1 = {};

var internal$1;
var hasRequiredInternal$1;
function requireInternal$1() {
  if (hasRequiredInternal$1) return internal$1;
  hasRequiredInternal$1 = 1;
  var Buffer = requireSafer().Buffer;

  // Export Node.js internal encodings.

  internal$1 = {
    // Encodings
    utf8: {
      type: "_internal",
      bomAware: true
    },
    cesu8: {
      type: "_internal",
      bomAware: true
    },
    unicode11utf8: "utf8",
    ucs2: {
      type: "_internal",
      bomAware: true
    },
    utf16le: "ucs2",
    binary: {
      type: "_internal"
    },
    base64: {
      type: "_internal"
    },
    hex: {
      type: "_internal"
    },
    // Codec.
    _internal: InternalCodec
  };

  //------------------------------------------------------------------------------

  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
      this.enc = "utf8"; // Use utf8 for decoding.
      this.encoder = InternalEncoderCesu8;

      // Add decoder for versions of Node not supporting CESU-8
      if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;

  //------------------------------------------------------------------------------

  // We use node.js internal decoder. Its signature is the same as ours.
  var StringDecoder = require$$1$5.StringDecoder;
  if (!StringDecoder.prototype.end)
    // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function () {};
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      buf = Buffer.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function () {
    return this.decoder.end();
  };

  //------------------------------------------------------------------------------
  // Encoder is mostly trivial

  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function (str) {
    return Buffer.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // Except base64 encoder, which must keep its state.

  function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
  }
  InternalEncoderBase64.prototype.write = function (str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function () {
    return Buffer.from(this.prevStr, "base64");
  };

  //------------------------------------------------------------------------------
  // CESU-8 encoder is also special.

  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length * 3),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      // Naive implementation, but it works because CESU-8 is especially easy
      // to convert from UTF-16 (which all JS strings are encoded in).
      if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
        buf[bufIdx++] = 0xC0 + (charCode >>> 6);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      } else {
        // charCode will always be < 0x10000 in javascript.
        buf[bufIdx++] = 0xE0 + (charCode >>> 12);
        buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // CESU-8 decoder is not implemented in Node v4.0+

  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function (buf) {
    var acc = this.acc,
      contBytes = this.contBytes,
      accBytes = this.accBytes,
      res = '';
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 0xC0) !== 0x80) {
        // Leading byte
        if (contBytes > 0) {
          // Previous code is invalid
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 0x80) {
          // Single-byte code
          res += String.fromCharCode(curByte);
        } else if (curByte < 0xE0) {
          // Two-byte code
          acc = curByte & 0x1F;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 0xF0) {
          // Three-byte code
          acc = curByte & 0x0F;
          contBytes = 2;
          accBytes = 1;
        } else {
          // Four or more are not supported for CESU-8.
          res += this.defaultCharUnicode;
        }
      } else {
        // Continuation byte
        if (contBytes > 0) {
          // We're waiting for it.
          acc = acc << 6 | curByte & 0x3f;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
            if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
              // Actually add character.
              res += String.fromCharCode(acc);
          }
        } else {
          // Unexpected continuation byte
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function () {
    var res = 0;
    if (this.contBytes > 0) res += this.defaultCharUnicode;
    return res;
  };
  return internal$1;
}

var utf32 = {};

var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer = requireSafer().Buffer;

  // == UTF32-LE/BE codec. ==========================================================

  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = {
    type: '_utf32',
    isLE: true
  };
  utf32.utf32be = {
    type: '_utf32',
    isLE: false
  };

  // Aliases
  utf32.ucs4le = 'utf32le';
  utf32.ucs4be = 'utf32be';
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;

  // -- Encoding

  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function (str) {
    var src = Buffer.from(str, 'ucs2');
    var dst = Buffer.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 0xD800 <= code && code < 0xDC00;
      var isLowSurrogate = 0xDC00 <= code && code < 0xE000;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
          // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
          // (technically wrong, but expected by some applications, like Windows file names).
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          // Create 32-bit value from high and low surrogates;
          var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate) this.highSurrogate = code;else {
        // Even if the current character is a low surrogate, with no previous high surrogate, we'll
        // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
        // unpaired high surrogates.
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length) dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function () {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate) return;
    var buf = Buffer.alloc(4);
    if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };

  // -- Decoding

  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function (src) {
    if (src.length === 0) return '';
    var i = 0;
    var codepoint = 0;
    var dst = Buffer.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++) overflow.push(src[i]);
      if (overflow.length === 4) {
        // NOTE: codepoint is a signed int32 and can be negative.
        // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }

    // Main loop. Should be as optimized as possible.
    for (; i < src.length - 3; i += 4) {
      // NOTE: codepoint is a signed int32 and can be negative.
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }

    // Keep overflowing bytes.
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString('ucs2');
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
    if (codepoint < 0 || codepoint > 0x10FFFF) {
      // Not a valid Unicode codepoint
      codepoint = badChar;
    }

    // Ephemeral Planes: Write high surrogate.
    if (codepoint >= 0x10000) {
      codepoint -= 0x10000;
      var high = 0xD800 | codepoint >> 10;
      dst[offset++] = high & 0xff;
      dst[offset++] = high >> 8;

      // Low surrogate is written below.
      var codepoint = 0xDC00 | codepoint & 0x3FF;
    }

    // Write BMP char or low surrogate.
    dst[offset++] = codepoint & 0xff;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function () {
    this.overflow.length = 0;
  };

  // == UTF-32 Auto codec =============================================================
  // Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
  // Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
  // Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

  // Encoder prepends BOM (which can be overridden with (addBOM: false}).

  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = 'utf32';
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

  // -- Encoding

  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
  }
  Utf32AutoEncoder.prototype.write = function (str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function () {
    return this.encoder.end();
  };

  // -- Decoding

  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function (buf) {
    if (!this.decoder) {
      // Codec is not chosen yet. Accumulate initial bytes.
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        // We need more bytes to use space heuristic (see below)
        return '';

      // We have enough bytes -> detect endianness.
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function () {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail) resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0,
      invalidBE = 0; // Number of invalid chars when decoded as LE or BE.
    var bmpCharsLE = 0,
      bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

    outer_loop: for (var i = 0; i < bufs.length; i++) {
      var buf = bufs[i];
      for (var j = 0; j < buf.length; j++) {
        b.push(buf[j]);
        if (b.length === 4) {
          if (charsProcessed === 0) {
            // Check BOM first.
            if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
              return 'utf-32le';
            }
            if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
              return 'utf-32be';
            }
          }
          if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
          if (b[3] !== 0 || b[2] > 0x10) invalidLE++;
          if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
          if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
          b.length = 0;
          charsProcessed++;
          if (charsProcessed >= 100) {
            break outer_loop;
          }
        }
      }
    }

    // Make decisions.
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return 'utf-32be';
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return 'utf-32le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-32le';
  }
  return utf32;
}

var utf16$1 = {};

var hasRequiredUtf16$1;
function requireUtf16$1() {
  if (hasRequiredUtf16$1) return utf16$1;
  hasRequiredUtf16$1 = 1;
  var Buffer = requireSafer().Buffer;

  // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

  // == UTF16-BE codec. ==========================================================

  utf16$1.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;

  // -- Encoding

  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function (str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function () {};

  // -- Decoding

  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function (buf) {
    if (buf.length == 0) return '';
    var buf2 = Buffer.alloc(buf.length + 1),
      i = 0,
      j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString('ucs2');
  };
  Utf16BEDecoder.prototype.end = function () {
    this.overflowByte = -1;
  };

  // == UTF-16 codec =============================================================
  // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
  // Defaults to UTF-16LE, as it's prevalent and default in Node.
  // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
  // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

  // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

  utf16$1.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;

  // -- Encoding (pass-through)

  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
  }
  Utf16Encoder.prototype.write = function (str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function () {
    return this.encoder.end();
  };

  // -- Decoding

  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function (buf) {
    if (!this.decoder) {
      // Codec is not chosen yet. Accumulate initial bytes.
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        // We need more bytes to use space heuristic (see below)
        return '';

      // We have enough bytes -> detect endianness.
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function () {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail) resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0,
      asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

    outer_loop: for (var i = 0; i < bufs.length; i++) {
      var buf = bufs[i];
      for (var j = 0; j < buf.length; j++) {
        b.push(buf[j]);
        if (b.length === 2) {
          if (charsProcessed === 0) {
            // Check BOM first.
            if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
            if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
          }
          if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
          if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
          b.length = 0;
          charsProcessed++;
          if (charsProcessed >= 100) {
            break outer_loop;
          }
        }
      }
    }

    // Make decisions.
    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
    // So, we count ASCII as if it was LE or BE, and decide from that.
    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-16le';
  }
  return utf16$1;
}

var utf7$1 = {};

var hasRequiredUtf7$1;
function requireUtf7$1() {
  if (hasRequiredUtf7$1) return utf7$1;
  hasRequiredUtf7$1 = 1;
  var Buffer = requireSafer().Buffer;

  // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
  // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

  utf7$1.utf7 = Utf7Codec;
  utf7$1.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;

  // -- Encoding

  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function (str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function (chunk) {
      return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function () {};

  // -- Decoding

  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = '+'.charCodeAt(0),
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);
  Utf7Decoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '+'
        if (buf[i] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64Chars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "+-" -> "+"
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus is absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };

  // UTF-7-IMAP codec.
  // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
  // Differences:
  //  * Base64 part is started by "&" instead of "+"
  //  * Direct characters are 0x20-0x7E, except "&" (0x26)
  //  * In Base64, "," is used instead of "/"
  //  * Base64 must not be used to represent direct characters.
  //  * No implicit shift back from Base64 (should always end with '-')
  //  * String must end in non-shifted position.
  //  * "-&" while in base64 is not allowed.

  utf7$1.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;

  // -- Encoding

  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function (str) {
    var inBase64 = this.inBase64,
      base64Accum = this.base64Accum,
      base64AccumIdx = this.base64AccumIdx,
      buf = Buffer.alloc(str.length * 5 + 10),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var uChar = str.charCodeAt(i);
      if (0x20 <= uChar && uChar <= 0x7E) {
        // Direct character or '&'.
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar; // Write direct character

          if (uChar === andChar)
            // Ampersand -> '&-'
            buf[bufIdx++] = minusChar;
        }
      } else {
        // Non-direct character
        if (!inBase64) {
          buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 0xFF;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function () {
    var buf = Buffer.alloc(10),
      bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };

  // -- Decoding

  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[','.charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '&'
        if (buf[i] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64IMAPChars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "&-" -> "&"
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus may be absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };
  return utf7$1;
}

var sbcsCodec$1 = {};

var hasRequiredSbcsCodec$1;
function requireSbcsCodec$1() {
  if (hasRequiredSbcsCodec$1) return sbcsCodec$1;
  hasRequiredSbcsCodec$1 = 1;
  var Buffer = requireSafer().Buffer;

  // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
  // correspond to encoded bytes (if 128 - then lower half is ASCII). 

  sbcsCodec$1._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

    // Prepare char buffer for decoding.
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function () {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function (buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length * 2);
    var idx1 = 0,
      idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString('ucs2');
  };
  SBCSDecoder.prototype.end = function () {};
  return sbcsCodec$1;
}

var sbcsData$1;
var hasRequiredSbcsData$1;
function requireSbcsData$1() {
  if (hasRequiredSbcsData$1) return sbcsData$1;
  hasRequiredSbcsData$1 = 1;

  // Manually added data to be used by sbcs codec in addition to generated one.

  sbcsData$1 = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData$1;
}

var sbcsDataGenerated$1;
var hasRequiredSbcsDataGenerated$1;
function requireSbcsDataGenerated$1() {
  if (hasRequiredSbcsDataGenerated$1) return sbcsDataGenerated$1;
  hasRequiredSbcsDataGenerated$1 = 1;

  // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
  sbcsDataGenerated$1 = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": ""
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated$1;
}

var dbcsCodec$1 = {};

var hasRequiredDbcsCodec$1;
function requireDbcsCodec$1() {
  if (hasRequiredDbcsCodec$1) return dbcsCodec$1;
  hasRequiredDbcsCodec$1 = 1;
  var Buffer = requireSafer().Buffer;

  // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
  // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
  // To save memory and loading time, we read table files only when requested.

  dbcsCodec$1._dbcs = DBCSCodec;
  var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START = -10,
    NODE_START = -1e3,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;
  for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

  // Class DBCSCodec reads and initializes mapping tables.
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();

    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
      this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

      // Add GB18030 common decode nodes.
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));

      // Fill out the tree
      var firstByteNode = this.decodeTables[0];
      for (var i = 0x81; i <= 0xFE; i++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
        for (var j = 0x30; j <= 0x39; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 0x81; k <= 0xFE; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 0x30; l <= 0x39; l++) {
              if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;

    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];

    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
      var val = codecOptions.encodeSkipVals[i];
      if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
    }

    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;

  // Decoder helpers
  DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8) bytes.push(addr & 0xFF);
    if (bytes.length == 0) bytes.push(0);
    var node = this.decodeTables[0];
    for (var i = bytes.length - 1; i > 0; i--) {
      // Traverse nodes deeper into the trie.
      var val = node[bytes[i]];
      if (val == UNASSIGNED) {
        // Create new node.
        node[bytes[i]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        // Existing node.
        node = this.decodeTables[NODE_START - val];
      } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function (chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        // String, write as-is.
        for (var l = 0; l < part.length;) {
          var code = part.charCodeAt(l++);
          if (0xD800 <= code && code < 0xDC00) {
            // Decode surrogate
            var codeTrail = part.charCodeAt(l++);
            if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (0x0FF0 < code && code <= 0x0FFF) {
            // Character sequence (our own encoding used)
            var len = 0xFFF - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else writeTable[curAddr++] = code; // Basic char
        }
      } else if (typeof part === "number") {
        // Integer, meaning increasing sequence starting with prev character.
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
      } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };

  // Encoder helpers
  DBCSCodec.prototype._getEncodeBucket = function (uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    var node;
    if (bucket[low] <= SEQ_START) {
      // There's already a sequence with  - use it.
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      // There was no sequence object - allocate a new one.
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === 'object') node = oldVal;else {
        node = node[uCode] = {};
        if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
      }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i = 0; i < 0x100; i++) {
      var uCode = node[i];
      var mbCode = prefix + i;
      if (skipEncodeChars[mbCode]) continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          // Skip empty subtrees (they are too large in gb18030).
          var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;else subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };

  // == Encoder ==================================================================

  function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;

    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function (str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
      leadSurrogate = this.leadSurrogate,
      seqObj = this.seqObj,
      nextChar = -1,
      i = 0,
      j = 0;
    while (true) {
      // 0. Get next character.
      if (nextChar === -1) {
        if (i == str.length) break;
        var uCode = str.charCodeAt(i++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }

      // 1. Handle surrogates.
      if (0xD800 <= uCode && uCode < 0xE000) {
        // Char is one of surrogates.
        if (uCode < 0xDC00) {
          // We've got lead surrogate.
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            // Double lead surrogate found.
            uCode = UNASSIGNED;
          }
        } else {
          // We've got trail surrogate.
          if (leadSurrogate !== -1) {
            uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
            leadSurrogate = -1;
          } else {
            // Incomplete surrogate pair - only trail surrogate found.
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        nextChar = uCode;
        uCode = UNASSIGNED; // Write an error, then current char.
        leadSurrogate = -1;
      }

      // 2. Convert uCode character.
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        // We are in the middle of the sequence
        var resCode = seqObj[uCode];
        if (typeof resCode === 'object') {
          // Sequence continues.
          seqObj = resCode;
          continue;
        } else if (typeof resCode == 'number') {
          // Sequence finished. Write it.
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          // Current character is not part of the sequence.

          // Try default character for this sequence
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode; // Found. Write it.
            nextChar = uCode; // Current character will be written too in the next iteration.
          }
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        // Regular character
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
        if (dbcsCode <= SEQ_START) {
          // Sequence start
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          // Use GB18030 algorithm to find character(s) to write.
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 0x30 + dbcsCode;
            continue;
          }
        }
      }

      // 3. Write dbcsCode character.
      if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 0x100) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 0x10000) {
        newBuf[j++] = dbcsCode >> 8; // high byte
        newBuf[j++] = dbcsCode & 0xFF; // low byte
      } else if (dbcsCode < 0x1000000) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 0xFF;
        newBuf[j++] = dbcsCode & 0xFF;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 0xFF;
        newBuf[j++] = dbcsCode >>> 8 & 0xFF;
        newBuf[j++] = dbcsCode & 0xFF;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function () {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10),
      j = 0;
    if (this.seqObj) {
      // We're in the sequence.
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        // Write beginning of the sequence.
        if (dbcsCode < 0x100) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8; // high byte
          newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
      }
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      // Incomplete surrogate pair - only lead surrogate found.
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };

  // Export for testing
  DBCSEncoder.prototype.findIdx = findIdx;

  // == Decoder ==================================================================

  function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBytes = [];

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function (buf) {
    var newBuf = Buffer.alloc(buf.length * 2),
      nodeIdx = this.nodeIdx,
      prevBytes = this.prevBytes,
      prevOffset = this.prevBytes.length,
      seqStart = -this.prevBytes.length,
      // idx of the start of current parsed sequence.
      uCode;
    for (var i = 0, j = 0; i < buf.length; i++) {
      var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];

      // Lookup in current trie node.
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ; else if (uCode === UNASSIGNED) {
        // Unknown char.
        // TODO: Callback with seq.
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
      } else if (uCode === GB18030_CODE) {
        if (i >= 3) {
          var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);
        } else {
          var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        // Go to next trie node.
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        // Output a sequence of chars.
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 0xFF;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

      // Write the character to buffer, handling higher planes using surrogate pair.
      if (uCode >= 0x10000) {
        uCode -= 0x10000;
        var uCodeLead = 0xD800 | uCode >> 10;
        newBuf[j++] = uCodeLead & 0xFF;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 0xDC00 | uCode & 0x3FF;
      }
      newBuf[j++] = uCode & 0xFF;
      newBuf[j++] = uCode >> 8;

      // Reset trie node.
      nodeIdx = 0;
      seqStart = i + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString('ucs2');
  };
  DBCSDecoder.prototype.end = function () {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBytes.length > 0) {
      // Skip 1 character in the buffer.
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);

      // Parse remaining as usual.
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0) ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };

  // Binary search for GB18030. Returns largest i such that table[i] <= val.
  function findIdx(table, val) {
    if (table[0] > val) return -1;
    var l = 0,
      r = table.length;
    while (l < r - 1) {
      // always table[l] <= val < table[r]
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val) l = mid;else r = mid;
    }
    return l;
  }
  return dbcsCodec$1;
}

var require$$0$1 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2$1 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3$1 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	[
		"8135f437",
		""
	]
];

var uChars$1 = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars$1 = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4$1 = {
	uChars: uChars$1,
	gbChars: gbChars$1
};

var require$$5$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7$1 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData$1;
var hasRequiredDbcsData$1;
function requireDbcsData$1() {
  if (hasRequiredDbcsData$1) return dbcsData$1;
  hasRequiredDbcsData$1 = 1;

  // Description of supported double byte encodings and aliases.
  // Tables are not require()-d until they are needed to speed up library load.
  // require()-s are direct to support Browserify.

  dbcsData$1 = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
      type: '_dbcs',
      table: function () {
        return require$$0$1;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      },
      encodeSkipVals: [{
        from: 0xED40,
        to: 0xF940
      }]
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',
    'eucjp': {
      type: '_dbcs',
      table: function () {
        return require$$1$1;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',
    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
      type: '_dbcs',
      table: function () {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
      type: '_dbcs',
      table: function () {
        return require$$2$1.concat(require$$3$1);
      }
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
      type: '_dbcs',
      table: function () {
        return require$$2$1.concat(require$$3$1);
      },
      gb18030: function () {
        return require$$4$1;
      },
      encodeSkipVals: [0x80],
      encodeAdd: {
        '': 0xA2E3
      }
    },
    'chinese': 'gb18030',
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
      type: '_dbcs',
      table: function () {
        return require$$5$1;
      }
    },
    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
      type: '_dbcs',
      table: function () {
        return require$$6$1;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
      type: '_dbcs',
      table: function () {
        return require$$6$1.concat(require$$7$1);
      },
      encodeSkipVals: [
      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
      0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe, 0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca, 0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62, 0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef, 0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,
      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
      0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce]
    },
    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs'
  };
  return dbcsData$1;
}

var hasRequiredEncodings$1;
function requireEncodings$1() {
  if (hasRequiredEncodings$1) return encodings$1;
  hasRequiredEncodings$1 = 1;
  (function (exports) {

    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [requireInternal$1(), requireUtf32(), requireUtf16$1(), requireUtf7$1(), requireSbcsCodec$1(), requireSbcsData$1(), requireSbcsDataGenerated$1(), requireDbcsCodec$1(), requireDbcsData$1()];

    // Put all encoding/alias/codec definitions to single object and export it.
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
    }
  })(encodings$1);
  return encodings$1;
}

var streams$1;
var hasRequiredStreams$1;
function requireStreams$1() {
  if (hasRequiredStreams$1) return streams$1;
  hasRequiredStreams$1 = 1;
  var Buffer = requireSafer().Buffer;

  // NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
  // we opt to dependency-inject it instead of creating a hard dependency.
  streams$1 = function (stream_module) {
    var Transform = stream_module.Transform;

    // == Encoder stream =======================================================

    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {
        value: IconvLiteEncoderStream
      }
    });
    IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
      if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function (done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function (cb) {
      var chunks = [];
      this.on('error', cb);
      this.on('data', function (chunk) {
        chunks.push(chunk);
      });
      this.on('end', function () {
        cb(null, Buffer.concat(chunks));
      });
      return this;
    };

    // == Decoder stream =======================================================

    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = 'utf8'; // We output strings.
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {
        value: IconvLiteDecoderStream
      }
    });
    IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
      if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function (done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function (cb) {
      var res = '';
      this.on('error', cb);
      this.on('data', function (chunk) {
        res += chunk;
      });
      this.on('end', function () {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream: IconvLiteEncoderStream,
      IconvLiteDecoderStream: IconvLiteDecoderStream
    };
  };
  return streams$1;
}

var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3.exports;
  hasRequiredLib$3 = 1;
  (function (module) {

    var Buffer = requireSafer().Buffer;
    var bomHandling = requireBomHandling$1(),
      iconv = module.exports;

    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;

    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '';
    iconv.defaultCharSingleByte = '?';

    // Public API.
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || ""); // Ensure string.

      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
          console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };

    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;

    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings) iconv.encodings = requireEncodings$1(); // Lazy load all encoding definitions.

      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      var enc = iconv._canonicalizeEncoding(encoding);

      // Traverse iconv.encodings to find actual codec.
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            // Direct alias to other encoding.
            enc = codecDef;
            break;
          case "object":
            // Alias with options. Can be layered.
            for (var key in codecDef) codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            // Codec itself.
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;

            // The codec function must load all tables and return object with .encoder and .decoder methods.
            // It'll be called only once (for each different options object).
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function (encoding) {
      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };

    // Streaming API
    // NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
    // up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
    // If you would like to enable it explicitly, please add the following code to your app:
    // > iconv.enableStreamingAPI(require('stream'));
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
      if (iconv.supportsStreams) return;

      // Dependency-inject stream module to create IconvLite stream classes.
      var streams = requireStreams$1()(stream_module);

      // Not public API yet, but expose the stream classes.
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

      // Streaming API.
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };

    // Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {}
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      // In rare cases where 'stream' module is not available by default, throw a helpful exception.
      iconv.encodeStream = iconv.decodeStream = function () {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$3);
  return lib$3.exports;
}

/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody$2;
var hasRequiredRawBody$1;
function requireRawBody$1() {
  if (hasRequiredRawBody$1) return rawBody$2;
  hasRequiredRawBody$1 = 1;

  /**
   * Module dependencies.
   * @private
   */

  var asyncHooks = tryRequireAsyncHooks();
  var bytes = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$3();
  var unpipe = requireUnpipe();

  /**
   * Module exports.
   * @public
   */

  rawBody$2 = getRawBody;

  /**
   * Module variables.
   * @private
   */

  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;

  /**
   * Get the decoder for a given encoding.
   *
   * @param {string} encoding
   * @private
   */

  function getDecoder(encoding) {
    if (!encoding) return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      // error getting decoder
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;

      // the encoding was not found
      throw createError(415, 'specified encoding unsupported', {
        encoding: encoding,
        type: 'encoding.unsupported'
      });
    }
  }

  /**
   * Get the raw body of a stream (typically HTTP).
   *
   * @param {object} stream
   * @param {object|string|function} [options]
   * @param {function} [callback]
   * @public
   */

  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};

    // light validation
    if (stream === undefined) {
      throw new TypeError('argument stream is required');
    } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
      throw new TypeError('argument stream must be a stream');
    }
    if (options === true || typeof options === 'string') {
      // short cut for encoding
      opts = {
        encoding: options
      };
    }
    if (typeof options === 'function') {
      done = options;
      opts = {};
    }

    // validate callback is a function, if provided
    if (done !== undefined && typeof done !== 'function') {
      throw new TypeError('argument callback must be a function');
    }

    // require the callback without promises
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError('argument callback is required');
    }

    // get encoding
    var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';

    // convert the limit to an integer
    var limit = bytes.parse(opts.limit);

    // convert the expected length to an integer
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      // classic callback style
      return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve(buf);
      });
    });
  }

  /**
   * Halt a stream.
   *
   * @param {Object} stream
   * @private
   */

  function halt(stream) {
    // unpipe everything from the stream
    unpipe(stream);

    // pause stream
    if (typeof stream.pause === 'function') {
      stream.pause();
    }
  }

  /**
   * Read the data from the stream.
   *
   * @param {object} stream
   * @param {string} encoding
   * @param {number} length
   * @param {number} limit
   * @param {function} callback
   * @public
   */

  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;

    // check the length and limit options.
    // note: we intentionally leave the stream paused,
    // so users should handle the stream themselves.
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, 'request entity too large', {
        expected: length,
        length: length,
        limit: limit,
        type: 'entity.too.large'
      }));
    }

    // streams1: assert request encoding is buffer.
    // streams2+: assert the stream encoding is buffer.
    //   stream._decoder: streams1
    //   state.encoding: streams2
    //   state.decoder: streams2, specifically < 0.10.6
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      // developer error
      return done(createError(500, 'stream encoding should not be set', {
        type: 'stream.encoding.set'
      }));
    }
    if (typeof stream.readable !== 'undefined' && !stream.readable) {
      return done(createError(500, 'stream is not readable', {
        type: 'stream.not.readable'
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? '' : [];

    // attach listeners
    stream.on('aborted', onAborted);
    stream.on('close', cleanup);
    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('error', onEnd);

    // mark sync section complete
    sync = false;
    function done() {
      var args = new Array(arguments.length);

      // copy arguments
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      // mark complete
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          // halt the stream on error
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError(400, 'request aborted', {
        code: 'ECONNABORTED',
        expected: length,
        length: length,
        received: received,
        type: 'request.aborted'
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, 'request entity too large', {
          limit: limit,
          received: received,
          type: 'entity.too.large'
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError(400, 'request size did not match content length', {
          expected: length,
          length: length,
          received: received,
          type: 'request.size.invalid'
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream.removeListener('aborted', onAborted);
      stream.removeListener('data', onData);
      stream.removeListener('end', onEnd);
      stream.removeListener('error', onEnd);
      stream.removeListener('close', cleanup);
    }
  }

  /**
   * Try to require async_hooks
   * @private
   */

  function tryRequireAsyncHooks() {
    try {
      return require('async_hooks');
    } catch (e) {
      return {};
    }
  }

  /**
   * Wrap function with async resource, if possible.
   * AsyncResource.bind static method backported.
   * @private
   */

  function wrap(fn) {
    var res;

    // create anonymous resource
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }

    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
      return fn;
    }

    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody$2;
}

var rawBodyExports = requireRawBody$1();
var rawBody$1 = /*@__PURE__*/getDefaultExportFromCjs(rawBodyExports);

var coBody = {exports: {}};

var lib$2 = {exports: {}};

var bomHandling = {};

var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = '\uFEFF';
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function (str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function () {
    return this.encoder.end();
  };

  //------------------------------------------------------------------------------

  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function (buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function () {
    return this.decoder.end();
  };
  return bomHandling;
}

var encodings = {};

var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer = requireSafer().Buffer;

  // Export Node.js internal encodings.

  internal = {
    // Encodings
    utf8: {
      type: "_internal",
      bomAware: true
    },
    cesu8: {
      type: "_internal",
      bomAware: true
    },
    unicode11utf8: "utf8",
    ucs2: {
      type: "_internal",
      bomAware: true
    },
    utf16le: "ucs2",
    binary: {
      type: "_internal"
    },
    base64: {
      type: "_internal"
    },
    hex: {
      type: "_internal"
    },
    // Codec.
    _internal: InternalCodec
  };

  //------------------------------------------------------------------------------

  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
      this.enc = "utf8"; // Use utf8 for decoding.
      this.encoder = InternalEncoderCesu8;

      // Add decoder for versions of Node not supporting CESU-8
      if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;

  //------------------------------------------------------------------------------

  // We use node.js internal decoder. Its signature is the same as ours.
  var StringDecoder = require$$1$5.StringDecoder;
  if (!StringDecoder.prototype.end)
    // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function () {};
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;

  //------------------------------------------------------------------------------
  // Encoder is mostly trivial

  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function (str) {
    return Buffer.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // Except base64 encoder, which must keep its state.

  function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
  }
  InternalEncoderBase64.prototype.write = function (str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function () {
    return Buffer.from(this.prevStr, "base64");
  };

  //------------------------------------------------------------------------------
  // CESU-8 encoder is also special.

  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length * 3),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      // Naive implementation, but it works because CESU-8 is especially easy
      // to convert from UTF-16 (which all JS strings are encoded in).
      if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
        buf[bufIdx++] = 0xC0 + (charCode >>> 6);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      } else {
        // charCode will always be < 0x10000 in javascript.
        buf[bufIdx++] = 0xE0 + (charCode >>> 12);
        buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // CESU-8 decoder is not implemented in Node v4.0+

  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function (buf) {
    var acc = this.acc,
      contBytes = this.contBytes,
      accBytes = this.accBytes,
      res = '';
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 0xC0) !== 0x80) {
        // Leading byte
        if (contBytes > 0) {
          // Previous code is invalid
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 0x80) {
          // Single-byte code
          res += String.fromCharCode(curByte);
        } else if (curByte < 0xE0) {
          // Two-byte code
          acc = curByte & 0x1F;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 0xF0) {
          // Three-byte code
          acc = curByte & 0x0F;
          contBytes = 2;
          accBytes = 1;
        } else {
          // Four or more are not supported for CESU-8.
          res += this.defaultCharUnicode;
        }
      } else {
        // Continuation byte
        if (contBytes > 0) {
          // We're waiting for it.
          acc = acc << 6 | curByte & 0x3f;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
            if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
              // Actually add character.
              res += String.fromCharCode(acc);
          }
        } else {
          // Unexpected continuation byte
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function () {
    var res = 0;
    if (this.contBytes > 0) res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}

var utf16 = {};

var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer = requireSafer().Buffer;

  // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

  // == UTF16-BE codec. ==========================================================

  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;

  // -- Encoding

  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function (str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function () {};

  // -- Decoding

  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function (buf) {
    if (buf.length == 0) return '';
    var buf2 = Buffer.alloc(buf.length + 1),
      i = 0,
      j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString('ucs2');
  };
  Utf16BEDecoder.prototype.end = function () {};

  // == UTF-16 codec =============================================================
  // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
  // Defaults to UTF-16LE, as it's prevalent and default in Node.
  // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
  // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

  // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;

  // -- Encoding (pass-through)

  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
  }
  Utf16Encoder.prototype.write = function (str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function () {
    return this.encoder.end();
  };

  // -- Decoding

  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function (buf) {
    if (!this.decoder) {
      // Codec is not chosen yet. Accumulate initial bytes.
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        // We need more bytes to use space heuristic (see below)
        return '';

      // We have enough bytes -> detect endianness.
      var buf = Buffer.concat(this.initialBytes),
        encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function () {
    if (!this.decoder) {
      var buf = Buffer.concat(this.initialBytes),
        encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf),
        trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';
    if (buf.length >= 2) {
      // Check BOM.
      if (buf[0] == 0xFE && buf[1] == 0xFF)
        // UTF-16BE BOM
        enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE)
        // UTF-16LE BOM
        enc = 'utf-16le';else {
        // No BOM found. Try to deduce encoding from initial content.
        // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
        // So, we count ASCII as if it was LE or BE, and decide from that.
        var asciiCharsLE = 0,
          asciiCharsBE = 0,
          // Counts of chars in both positions
          _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
      }
    }
    return enc;
  }
  return utf16;
}

var utf7 = {};

var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer = requireSafer().Buffer;

  // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
  // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;

  // -- Encoding

  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function (str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function (chunk) {
      return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function () {};

  // -- Decoding

  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = '+'.charCodeAt(0),
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);
  Utf7Decoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '+'
        if (buf[i] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64Chars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "+-" -> "+"
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i).toString();
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus is absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };

  // UTF-7-IMAP codec.
  // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
  // Differences:
  //  * Base64 part is started by "&" instead of "+"
  //  * Direct characters are 0x20-0x7E, except "&" (0x26)
  //  * In Base64, "," is used instead of "/"
  //  * Base64 must not be used to represent direct characters.
  //  * No implicit shift back from Base64 (should always end with '-')
  //  * String must end in non-shifted position.
  //  * "-&" while in base64 is not allowed.

  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;

  // -- Encoding

  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function (str) {
    var inBase64 = this.inBase64,
      base64Accum = this.base64Accum,
      base64AccumIdx = this.base64AccumIdx,
      buf = Buffer.alloc(str.length * 5 + 10),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var uChar = str.charCodeAt(i);
      if (0x20 <= uChar && uChar <= 0x7E) {
        // Direct character or '&'.
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar; // Write direct character

          if (uChar === andChar)
            // Ampersand -> '&-'
            buf[bufIdx++] = minusChar;
        }
      } else {
        // Non-direct character
        if (!inBase64) {
          buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 0xFF;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function () {
    var buf = Buffer.alloc(10),
      bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };

  // -- Decoding

  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[','.charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '&'
        if (buf[i] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64IMAPChars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "&-" -> "&"
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus may be absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };
  return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer = requireSafer().Buffer;

  // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
  // correspond to encoded bytes (if 128 - then lower half is ASCII). 

  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

    // Prepare char buffer for decoding.
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function () {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function (buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length * 2);
    var idx1 = 0,
      idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString('ucs2');
  };
  SBCSDecoder.prototype.end = function () {};
  return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;

  // Manually added data to be used by sbcs codec in addition to generated one.

  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;

  // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": ""
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer = requireSafer().Buffer;

  // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
  // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
  // To save memory and loading time, we read table files only when requested.

  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START = -10,
    NODE_START = -1e3,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;
  for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

  // Class DBCSCodec reads and initializes mapping tables.
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();

    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;

    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];

    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
      var val = codecOptions.encodeSkipVals[i];
      if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
    }

    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
      this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

      // Add GB18030 decode tables.
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i = 0x81; i <= 0xFE; i++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
      for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;

  // Decoder helpers
  DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);
    if (bytes.length == 0) bytes.push(0);
    var node = this.decodeTables[0];
    for (var i = bytes.length - 1; i > 0; i--) {
      // Traverse nodes deeper into the trie.
      var val = node[bytes[i]];
      if (val == UNASSIGNED) {
        // Create new node.
        node[bytes[i]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        // Existing node.
        node = this.decodeTables[NODE_START - val];
      } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function (chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        // String, write as-is.
        for (var l = 0; l < part.length;) {
          var code = part.charCodeAt(l++);
          if (0xD800 <= code && code < 0xDC00) {
            // Decode surrogate
            var codeTrail = part.charCodeAt(l++);
            if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (0x0FF0 < code && code <= 0x0FFF) {
            // Character sequence (our own encoding used)
            var len = 0xFFF - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else writeTable[curAddr++] = code; // Basic char
        }
      } else if (typeof part === "number") {
        // Integer, meaning increasing sequence starting with prev character.
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
      } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };

  // Encoder helpers
  DBCSCodec.prototype._getEncodeBucket = function (uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    var node;
    if (bucket[low] <= SEQ_START) {
      // There's already a sequence with  - use it.
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      // There was no sequence object - allocate a new one.
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === 'object') node = oldVal;else {
        node = node[uCode] = {};
        if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
      }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
      var uCode = node[i];
      var mbCode = prefix + i;
      if (skipEncodeChars[mbCode]) continue;
      if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };

  // == Encoder ==================================================================

  function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;

    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function (str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
      leadSurrogate = this.leadSurrogate,
      seqObj = this.seqObj,
      nextChar = -1,
      i = 0,
      j = 0;
    while (true) {
      // 0. Get next character.
      if (nextChar === -1) {
        if (i == str.length) break;
        var uCode = str.charCodeAt(i++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }

      // 1. Handle surrogates.
      if (0xD800 <= uCode && uCode < 0xE000) {
        // Char is one of surrogates.
        if (uCode < 0xDC00) {
          // We've got lead surrogate.
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            // Double lead surrogate found.
            uCode = UNASSIGNED;
          }
        } else {
          // We've got trail surrogate.
          if (leadSurrogate !== -1) {
            uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
            leadSurrogate = -1;
          } else {
            // Incomplete surrogate pair - only trail surrogate found.
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        nextChar = uCode;
        uCode = UNASSIGNED; // Write an error, then current char.
        leadSurrogate = -1;
      }

      // 2. Convert uCode character.
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        // We are in the middle of the sequence
        var resCode = seqObj[uCode];
        if (typeof resCode === 'object') {
          // Sequence continues.
          seqObj = resCode;
          continue;
        } else if (typeof resCode == 'number') {
          // Sequence finished. Write it.
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          // Current character is not part of the sequence.

          // Try default character for this sequence
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode; // Found. Write it.
            nextChar = uCode; // Current character will be written too in the next iteration.
          }
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        // Regular character
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
        if (dbcsCode <= SEQ_START) {
          // Sequence start
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          // Use GB18030 algorithm to find character(s) to write.
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 0x30 + dbcsCode;
            continue;
          }
        }
      }

      // 3. Write dbcsCode character.
      if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 0x100) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 0x10000) {
        newBuf[j++] = dbcsCode >> 8; // high byte
        newBuf[j++] = dbcsCode & 0xFF; // low byte
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 0xFF;
        newBuf[j++] = dbcsCode & 0xFF;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function () {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10),
      j = 0;
    if (this.seqObj) {
      // We're in the sequence.
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        // Write beginning of the sequence.
        if (dbcsCode < 0x100) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8; // high byte
          newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
      }
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      // Incomplete surrogate pair - only lead surrogate found.
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };

  // Export for testing
  DBCSEncoder.prototype.findIdx = findIdx;

  // == Decoder ==================================================================

  function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function (buf) {
    var newBuf = Buffer.alloc(buf.length * 2),
      nodeIdx = this.nodeIdx,
      prevBuf = this.prevBuf,
      prevBufOffset = this.prevBuf.length,
      seqStart = -this.prevBuf.length,
      // idx of the start of current parsed sequence.
      uCode;
    if (prevBufOffset > 0)
      // Make prev buf overlap a little to make it easier to slice later.
      prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    for (var i = 0, j = 0; i < buf.length; i++) {
      var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

      // Lookup in current trie node.
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ; else if (uCode === UNASSIGNED) {
        // Unknown char.
        // TODO: Callback with seq.
        //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
        i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        // Go to next trie node.
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        // Output a sequence of chars.
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 0xFF;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

      // Write the character to buffer, handling higher planes using surrogate pair.
      if (uCode > 0xFFFF) {
        uCode -= 0x10000;
        var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
        newBuf[j++] = uCodeLead & 0xFF;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 0xDC00 + uCode % 0x400;
      }
      newBuf[j++] = uCode & 0xFF;
      newBuf[j++] = uCode >> 8;

      // Reset trie node.
      nodeIdx = 0;
      seqStart = i + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
  };
  DBCSDecoder.prototype.end = function () {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
      // Skip 1 character in the buffer.
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);

      // Parse remaining as usual.
      this.prevBuf = Buffer.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0) ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };

  // Binary search for GB18030. Returns largest i such that table[i] <= val.
  function findIdx(table, val) {
    if (table[0] > val) return -1;
    var l = 0,
      r = table.length;
    while (l < r - 1) {
      // always table[l] <= val < table[r]
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val) l = mid;else r = mid;
    }
    return l;
  }
  return dbcsCodec;
}

var require$$0 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;

  // Description of supported double byte encodings and aliases.
  // Tables are not require()-d until they are needed to speed up library load.
  // require()-s are direct to support Browserify.

  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
      type: '_dbcs',
      table: function () {
        return require$$0;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      },
      encodeSkipVals: [{
        from: 0xED40,
        to: 0xF940
      }]
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',
    'eucjp': {
      type: '_dbcs',
      table: function () {
        return require$$1;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',
    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
      type: '_dbcs',
      table: function () {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
      type: '_dbcs',
      table: function () {
        return require$$2.concat(require$$3);
      }
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
      type: '_dbcs',
      table: function () {
        return require$$2.concat(require$$3);
      },
      gb18030: function () {
        return require$$4;
      },
      encodeSkipVals: [0x80],
      encodeAdd: {
        '': 0xA2E3
      }
    },
    'chinese': 'gb18030',
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
      type: '_dbcs',
      table: function () {
        return require$$5;
      }
    },
    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
      type: '_dbcs',
      table: function () {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
      type: '_dbcs',
      table: function () {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [0xa2cc]
    },
    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs'
  };
  return dbcsData;
}

var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function (exports) {

    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [requireInternal(), requireUtf16(), requireUtf7(), requireSbcsCodec(), requireSbcsData(), requireSbcsDataGenerated(), requireDbcsCodec(), requireDbcsData()];

    // Put all encoding/alias/codec definitions to single object and export it. 
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}

var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer = require$$0$9.Buffer,
    Transform = require$$1$4.Transform;

  // == Exports ==================================================================
  streams = function (iconv) {
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;

    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };

  // == Encoder stream =======================================================
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: {
      value: IconvLiteEncoderStream
    }
  });
  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
    if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length) this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function (done) {
    try {
      var res = this.conv.end();
      if (res && res.length) this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function (cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function (chunk) {
      chunks.push(chunk);
    });
    this.on('end', function () {
      cb(null, Buffer.concat(chunks));
    });
    return this;
  };

  // == Decoder stream =======================================================
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: {
      value: IconvLiteDecoderStream
    }
  });
  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
    if (!Buffer.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length) this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function (done) {
    try {
      var res = this.conv.end();
      if (res && res.length) this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function (cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function (chunk) {
      res += chunk;
    });
    this.on('end', function () {
      cb(null, res);
    });
    return this;
  };
  return streams;
}

var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer = require$$0$9.Buffer;
  // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

  // == Extend Node primitives to use iconv-lite =================================

  extendNode = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    // Note: this does use older Buffer API on a purpose
    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original) return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        'hex': true,
        'utf8': true,
        'utf-8': true,
        'ascii': true,
        'binary': true,
        'base64': true,
        'ucs2': true,
        'ucs-2': true,
        'utf16le': true,
        'utf-16le': true
      };
      Buffer.isNativeEncoding = function (enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };

      // -- SlowBuffer -----------------------------------------------------------
      var SlowBuffer = require$$0$9.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function (encoding, start, end) {
        encoding = String(encoding || 'utf8').toLowerCase();

        // Use native conversion when possible
        if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

        // Otherwise, use our decoding method.
        if (typeof start == 'undefined') start = 0;
        if (typeof end == 'undefined') end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function (string, offset, length, encoding) {
        // Support both (string, offset, length, encoding)
        // and the legacy (string, encoding, offset, length)
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          // legacy
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || 'utf8').toLowerCase();

        // Use native conversion when possible
        if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
        if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

        // Otherwise, use our encoding method.
        var buf = iconv.encode(string, encoding);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };

      // -- Buffer ---------------------------------------------------------------

      original.BufferIsEncoding = Buffer.isEncoding;
      Buffer.isEncoding = function (encoding) {
        return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer.byteLength;
      Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {
        encoding = String(encoding || 'utf8').toLowerCase();

        // Use native conversion when possible
        if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);

        // Slow, I know, but we don't have a better way yet.
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer.prototype.toString;
      Buffer.prototype.toString = function (encoding, start, end) {
        encoding = String(encoding || 'utf8').toLowerCase();

        // Use native conversion when possible
        if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

        // Otherwise, use our decoding method.
        if (typeof start == 'undefined') start = 0;
        if (typeof end == 'undefined') end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer.prototype.write;
      Buffer.prototype.write = function (string, offset, length, encoding) {
        var _offset = offset,
          _length = length,
          _encoding = encoding;
        // Support both (string, offset, length, encoding)
        // and the legacy (string, encoding, offset, length)
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          // legacy
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || 'utf8').toLowerCase();

        // Use native conversion when possible
        if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

        // Otherwise, use our encoding method.
        var buf = iconv.encode(string, encoding);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;

        // TODO: Set _charsWritten.
      };

      // -- Readable -------------------------------------------------------------
      if (iconv.supportsStreams) {
        var Readable = require$$1$4.Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          // Use our own decoder, it has the same interface.
          // We cannot use original function as it doesn't handle BOM-s.
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension) return;
      if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer.isNativeEncoding;
      var SlowBuffer = require$$0$9.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer.isEncoding = original.BufferIsEncoding;
      Buffer.byteLength = original.BufferByteLength;
      Buffer.prototype.toString = original.BufferToString;
      Buffer.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = require$$1$4.Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = undefined;
    };
  };
  return extendNode;
}

var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2.exports;
  hasRequiredLib$2 = 1;
  (function (module) {

    // Some environments don't have global Buffer (e.g. React Native).
    // Solution would be installing npm modules "buffer" and "stream" explicitly.
    var Buffer = requireSafer().Buffer;
    var bomHandling = requireBomHandling(),
      iconv = module.exports;

    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;

    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '';
    iconv.defaultCharSingleByte = '?';

    // Public API.
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || ""); // Ensure string.

      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
          console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };

    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;

    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings) iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.

      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      var enc = iconv._canonicalizeEncoding(encoding);

      // Traverse iconv.encodings to find actual codec.
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            // Direct alias to other encoding.
            enc = codecDef;
            break;
          case "object":
            // Alias with options. Can be layered.
            for (var key in codecDef) codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            // Codec itself.
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;

            // The codec function must load all tables and return object with .encoder and .decoder methods.
            // It'll be called only once (for each different options object).
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function (encoding) {
      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };

    // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
    var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
    if (nodeVer) {
      // Load streaming support in Node v0.10+
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams()(iconv);
      }

      // Load Node primitive extensions.
      requireExtendNode()(iconv);
    }
  })(lib$2);
  return lib$2.exports;
}

/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;

  /**
   * Module dependencies.
   * @private
   */

  var asyncHooks = tryRequireAsyncHooks();
  var bytes = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$2();
  var unpipe = requireUnpipe();

  /**
   * Module exports.
   * @public
   */

  rawBody = getRawBody;

  /**
   * Module variables.
   * @private
   */

  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;

  /**
   * Get the decoder for a given encoding.
   *
   * @param {string} encoding
   * @private
   */

  function getDecoder(encoding) {
    if (!encoding) return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      // error getting decoder
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;

      // the encoding was not found
      throw createError(415, 'specified encoding unsupported', {
        encoding: encoding,
        type: 'encoding.unsupported'
      });
    }
  }

  /**
   * Get the raw body of a stream (typically HTTP).
   *
   * @param {object} stream
   * @param {object|string|function} [options]
   * @param {function} [callback]
   * @public
   */

  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};

    // light validation
    if (stream === undefined) {
      throw new TypeError('argument stream is required');
    } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
      throw new TypeError('argument stream must be a stream');
    }
    if (options === true || typeof options === 'string') {
      // short cut for encoding
      opts = {
        encoding: options
      };
    }
    if (typeof options === 'function') {
      done = options;
      opts = {};
    }

    // validate callback is a function, if provided
    if (done !== undefined && typeof done !== 'function') {
      throw new TypeError('argument callback must be a function');
    }

    // require the callback without promises
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError('argument callback is required');
    }

    // get encoding
    var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';

    // convert the limit to an integer
    var limit = bytes.parse(opts.limit);

    // convert the expected length to an integer
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      // classic callback style
      return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve(buf);
      });
    });
  }

  /**
   * Halt a stream.
   *
   * @param {Object} stream
   * @private
   */

  function halt(stream) {
    // unpipe everything from the stream
    unpipe(stream);

    // pause stream
    if (typeof stream.pause === 'function') {
      stream.pause();
    }
  }

  /**
   * Read the data from the stream.
   *
   * @param {object} stream
   * @param {string} encoding
   * @param {number} length
   * @param {number} limit
   * @param {function} callback
   * @public
   */

  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;

    // check the length and limit options.
    // note: we intentionally leave the stream paused,
    // so users should handle the stream themselves.
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, 'request entity too large', {
        expected: length,
        length: length,
        limit: limit,
        type: 'entity.too.large'
      }));
    }

    // streams1: assert request encoding is buffer.
    // streams2+: assert the stream encoding is buffer.
    //   stream._decoder: streams1
    //   state.encoding: streams2
    //   state.decoder: streams2, specifically < 0.10.6
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      // developer error
      return done(createError(500, 'stream encoding should not be set', {
        type: 'stream.encoding.set'
      }));
    }
    if (typeof stream.readable !== 'undefined' && !stream.readable) {
      return done(createError(500, 'stream is not readable', {
        type: 'stream.not.readable'
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? '' : [];

    // attach listeners
    stream.on('aborted', onAborted);
    stream.on('close', cleanup);
    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('error', onEnd);

    // mark sync section complete
    sync = false;
    function done() {
      var args = new Array(arguments.length);

      // copy arguments
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      // mark complete
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          // halt the stream on error
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError(400, 'request aborted', {
        code: 'ECONNABORTED',
        expected: length,
        length: length,
        received: received,
        type: 'request.aborted'
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, 'request entity too large', {
          limit: limit,
          received: received,
          type: 'entity.too.large'
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError(400, 'request size did not match content length', {
          expected: length,
          length: length,
          received: received,
          type: 'request.size.invalid'
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream.removeListener('aborted', onAborted);
      stream.removeListener('data', onData);
      stream.removeListener('end', onEnd);
      stream.removeListener('error', onEnd);
      stream.removeListener('close', cleanup);
    }
  }

  /**
   * Try to require async_hooks
   * @private
   */

  function tryRequireAsyncHooks() {
    try {
      return require('async_hooks');
    } catch (e) {
      return {};
    }
  }

  /**
   * Wrap function with async resource, if possible.
   * AsyncResource.bind static method backported.
   * @private
   */

  function wrap(fn) {
    var res;

    // create anonymous resource
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
    }

    // incompatible node.js
    if (!res || !res.runInAsyncScope) {
      return fn;
    }

    // return bound function
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody;
}

var inflation;
var hasRequiredInflation;
function requireInflation() {
  if (hasRequiredInflation) return inflation;
  hasRequiredInflation = 1;
  var zlib = require$$3$4;
  inflation = inflate;
  function inflate(stream, options) {
    if (!stream) {
      throw new TypeError('argument stream is required');
    }
    options = options || {};
    var encoding = options.encoding || stream.headers && stream.headers['content-encoding'] || 'identity';
    var decompression;
    switch (encoding) {
      case 'gzip':
      case 'deflate':
        delete options.brotli;
        delete options.encoding;
        decompression = zlib.createUnzip(options);
        break;
      case 'br':
        if (zlib.createBrotliDecompress) {
          decompression = zlib.createBrotliDecompress(options.brotli);
        }
        break;
      case 'identity':
        return stream;
    }
    if (!decompression) {
      var err = new Error('Unsupported Content-Encoding: ' + encoding);
      err.status = 415;
      throw err;
    }
    return stream.pipe(decompression);
  }
  return inflation;
}

var lib$1 = {};

var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  (function (exports) {

    const internals = {
      suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
    };
    exports.parse = function (text, ...args) {
      // Normalize arguments

      const firstOptions = typeof args[0] === 'object' && args[0];
      const reviver = args.length > 1 || !firstOptions ? args[0] : undefined;
      const options = args.length > 1 && args[1] || firstOptions || {};

      // Parse normally, allowing exceptions

      const obj = JSON.parse(text, reviver);

      // options.protoAction: 'error' (default) / 'remove' / 'ignore'

      if (options.protoAction === 'ignore') {
        return obj;
      }

      // Ignore null and non-objects

      if (!obj || typeof obj !== 'object') {
        return obj;
      }

      // Check original string for potential exploit

      if (!text.match(internals.suspectRx)) {
        return obj;
      }

      // Scan result for proto keys

      exports.scan(obj, options);
      return obj;
    };
    exports.scan = function (obj, options = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {
            // Avoid calling node.hasOwnProperty directly
            if (options.protoAction !== 'remove') {
              throw new SyntaxError('Object contains forbidden prototype property');
            }
            delete node.__proto__;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === 'object') {
              next.push(node[key]);
            }
          }
        }
      }
    };
    exports.safeParse = function (text, reviver) {
      try {
        return exports.parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    };
  })(lib$1);
  return lib$1;
}

var utils$1 = {};

var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;

  /**
   * Module dependencies.
   */

  utils$1.clone = function (opts) {
    const options = {};
    opts = opts || {};
    for (const key in opts) {
      options[key] = opts[key];
    }
    return options;
  };
  return utils$1;
}

var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;

  /**
   * Module dependencies.
   */

  const raw = requireRawBody();
  const inflate = requireInflation();
  const bourne = requireLib$1();
  const utils = requireUtils$1();

  // Allowed whitespace is defined in RFC 7159
  // http://www.rfc-editor.org/rfc/rfc7159.txt
  const strictJSONReg = /^[\x20\x09\x0a\x0d]*(\[|\{)/;

  /**
   * Return a Promise which parses json requests.
   *
   * Pass a node request or an object with `.req`,
   * such as a koa Context.
   *
   * @param {Request} req
   * @param {Options} [opts]
   * @return {Function}
   * @api public
   */

  json = async function (req, opts) {
    req = req.req || req;
    opts = utils.clone(opts);

    // defaults
    const len = req.headers['content-length'];
    const encoding = req.headers['content-encoding'] || 'identity';
    if (len && encoding === 'identity') opts.length = ~~len;
    opts.encoding = opts.encoding || 'utf8';
    opts.limit = opts.limit || '1mb';
    const strict = opts.strict !== false;
    const protoAction = opts.onProtoPoisoning || 'error';
    const str = await raw(inflate(req), opts);
    try {
      const parsed = parse(str);
      return opts.returnRawBody ? {
        parsed,
        raw: str
      } : parsed;
    } catch (err) {
      err.status = 400;
      err.body = str;
      throw err;
    }
    function parse(str) {
      if (!strict) return str ? bourne.parse(str, {
        protoAction
      }) : str;
      // strict mode always return object
      if (!str) return {};
      // strict JSON test
      if (!strictJSONReg.test(str)) {
        throw new SyntaxError('invalid JSON, only supports object and array');
      }
      return bourne.parse(str, {
        protoAction
      });
    }
  };
  return json;
}

var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;

  /** @type {import('./type')} */
  type = TypeError;
  return type;
}

var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$2.inspect;
  return util_inspect;
}

var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === 'function' && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === 'function' && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
  // ie, `has-tostringtag/shams
  var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
  ? function (O) {
    return O.__proto__; // eslint-disable-line no-proto
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1000 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
      var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
      }
    }
    return $replace.call(str, sepRegex, '$&_');
  }
  var utilInspect = /*@__PURE__*/requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
      throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }
    if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === 'undefined') {
      return 'undefined';
    }
    if (obj === null) {
      return 'null';
    }
    if (typeof obj === 'boolean') {
      return obj ? 'true' : 'false';
    }
    if (typeof obj === 'string') {
      return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
      if (obj === 0) {
        return Infinity / obj > 0 ? '0' : '-0';
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
      var bigIntStr = String(obj) + 'n';
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
      return isArray(obj) ? '[Array]' : '[Object]';
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === 'undefined') {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return '[Circular]';
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, 'quoteStyle')) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === 'function' && !isRegExp(obj)) {
      // in older engines, regexes are callable
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
      return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = '<' + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
      }
      s += '>';
      if (obj.childNodes && obj.childNodes.length) {
        s += '...';
      }
      s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
      return s;
    }
    if (isArray(obj)) {
      if (obj.length === 0) {
        return '[]';
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return '[' + indentedJoin(xs, indent) + ']';
      }
      return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
        return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
      }
      if (parts.length === 0) {
        return '[' + String(obj) + ']';
      }
      return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
        return utilInspect(obj, {
          depth: maxDepth - depth
        });
      } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function (value, key) {
          mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
      }
      return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function (value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
      return '{ [object Window] }';
    }
    if (typeof globalThis !== 'undefined' && obj === globalThis || typeof commonjsGlobal !== 'undefined' && obj === commonjsGlobal) {
      return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? '' : 'null prototype';
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
      var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
      var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
      if (ys.length === 0) {
        return tag + '{}';
      }
      if (indent) {
        return tag + '{' + indentedJoin(ys, indent) + '}';
      }
      return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
  }
  function isArray(obj) {
    return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isDate(obj) {
    return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isRegExp(obj) {
    return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isString(obj) {
    return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isNumber(obj) {
    return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }
  function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
  }

  // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
      return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function (key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {}
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== 'object') {
      return false;
    }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: 'b',
      9: 't',
      10: 'n',
      12: 'f',
      13: 'r'
    }[n];
    if (x) {
      return '\\' + x;
    }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return 'Object(' + str + ')';
  }
  function weakCollectionOf(type) {
    return type + ' { ? }';
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], '\n') >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
      baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return '';
    }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
      }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap['$' + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      // eslint-disable-line no-restricted-syntax
      if (!has(obj, key)) {
        continue;
      } // eslint-disable-line no-restricted-syntax, no-continue
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      } // eslint-disable-line no-restricted-syntax, no-continue
      if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
        // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
        continue; // eslint-disable-line no-restricted-syntax, no-continue
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
      } else {
        xs.push(key + ': ' + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === 'function') {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}

var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = /*@__PURE__*/requireObjectInspect();
  var $TypeError = /*@__PURE__*/requireType();

  /*
  * This function traverses the list returning the node corresponding to the given key.
  *
  * That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
  * By doing so, all the recently used nodes can be accessed relatively quickly.
  */
  /** @type {import('./list.d.ts').listGetNode} */
  // eslint-disable-next-line consistent-return
  var listGetNode = function (list, key, isDelete) {
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */
    var prev = list;
    /** @type {(typeof list)['next']} */
    var curr;
    // eslint-disable-next-line eqeqeq
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          // eslint-disable-next-line no-extra-parens
          curr.next = /** @type {NonNullable<typeof list.next>} */list.next;
          list.next = curr; // eslint-disable-line no-param-reassign
        }
        return curr;
      }
    }
  };

  /** @type {import('./list.d.ts').listGet} */
  var listGet = function (objects, key) {
    if (!objects) {
      return undefined;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  /** @type {import('./list.d.ts').listSet} */
  var listSet = function (objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      // Prepend the new node to the beginning of the list
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */{
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key,
        next: objects.next,
        value: value
      };
    }
  };
  /** @type {import('./list.d.ts').listHas} */
  var listHas = function (objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  /** @type {import('./list.d.ts').listDelete} */
  // eslint-disable-next-line consistent-return
  var listDelete = function (objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };

  /** @type {import('.')} */
  sideChannelList = function getSideChannelList() {
    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */
    /** @typedef {Parameters<Channel['get']>[0]} K */
    /** @typedef {Parameters<Channel['set']>[1]} V */

    /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */var $o;

    /** @type {Channel} */
    var channel = {
      assert: function (key) {
        if (!channel.has(key)) {
          throw new $TypeError('Side channel does not contain ' + inspect(key));
        }
      },
      'delete': function (key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = undefined;
        }
        return !!deletedNode;
      },
      get: function (key) {
        return listGet($o, key);
      },
      has: function (key) {
        return listHas($o, key);
      },
      set: function (key, value) {
        if (!$o) {
          // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
          $o = {
            next: undefined
          };
        }
        // eslint-disable-next-line no-extra-parens
        listSet(/** @type {NonNullable<typeof $o>} */$o, key, value);
      }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
  };
  return sideChannelList;
}

var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;

  /** @type {import('.')} */
  esObjectAtoms = Object;
  return esObjectAtoms;
}

var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;

  /** @type {import('.')} */
  esErrors = Error;
  return esErrors;
}

var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;

  /** @type {import('./eval')} */
  _eval = EvalError;
  return _eval;
}

var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;

  /** @type {import('./range')} */
  range = RangeError;
  return range;
}

var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;

  /** @type {import('./ref')} */
  ref = ReferenceError;
  return ref;
}

var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;

  /** @type {import('./syntax')} */
  syntax = SyntaxError;
  return syntax;
}

var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;

  /** @type {import('./uri')} */
  uri = URIError;
  return uri;
}

var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;

  /** @type {import('./abs')} */
  abs = Math.abs;
  return abs;
}

var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;

  /** @type {import('./floor')} */
  floor = Math.floor;
  return floor;
}

var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;

  /** @type {import('./max')} */
  max = Math.max;
  return max;
}

var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;

  /** @type {import('./min')} */
  min = Math.min;
  return min;
}

var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;

  /** @type {import('./pow')} */
  pow = Math.pow;
  return pow;
}

var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;

  /** @type {import('./round')} */
  round = Math.round;
  return round;
}

var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;

  /** @type {import('./isNaN')} */
  _isNaN = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
  return _isNaN;
}

var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /*@__PURE__*/require_isNaN();

  /** @type {import('./sign')} */
  sign = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}

var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;

  /** @type {import('./gOPD')} */
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}

var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;

  /** @type {import('.')} */
  var $gOPD = /*@__PURE__*/requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], 'length');
    } catch (e) {
      // IE 8 has a broken gOPD
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}

var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;

  /** @type {import('.')} */
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, 'a', {
        value: 1
      });
    } catch (e) {
      // IE 8 has a broken defineProperty
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}

var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;

  /** @type {import('./shams')} */
  /* eslint complexity: [2, 18], max-statements: [2, 33] */
  shams = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
      return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
      return true;
    }

    /** @type {{ [k in symbol]?: unknown }} */
    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
      return false;
    }

    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }

    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
      // eslint-disable-next-line no-extra-parens
      var descriptor = /** @type {PropertyDescriptor} */Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}

var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== 'undefined' && Symbol;
  var hasSymbolSham = requireShams();

  /** @type {import('.')} */
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
      return false;
    }
    if (typeof Symbol !== 'function') {
      return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
      return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}

var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;

  /** @type {import('./Reflect.getPrototypeOf')} */
  Reflect_getPrototypeOf = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}

var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /*@__PURE__*/requireEsObjectAtoms();

  /** @type {import('./Object.getPrototypeOf')} */
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}

var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = '[object Function]';
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function () {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}

var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation = requireImplementation();
  functionBind = Function.prototype.bind || implementation;
  return functionBind;
}

var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;

  /** @type {import('./functionCall')} */
  functionCall = Function.prototype.call;
  return functionCall;
}

var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;

  /** @type {import('./functionApply')} */
  functionApply = Function.prototype.apply;
  return functionApply;
}

var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;

  /** @type {import('./reflectApply')} */
  reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
  return reflectApply;
}

var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();

  /** @type {import('./actualApply')} */
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}

var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /*@__PURE__*/requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();

  /** @type {import('.')} */
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
      throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}

var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD = /*@__PURE__*/requireGopd();
  var hasProtoAccessor;
  try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */[].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
      throw e;
    }
  }

  // eslint-disable-next-line no-extra-parens
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */'__proto__');
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;

  /** @type {import('./get')} */
  get = desc && typeof desc.get === 'function' ? callBind([desc.get]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
  return get;
}

var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /*@__PURE__*/requireGet();

  /** @type {import('.')} */
  getProto = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
      throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
  } : null;
  return getProto;
}

var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();

  /** @type {import('.')} */
  hasown = bind.call(call, $hasOwn);
  return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /*@__PURE__*/requireEsObjectAtoms();
  var $Error = /*@__PURE__*/requireEsErrors();
  var $EvalError = /*@__PURE__*/require_eval();
  var $RangeError = /*@__PURE__*/requireRange();
  var $ReferenceError = /*@__PURE__*/requireRef();
  var $SyntaxError = /*@__PURE__*/requireSyntax();
  var $TypeError = /*@__PURE__*/requireType();
  var $URIError = /*@__PURE__*/requireUri();
  var abs = /*@__PURE__*/requireAbs();
  var floor = /*@__PURE__*/requireFloor();
  var max = /*@__PURE__*/requireMax();
  var min = /*@__PURE__*/requireMin();
  var pow = /*@__PURE__*/requirePow();
  var round = /*@__PURE__*/requireRound();
  var sign = /*@__PURE__*/requireSign();
  var $Function = Function;

  // eslint-disable-next-line consistent-return
  var getEvalledConstructor = function (expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
  };
  var $gOPD = /*@__PURE__*/requireGopd();
  var $defineProperty = /*@__PURE__*/requireEsDefineProperty();
  var throwTypeError = function () {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function () {
    try {
      // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
      arguments.callee; // IE 8 does not throw here
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
        return $gOPD(arguments, 'callee').get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = requireHasSymbols()();
  var getProto = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    '%AsyncFromSyncIteratorPrototype%': undefined$1,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    // eslint-disable-line no-eval
    '%EvalError%': $EvalError,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
    '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
    '%Symbol%': hasSymbols ? Symbol : undefined$1,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
  };
  if (getProto) {
    try {
      null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
      // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
      var errorProto = getProto(getProto(e));
      INTRINSICS['%Error.prototype%'] = errorProto;
    }
  }
  var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
      value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
      value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
      value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
      var fn = doEval('%AsyncGeneratorFunction%');
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === '%AsyncIteratorPrototype%') {
      var gen = doEval('%AsyncGenerator%');
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype']
  };
  var bind = requireFunctionBind();
  var hasOwn = /*@__PURE__*/requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);

  /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
      throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
      throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function (match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
  };
  /* end adaptation */

  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === 'undefined' && !allowMissing) {
        throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
      }
      return {
        alias: alias,
        name: intrinsicName,
        value: value
      };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
      throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
        throw new $SyntaxError('property names with quotes must have matching quotes');
      }
      if (part === 'constructor' || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += '.' + part;
      intrinsicRealName = '%' + intrinsicBaseName + '%';
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
          }
          return undefined;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;

          // By convention, when a data property is converted to an accessor
          // property to emulate a data property that does not suffer from
          // the override mistake, that accessor's getter is marked with
          // an `originalValue` property. Here, when we detect this, we
          // uphold the illusion by pretending to see that original data
          // property, i.e., returning the value rather than the getter
          // itself.
          if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}

var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /*@__PURE__*/requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();

  /** @type {(thisArg: string, searchString: string, position?: number) => number} */
  var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

  /** @type {import('.')} */
  callBound = function callBoundIntrinsic(name, allowMissing) {
    // eslint-disable-next-line no-extra-parens
    var intrinsic = /** @type {Parameters<typeof callBindBasic>[0][0]} */GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
  return callBound;
}

var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /*@__PURE__*/requireGetIntrinsic();
  var callBound = /*@__PURE__*/requireCallBound();
  var inspect = /*@__PURE__*/requireObjectInspect();
  var $TypeError = /*@__PURE__*/requireType();
  var $Map = GetIntrinsic('%Map%', true);

  /** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
  var $mapGet = callBound('Map.prototype.get', true);
  /** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
  var $mapSet = callBound('Map.prototype.set', true);
  /** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
  var $mapHas = callBound('Map.prototype.has', true);
  /** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
  var $mapDelete = callBound('Map.prototype.delete', true);
  /** @type {<K, V>(thisArg: Map<K, V>) => number} */
  var $mapSize = callBound('Map.prototype.size', true);

  /** @type {import('.')} */
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */function getSideChannelMap() {
    /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
    /** @typedef {Parameters<Channel['get']>[0]} K */
    /** @typedef {Parameters<Channel['set']>[1]} V */

    /** @type {Map<K, V> | undefined} */var $m;

    /** @type {Channel} */
    var channel = {
      assert: function (key) {
        if (!channel.has(key)) {
          throw new $TypeError('Side channel does not contain ' + inspect(key));
        }
      },
      'delete': function (key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = undefined;
          }
          return result;
        }
        return false;
      },
      get: function (key) {
        // eslint-disable-line consistent-return
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function (key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function (key, value) {
        if (!$m) {
          // @ts-expect-error TS can't handle narrowing a variable inside a closure
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };

    // @ts-expect-error TODO: figure out why TS is erroring here
    return channel;
  };
  return sideChannelMap;
}

var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /*@__PURE__*/requireGetIntrinsic();
  var callBound = /*@__PURE__*/requireCallBound();
  var inspect = /*@__PURE__*/requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /*@__PURE__*/requireType();
  var $WeakMap = GetIntrinsic('%WeakMap%', true);

  /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
  var $weakMapGet = callBound('WeakMap.prototype.get', true);
  /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
  var $weakMapSet = callBound('WeakMap.prototype.set', true);
  /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
  var $weakMapHas = callBound('WeakMap.prototype.has', true);
  /** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
  var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

  /** @type {import('.')} */
  sideChannelWeakmap = $WeakMap ? /** @type {Exclude<import('.'), false>} */function getSideChannelWeakMap() {
    /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
    /** @typedef {Parameters<Channel['get']>[0]} K */
    /** @typedef {Parameters<Channel['set']>[1]} V */

    /** @type {WeakMap<K & object, V> | undefined} */var $wm;
    /** @type {Channel | undefined} */
    var $m;

    /** @type {Channel} */
    var channel = {
      assert: function (key) {
        if (!channel.has(key)) {
          throw new $TypeError('Side channel does not contain ' + inspect(key));
        }
      },
      'delete': function (key) {
        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap) {
          if ($m) {
            return $m['delete'](key);
          }
        }
        return false;
      },
      get: function (key) {
        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function (key) {
        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function (key, value) {
        if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap) {
          if (!$m) {
            $m = getSideChannelMap();
          }
          // eslint-disable-next-line no-extra-parens
          /** @type {NonNullable<typeof $m>} */
          $m.set(key, value);
        }
      }
    };

    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
  } : getSideChannelMap;
  return sideChannelWeakmap;
}

var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /*@__PURE__*/requireType();
  var inspect = /*@__PURE__*/requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

  /** @type {import('.')} */
  sideChannel = function getSideChannel() {
    /** @typedef {ReturnType<typeof getSideChannel>} Channel */

    /** @type {Channel | undefined} */var $channelData;

    /** @type {Channel} */
    var channel = {
      assert: function (key) {
        if (!channel.has(key)) {
          throw new $TypeError('Side channel does not contain ' + inspect(key));
        }
      },
      'delete': function (key) {
        return !!$channelData && $channelData['delete'](key);
      },
      get: function (key) {
        return $channelData && $channelData.get(key);
      },
      has: function (key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function (key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
  };
  return sideChannel;
}

var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
  };
  formats = {
    'default': Format.RFC3986,
    formatters: {
      RFC1738: function (value) {
        return replace.call(value, percentTwenties, '+');
      },
      RFC3986: function (value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}

var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var formats = /*@__PURE__*/requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== 'undefined') {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? {
      __proto__: null
    } : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== 'undefined') {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
      return target;
    }
    if (typeof source !== 'object' && typeof source !== 'function') {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === 'object') {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== 'object') {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function (item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function (acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function (str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
      // unescape never throws, no try...catch needed:
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;

  /* eslint operator-linebreak: [2, "before"] */

  var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === 'symbol') {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
      string = String(str);
    }
    if (charset === 'iso-8859-1') {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
        return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
      });
    }
    var out = '';
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 0x2D // -
        || c === 0x2E // .
        || c === 0x5F // _
        || c === 0x7E // ~
        || c >= 0x30 && c <= 0x39 // 0-9
        || c >= 0x41 && c <= 0x5A // a-z
        || c >= 0x61 && c <= 0x7A // A-Z
        || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
        ) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 0x80) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 0x800) {
          arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
          continue;
        }
        if (c < 0xD800 || c >= 0xE000) {
          arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
          continue;
        }
        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
        arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
      }
      out += arr.join('');
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{
      obj: {
        o: value
      },
      prop: 'o'
    }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
          queue.push({
            obj: obj,
            prop: key
          });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };
  var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
  };
  return utils;
}

var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils = /*@__PURE__*/requireUtils();
  var formats = /*@__PURE__*/requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
      return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats['default'];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
  };
  var sentinel = {};
  var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== undefined && !findFlag) {
      // Where object last appeared in the ref tree
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== 'undefined') {
        if (pos === step) {
          throw new RangeError('Cyclic object value');
        } else {
          findFlag = true; // Break while
        }
      }
      if (typeof tmpSc.get(sentinel) === 'undefined') {
        step = 0;
      }
    }
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
      obj = utils.maybeMap(obj, function (value) {
        if (value instanceof Date) {
          return serializeDate(value);
        }
        return value;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
      }
      obj = '';
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
        return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
      }
      return [formatter(prefix) + '=' + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
      // we need to join elements in
      if (encodeValuesOnly && encoder) {
        obj = utils.maybeMap(obj, encoder);
      }
      objKeys = [{
        value: obj.length > 0 ? obj.join(',') || null : undefined
      }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + '[]';
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === 'object' && key && typeof key.value !== 'undefined' ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
      throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
      throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
      throw new TypeError('Encoder has to be a function.');
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError('Unknown format option provided.');
      }
      format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
      arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
      throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots: allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat: arrayFormat,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter: filter,
      format: format,
      formatter: formatter,
      serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === 'function' ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  stringify_1 = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
      return '';
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
      if (options.charset === 'iso-8859-1') {
        // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
        prefix += 'utf8=%26%2310003%3B&';
      } else {
        // encodeURIComponent('')
        prefix += 'utf8=%E2%9C%93&';
      }
    }
    return joined.length > 0 ? prefix + joined : '';
  };
  return stringify_1;
}

var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var utils = /*@__PURE__*/requireUtils();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function (val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      return val.split(',');
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }
    return val;
  };

  // This is what browsers will submit when the  character occurs in an
  // application/x-www-form-urlencoded body and the encoding of the page containing
  // the form is iso-8859-1, or when the submitted form has an accept-charset
  // attribute of iso-8859-1. Presumably also with other charsets that do not contain
  // the  character, such as us-ascii.
  var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

  // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
  var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
      __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf('utf8=') === 0) {
          if (parts[i] === charsetSentinel) {
            charset = 'utf-8';
          } else if (parts[i] === isoSentinel) {
            charset = 'iso-8859-1';
          }
          skipIndex = i;
          i = parts.length; // The eslint settings do not allow break;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf(']=');
      var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, 'key');
        val = options.strictNullHandling ? null : '';
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function (encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, 'value');
        });
      }
      if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf('[]=') > -1) {
        val = isArray(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === 'combine') {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === 'last') {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function (chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
      var parentKey = chain.slice(0, -1).join('');
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === '[]' && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
      } else {
        obj = options.plainObjects ? {
          __proto__: null
        } : {};
        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === '') {
          obj = {
            0: leaf
          };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== '__proto__') {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
      // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
      }
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
      throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
      throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
      throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
      throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
      throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots: allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates: duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
  };
  parse = function (str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? {
        __proto__: null
      } : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? {
      __proto__: null
    } : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };
  return parse;
}

var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var stringify = /*@__PURE__*/requireStringify();
  var parse = /*@__PURE__*/requireParse();
  var formats = /*@__PURE__*/requireFormats();
  lib = {
    formats: formats,
    parse: parse,
    stringify: stringify
  };
  return lib;
}

var form;
var hasRequiredForm;
function requireForm() {
  if (hasRequiredForm) return form;
  hasRequiredForm = 1;

  /**
   * Module dependencies.
   */

  const raw = requireRawBody();
  const inflate = requireInflation();
  const qs = /*@__PURE__*/requireLib();
  const utils = requireUtils$1();

  /**
   * Return a Promise which parses x-www-form-urlencoded requests.
   *
   * Pass a node request or an object with `.req`,
   * such as a koa Context.
   *
   * @param {Request} req
   * @param {Options} [opts]
   * @return {Function}
   * @api public
   */

  form = async function (req, opts) {
    req = req.req || req;
    opts = utils.clone(opts);
    const queryString = opts.queryString || {};

    // keep compatibility with qs@4
    if (queryString.allowDots === undefined) queryString.allowDots = true;

    // defaults
    const len = req.headers['content-length'];
    const encoding = req.headers['content-encoding'] || 'identity';
    if (len && encoding === 'identity') opts.length = ~~len;
    opts.encoding = opts.encoding || 'utf8';
    opts.limit = opts.limit || '56kb';
    opts.qs = opts.qs || qs;
    const str = await raw(inflate(req), opts);
    try {
      const parsed = opts.qs.parse(str, queryString);
      return opts.returnRawBody ? {
        parsed,
        raw: str
      } : parsed;
    } catch (err) {
      err.status = 400;
      err.body = str;
      throw err;
    }
  };
  return form;
}

var text;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text;
  hasRequiredText = 1;

  /**
   * Module dependencies.
   */

  const raw = requireRawBody();
  const inflate = requireInflation();
  const utils = requireUtils$1();

  /**
   * Return a Promise which parses text/plain requests.
   *
   * Pass a node request or an object with `.req`,
   * such as a koa Context.
   *
   * @param {Request} req
   * @param {Options} [opts]
   * @return {Function}
   * @api public
   */

  text = async function (req, opts) {
    req = req.req || req;
    opts = utils.clone(opts);

    // defaults
    const len = req.headers['content-length'];
    const encoding = req.headers['content-encoding'] || 'identity';
    if (len && encoding === 'identity') opts.length = ~~len;
    opts.encoding = opts.encoding === undefined ? 'utf8' : opts.encoding;
    opts.limit = opts.limit || '1mb';
    const str = await raw(inflate(req), opts);
    // ensure return the same format with json / form
    return opts.returnRawBody ? {
      parsed: str,
      raw: str
    } : str;
  };
  return text;
}

var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;

  /**
   * Module dependencies.
   */

  const typeis = requireTypeIs();
  const json = requireJson();
  const form = requireForm();
  const text = requireText();
  const jsonTypes = ['json', 'application/*+json', 'application/csp-report'];
  const formTypes = ['urlencoded'];
  const textTypes = ['text'];

  /**
   * Return a Promise which parses form and json requests
   * depending on the Content-Type.
   *
   * Pass a node request or an object with `.req`,
   * such as a koa Context.
   *
   * @param {Request} req
   * @param {Options} [opts]
   * @return {Function}
   * @api public
   */

  any = async function (req, opts) {
    req = req.req || req;
    opts = opts || {};

    // json
    const jsonType = opts.jsonTypes || jsonTypes;
    if (typeis(req, jsonType)) return json(req, opts);

    // form
    const formType = opts.formTypes || formTypes;
    if (typeis(req, formType)) return form(req, opts);

    // text
    const textType = opts.textTypes || textTypes;
    if (typeis(req, textType)) return text(req, opts);

    // invalid
    const type = req.headers['content-type'] || '';
    const message = type ? 'Unsupported content-type: ' + type : 'Missing content-type';
    const err = new Error(message);
    err.status = 415;
    throw err;
  };
  return any;
}

var hasRequiredCoBody;
function requireCoBody() {
  if (hasRequiredCoBody) return coBody.exports;
  hasRequiredCoBody = 1;
  (function (module, exports) {

    exports = module.exports = requireAny();
    exports.json = requireJson();
    exports.form = requireForm();
    exports.text = requireText();
  })(coBody, coBody.exports);
  return coBody.exports;
}

var coBodyExports = requireCoBody();
var bodyParser = /*@__PURE__*/getDefaultExportFromCjs(coBodyExports);

var proxyAddr$1 = {exports: {}};

/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded) return forwarded_1;
  hasRequiredForwarded = 1;

  /**
   * Module exports.
   * @public
   */

  forwarded_1 = forwarded;

  /**
   * Get all addresses in the request, using the `X-Forwarded-For` header.
   *
   * @param {object} req
   * @return {array}
   * @public
   */

  function forwarded(req) {
    if (!req) {
      throw new TypeError('argument req is required');
    }

    // simple header parsing
    var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);

    // return all addresses
    return addrs;
  }

  /**
   * Get the socket address for a request.
   *
   * @param {object} req
   * @return {string}
   * @private
   */

  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }

  /**
   * Parse the X-Forwarded-For header.
   *
   * @param {string} header
   * @private
   */

  function parse(header) {
    var end = header.length;
    var list = [];
    var start = header.length;

    // gather addresses, backwards
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 0x20:
          /*   */
          if (start === end) {
            start = end = i;
          }
          break;
        case 0x2c:
          /* , */
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }

    // final address
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
  return forwarded_1;
}

var ipaddr$1 = {exports: {}};

var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr) return ipaddr$1.exports;
  hasRequiredIpaddr = 1;
  (function (module) {
    (function () {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (module !== null && module.exports) {
        module.exports = ipaddr;
      } else {
        root['ipaddr'] = ipaddr;
      }
      matchCIDR = function (first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function (address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = 'unicast';
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function () {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function () {
          return 'ipv4';
        };
        IPv4.prototype.toString = function () {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function () {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function () {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function (other, cidrRange) {
          var ref;
          if (cidrRange === undefined) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== 'ipv4') {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function () {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function () {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function () {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
        longValue: new RegExp("^" + ipv4Part + "$", 'i')
      };
      ipaddr.IPv4.parser = function (string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function (string) {
          if (string[0] === "0" && string[1] !== "x") {
            return parseInt(string, 8);
          } else {
            return parseInt(string);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function () {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 0xffffffff || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function () {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 0xff);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function () {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 0xffff)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function () {
          return 'ipv6';
        };
        IPv6.prototype.toString = function () {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
        };
        IPv6.prototype.toRFC5952String = function () {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function () {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 0xff);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function () {
          var addr, part, suffix;
          addr = function () {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = '';
          if (this.zoneId) {
            suffix = '%' + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function () {
          var addr, part, suffix;
          addr = function () {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, '0'));
            }
            return results;
          }.call(this).join(":");
          suffix = '';
          if (this.zoneId) {
            suffix = '%' + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function (other, cidrRange) {
          var ref;
          if (cidrRange === undefined) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== 'ipv6') {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
          rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
          '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function () {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function () {
          return this.range() === 'ipv4Mapped';
        };
        IPv6.prototype.toIPv4Address = function () {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function () {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, 'i'),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
      };
      expandIPv6 = function (string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, '');
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === '::') {
          colonCount--;
        }
        if (string.substr(-2, 2) === '::') {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ':';
        while (replacementCount--) {
          replacement += '0:';
        }
        string = string.replace('::', replacement);
        if (string[0] === ':') {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ':') {
          string = string.slice(0, -1);
        }
        parts = function () {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts: parts,
          zoneId: zoneId
        };
      };
      ipaddr.IPv6.parser = function (string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes['native'].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes['transitional'])) {
          zoneId = match[6] || '';
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function (string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function (string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function (string) {
        var addr;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr.IPv4.parse = function (string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function (string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function (string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, 'toString', {
              value: function () {
                return this.join('/');
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error('ipaddr: invalid IPv4 prefix length');
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function (string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
      };
      ipaddr.IPv6.parseCIDR = function (string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, 'toString', {
              value: function () {
                return this.join('/');
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function (string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function (string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function (string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error1) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function (bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function (string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(ipaddr);
  })(ipaddr$1);
  return ipaddr$1.exports;
}

/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr) return proxyAddr$1.exports;
  hasRequiredProxyAddr = 1;

  /**
   * Module exports.
   * @public
   */

  proxyAddr$1.exports = proxyaddr;
  proxyAddr$1.exports.all = alladdrs;
  proxyAddr$1.exports.compile = compile;

  /**
   * Module dependencies.
   * @private
   */

  var forwarded = requireForwarded();
  var ipaddr = requireIpaddr();

  /**
   * Variables.
   * @private
   */

  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;

  /**
   * Pre-defined IP ranges.
   * @private
   */

  var IP_RANGES = {
    linklocal: ['169.254.0.0/16', 'fe80::/10'],
    loopback: ['127.0.0.1/8', '::1/128'],
    uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
  };

  /**
   * Get all addresses in the request, optionally stopping
   * at the first untrusted.
   *
   * @param {Object} request
   * @param {Function|Array|String} [trust]
   * @public
   */

  function alladdrs(req, trust) {
    // get addresses
    var addrs = forwarded(req);
    if (!trust) {
      // Return all addresses
      return addrs;
    }
    if (typeof trust !== 'function') {
      trust = compile(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;
      addrs.length = i + 1;
    }
    return addrs;
  }

  /**
   * Compile argument into trust function.
   *
   * @param {Array|String} val
   * @private
   */

  function compile(val) {
    if (!val) {
      throw new TypeError('argument is required');
    }
    var trust;
    if (typeof val === 'string') {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError('unsupported trust argument');
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }

      // Splice in pre-defined range
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }

  /**
   * Compile `arr` elements into range subnets.
   *
   * @param {Array} arr
   * @private
   */

  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }

  /**
   * Compile range subnet array into trust function.
   *
   * @param {Array} rangeSubnets
   * @private
   */

  function compileTrust(rangeSubnets) {
    // Return optimized function based on length
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }

  /**
   * Parse IP notation string into range subnet.
   *
   * @param {String} note
   * @private
   */

  function parseipNotation(note) {
    var pos = note.lastIndexOf('/');
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError('invalid IP address: ' + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
      // Store as IPv4
      ip = ip.toIPv4Address();
    }
    var max = ip.kind() === 'ipv6' ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === 'ipv4' && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError('invalid range on address: ' + note);
    }
    return [ip, range];
  }

  /**
   * Parse netmask string into CIDR range.
   *
   * @param {String} netmask
   * @private
   */

  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;
  }

  /**
   * Determine address of proxied request.
   *
   * @param {Object} request
   * @param {Function|Array|String} trust
   * @public
   */

  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError('req argument is required');
    }
    if (!trust) {
      throw new TypeError('trust argument is required');
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }

  /**
   * Static trust function to trust nothing.
   *
   * @private
   */

  function trustNone() {
    return false;
  }

  /**
   * Compile trust function for multiple subnets.
   *
   * @param {Array} subnets
   * @private
   */

  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
            // Incompatible IP addresses
            continue;
          }
          if (!ipconv) {
            // Convert IP to match subnet IP kind
            ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }

  /**
   * Compile trust function for single subnet.
   *
   * @param {Object} subnet
   * @private
   */

  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === 'ipv4';
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          return false;
        }

        // Convert IP to match subnet IP kind
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr$1.exports;
}

var proxyAddrExports = requireProxyAddr();
var proxyAddr = /*@__PURE__*/getDefaultExportFromCjs(proxyAddrExports);

var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  cjs = deepmerge_1;
  return cjs;
}

requireCjs();

/**
 * A wrapper for the Node.js HTTP `ServerResponse` to implement the `IRawResponseWrapper` interface.
 *
 * This class provides methods for configuring and sending HTTP responses in a consistent and
 * flexible manner. It supports setting status codes, headers, streaming files, or sending raw body content.
 */
class ServerResponseWrapper {
  response;
  options;
  /**
   * Creates a new `ServerResponseWrapper` instance.
   *
   * @param response - The Node.js `ServerResponse` object to be wrapped.
   * @param options - Partial configuration for customizing the response.
   * @returns A new instance of `ServerResponseWrapper`.
   */
  static create(response, options = {}) {
    return new this(response, options);
  }
  /**
   * Constructs a `ServerResponseWrapper` instance.
   *
   * This constructor is private and intended to be used via the static `create` method.
   *
   * @param response - The Node.js `ServerResponse` object to be wrapped.
   * @param options - Partial configuration for customizing the response.
   */
  constructor(response, options = {}) {
    this.response = response;
    this.options = options;
  }
  /**
   * Sends the HTTP response based on the configured options.
   *
   * This method:
   * - Sets the `statusCode` and `statusMessage` if provided.
   * - Configures response `headers` if specified.
   * - Streams a file if `streamFile` is defined.
   * - Sends raw content if `body` is provided.
   *
   * @returns A promise that resolves to the HTTP status code of the response.
   *
   * @throws An error if the response cannot be sent due to an issue in `streamFile`.
   */
  async respond() {
    this.setStatus().setHeaders().sendBody();
    await this.streamFile();
    return this.hasBody() ? this.response : this.response.end();
  }
  /**
   * Sets the status code and status message of the response.
   *
   * If `statusCode` is not provided, the status code is not modified.
   */
  setStatus() {
    if (this.options.statusCode !== undefined) {
      this.response.statusCode = this.options.statusCode;
      this.response.statusMessage = this.options.statusMessage ?? '';
    }
    return this;
  }
  /**
   * Sets the headers for the response.
   *
   * If `headers` are not provided, this method does nothing.
   */
  setHeaders() {
    if (this.options.headers !== undefined) {
      this.response.setHeaders(this.options.headers);
    }
    return this;
  }
  /**
   * Streams a file as the response body.
   *
   * @throws An error if the file streaming operation fails.
   */
  async streamFile() {
    if (this.options.streamFile !== undefined) {
      await this.options.streamFile();
    }
  }
  /**
   * Sends the raw body content of the response.
   *
   * If `body` is not provided, this method does nothing.
   */
  sendBody() {
    if (this.options.body !== undefined) {
      this.response.end(this.options.body, this.options.charset ?? 'utf-8');
    }
    return this;
  }
  /**
   * Determines if the response has a body.
   *
   * @returns `true` if the response has a body, `false` otherwise.
   */
  hasBody() {
    return this.options.body !== undefined || this.options.streamFile !== undefined;
  }
}

/**
 * Custom error for node http adapter operations.
 */
class NodeHttpAdapterError extends IntegrationError {
  constructor(message, options) {
    super(message, options);
    this.name = 'NodeHttpAdapterError';
  }
}

/**
 * Node.js HTTP Adapter for the Stone.js framework.
 *
 * The `NodeHTTPAdapter` is responsible for integrating a Node.js HTTP/HTTPS server
 * with the Stone.js framework, converting incoming HTTP requests into `IncomingHttpEvent`
 * instances, and processing outgoing responses into the `OutgoingHttpResponse` format.
 *
 * It provides lifecycle hooks for initialization, termination, and error handling,
 * ensuring seamless integration with Stone.js.
 *
 * @template RawEvent - The raw HTTP event type (e.g., `IncomingMessage`).
 * @template RawResponse - The raw HTTP response type (e.g., `ServerResponse`).
 * @template Server - The server instance type (e.g., `NodeHttpServer`).
 * @template IncomingEvent - The Stone.js incoming event type (e.g., `IncomingHttpEvent`).
 * @template IncomingEventOptions - Options for creating an incoming event.
 * @template OutgoingResponse - The outgoing response type (e.g., `OutgoingHttpResponse`).
 * @template Context - The adapter context type (e.g., `NodeHttpAdapterContext`).
 *
 * @extends Adapter
 */
class NodeHttpAdapter extends Adapter {
  /**
   * The base URL for the server, derived from the Stone.js blueprint configuration.
   */
  url;
  /**
   * The HTTP/HTTPS server instance created by the adapter.
   */
  server;
  /**
   * Creates a new `NodeHTTPAdapter` instance.
   *
   * @param options - Configuration options for the adapter, including lifecycle event handlers,
   *                  logger, and dependency injection via the blueprint.
   * @returns A new instance of `NodeHTTPAdapter`.
   *
   * @example
   * ```typescript
   * const adapter = NodeHTTPAdapter.create({
   *   blueprint,
   *   handlerResolver,
   *   logger,
   * });
   * await adapter.run();
   * ```
   */
  static create(options) {
    return new this(options);
  }
  /**
   * Constructs a `NodeHTTPAdapter` instance.
   *
   * This constructor is protected and is intended to be used via the static `create` method.
   *
   * @param options - Configuration options for the adapter.
   * @protected
   */
  constructor(options) {
    super(options);
    this.url = new URL(this.blueprint.get('stone.adapter.url', 'http://localhost:8080'));
    this.server = this.createServer();
  }
  /**
   * Starts the HTTP/HTTPS server and listens for incoming requests.
   *
   * @returns A promise that resolves to an ExecutionResultType (usually `NodeHttpServer`) when the server starts successfully.
   *
   * @throws {NodeHttpAdapterError} If the server encounters an error during initialization.
   *
   * @example
   * ```typescript
   * const adapter = NodeHTTPAdapter.create(options);
   * await adapter.run();
   * console.log('Server is running');
   * ```
   */
  async run() {
    await this.onInit();
    return await new Promise((resolve, reject) => {
      this.server.once('error', error => reject(error)).listen(Number(this.url.port), this.url.hostname, () => resolve(this.server));
    });
  }
  /**
   * Lifecycle hook for adapter initialization.
   *
   * This method is called during the adapter's startup process and performs tasks
   * such as setting up exception listeners and verifying the runtime environment.
   *
   * @throws {NodeHttpAdapterError} If the adapter is used outside a Node.js context.
   */
  async onInit() {
    if (typeof window === 'object') {
      throw new NodeHttpAdapterError('This `NodeHTTPAdapter` must be used only in Node.js context.');
    }
    this.catchUncaughtExceptionListener();
    await super.onInit();
  }
  /**
   * Lifecycle hook for adapter termination.
   *
   * This method is called when the adapter needs to gracefully terminate,
   * ensuring all responses are completed before shutdown.
   *
   * @param eventHandler - The lifecycle event handler.
   * @param context - The context for the lifecycle event.
   */
  async onTerminate(eventHandler, context) {
    if (context.rawResponse !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/no-misused-promises */
      onFinished$2(context.rawResponse, async () => await super.onTerminate(eventHandler, context));
    }
  }
  /**
   * Handles incoming HTTP requests and sends them through the adapter's event pipeline.
   *
   * @param rawEvent - The raw HTTP request object.
   * @param rawResponse - The raw HTTP response object.
   * @returns A promise resolving to a ServerResponse (e.g., `ServerResponse`).
   *
   * @protected
   */
  async eventListener(rawEvent, rawResponse) {
    const eventHandler = this.handlerResolver(this.blueprint);
    await this.onPrepare(eventHandler);
    const incomingEventBuilder = AdapterEventBuilder.create({
      resolver: options => IncomingHttpEvent.create(options)
    });
    const rawResponseBuilder = AdapterEventBuilder.create({
      resolver: options => ServerResponseWrapper.create(rawResponse, options)
    });
    return await this.sendEventThroughDestination(eventHandler, {
      rawEvent,
      rawResponse,
      rawResponseBuilder,
      incomingEventBuilder,
      executionContext: this.server
    });
  }
  /**
   * Creates the HTTP or HTTPS server based on the adapter's configuration.
   *
   * @returns A `NodeHttpServer` instance.
   *
   * @protected
   */
  createServer() {
    // Create a connect app to handle server middleware
    const app = connect();
    this.blueprint.get('stone.adapter.serverMiddleware', []).forEach(middleware => app.use(middleware));
    /* eslint-disable-next-line @typescript-eslint/no-misused-promises */
    app.use(async (message, response) => await this.eventListener(message, response));
    if (this.url.protocol.includes('https')) {
      const options = this.blueprint.get('stone.adapter.server', {});
      return createServer(options, app);
    } else {
      const options = this.blueprint.get('stone.adapter.server', {});
      return createServer$1(options, app);
    }
  }
  /**
   * Adds listeners for uncaught exceptions and unhandled promise rejections.
   *
   * Logs errors and ensures the server shuts down gracefully in case of critical errors.
   *
   * @protected
   */
  catchUncaughtExceptionListener() {
    process.on('uncaughtException', error => {
      this.logger.error('Uncaught exception detected.', {
        error
      });
      this.server.close(() => process.exit(1));
      setTimeout(() => process.abort(), 1000).unref();
    }).on('unhandledRejection', (reason, promise) => {
      this.logger.error(`Unhandled Rejection at: ${String(promise)}, reason: ${String(reason)}`);
    });
  }
}

/**
 * Class representing an NodeHttpErrorHandler.
 */
class NodeHttpErrorHandler {
  logger;
  /**
   * Create an NodeHttpErrorHandler.
   *
   * @param options - NodeHttpErrorHandler options.
   */
  constructor({
    logger
  }) {
    if (logger === undefined) {
      throw new IntegrationError('Logger is required to create an NodeHttpErrorHandler instance.');
    }
    this.logger = logger;
  }
  /**
   * Handle an error.
   *
   * @param error - The error to handle.
   * @param context - The context of the adapter.
   * @returns The raw response.
   */
  async handle(error, context) {
    const type = accepts(context.rawEvent).type(['json', 'html']);
    const contentType = mime.getType(type !== false ? type : 'txt') ?? 'text/plain';
    const headers = new Headers({
      'Content-Type': contentType
    });
    context.rawResponseBuilder.add('headers', headers).add('statusCode', HTTP_INTERNAL_SERVER_ERROR).add('statusMessage', statuses.message[HTTP_INTERNAL_SERVER_ERROR]);
    this.logger.error(error.message, {
      error
    });
    return await context.rawResponseBuilder.build().respond();
  }
}

/**
 * A constant representing the Node.js HTTP platform identifier.
 *
 * This constant is used as an alias for the Node.js HTTP Adapter within the Stone.js framework.
 * It helps in identifying and configuring platform-specific adapters or components for handling
 * HTTP requests and responses.
 */
const NODE_HTTP_PLATFORM = 'node_http';

/**
 * Resolver function for the HTTP adapter.
 *
 * This function creates a `NodeHTTPAdapter` instance, which acts as the bridge between the HTTP server and the Stone.js framework.
 *
 * @param blueprint - The application blueprint for dependency resolution.
 * @returns An `AdapterResolver` instance for managing HTTP interactions.
 */
const nodeHttpAdapterResolver = blueprint => {
  const hooks = blueprint.get('stone.adapter.hooks', {});
  const loggerResolver = blueprint.get('stone.logger.resolver', defaultLoggerResolver);
  const handlerResolver = blueprint.get('stone.kernel.resolver', defaultKernelResolver);
  return NodeHttpAdapter.create({
    hooks,
    blueprint,
    handlerResolver,
    logger: loggerResolver(blueprint)
  });
};

/**
 * Class representing a BodyEventMiddleware.
 *
 * This middleware handles platform-specific messages and transforms them into Stone.js IncomingEvent objects.
 *
 * @author Mr. Stone
 */
class BodyEventMiddleware {
  /**
   * The blueprint for resolving configuration and dependencies.
   */
  blueprint;
  /**
   * Create a BodyEventMiddleware.
   *
   * @param {blueprint} options - Options for creating the BodyEventMiddleware.
   */
  constructor({
    blueprint
  }) {
    this.blueprint = blueprint;
  }
  /**
   * Handles the incoming event, processes it, and invokes the next middleware in the pipeline.
   *
   * @param context - The adapter context containing the raw event, execution context, and other data.
   * @param next - The next middleware to be invoked in the pipeline.
   * @returns A promise that resolves to the destination type after processing.
   *
   * @throws {NodeHttpAdapterError} If required components such as the rawEvent or IncomingEventBuilder are not provided.
   */
  async handle(context, next) {
    if (context.rawEvent === undefined || context.incomingEventBuilder?.add === undefined) {
      throw new NodeHttpAdapterError('The context is missing required components.');
    }
    if (!isMultipart(context.rawEvent)) {
      const body = await this.getBody(context.rawEvent);
      context.incomingEventBuilder.add('body', body).add('metadata', body);
    }
    return await next(context);
  }
  /**
   * Extract and parse the body from the message.
   *
   * @param message - The incoming HTTP message.
   * @returns A Promise resolving to the parsed body.
   * @throws {NodeHttpAdapterError} If the body parsing fails or is invalid.
   */
  async getBody(message) {
    if (!typeIs.hasBody(message)) {
      return {};
    }
    const defaultOptions = {
      limit: '100kb',
      defaultType: 'text/plain',
      defaultCharset: 'utf-8'
    };
    const {
      defaultType,
      defaultCharset,
      limit: rawLimit
    } = this.blueprint.get('stone.http.body', defaultOptions);
    const limit = bytes.parse(rawLimit) ?? 100000;
    const length = message.headers['content-length'];
    const encoding = getCharset(message, defaultCharset);
    try {
      switch (typeIs(message, ['urlencoded', 'json', 'text', 'bin']) ?? defaultType) {
        case 'bin':
          return await rawBody$1(message, {
            length,
            limit
          });
        case 'json':
          return await bodyParser.json(message, {
            limit,
            encoding
          });
        case 'text':
          return await bodyParser.text(message, {
            limit,
            encoding
          });
        case 'urlencoded':
          return await bodyParser.form(message, {
            limit,
            encoding
          });
        default:
          return {};
      }
    } catch (error) {
      throw new NodeHttpAdapterError('The context is missing required components.', {
        cause: error
      });
    }
  }
}
/**
 * Meta Middleware for processing the request body.
 */
classMiddleware(BodyEventMiddleware);

/**
 * Class representing a FilesEventMiddleware.
 *
 * @author Mr. Stone <evensstone@gmail.com>
 */
class FilesEventMiddleware {
  /**
   * The blueprint for resolving configuration and dependencies.
   */
  blueprint;
  /**
   * Create a FilesEventMiddleware.
   *
   * @param {blueprint} options - Options for creating the FilesEventMiddleware.
   */
  constructor({
    blueprint
  }) {
    this.blueprint = blueprint;
  }
  /**
   * Handles the incoming event, processes it, and invokes the next middleware in the pipeline.
   *
   * @param context - The adapter context containing the raw event, execution context, and other data.
   * @param next - The next middleware to be invoked in the pipeline.
   * @returns A promise that resolves to the destination type after processing.
   *
   * @throws {NodeHttpAdapterError} If required components such as the rawEvent or IncomingEventBuilder are not provided.
   */
  async handle(context, next) {
    if (context.rawEvent === undefined || context.incomingEventBuilder?.add === undefined) {
      throw new NodeHttpAdapterError('The context is missing required components.');
    }
    if (isMultipart(context.rawEvent)) {
      const options = this.blueprint.get('stone.http.files.upload', {});
      const response = await getFilesUploads(context.rawEvent, options);
      context.incomingEventBuilder.add('files', response.files).add('body', response.fields);
    }
    return await next(context);
  }
}
/**
 * Meta Middleware for processing files uploads.
 */
classMiddleware(FilesEventMiddleware);

/**
 * Middleware for handling incoming events and transforming them into Stone.js events.
 *
 * This class processes incoming HTTP requests, extracting relevant data such as URL, IP addresses,
 * headers, cookies, and more, and forwards them to the next middleware in the pipeline.
 */
class IncomingEventMiddleware {
  /**
   * The blueprint for resolving configuration and dependencies.
   */
  blueprint;
  /**
   * Create an IncomingEventMiddleware instance.
   *
   * @param {blueprint} options - Options containing the blueprint for resolving configuration and dependencies.
   */
  constructor({
    blueprint
  }) {
    this.blueprint = blueprint;
  }
  /**
   * Handles the incoming event, processes it, and invokes the next middleware in the pipeline.
   *
   * @param context - The adapter context containing the raw event, execution context, and other data.
   * @param next - The next middleware to be invoked in the pipeline.
   * @returns A promise that resolves to the processed context.
   * @throws {NodeHttpAdapterError} If required components are missing in the context.
   */
  async handle(context, next) {
    if (context.rawEvent == null || context.incomingEventBuilder?.add == null) {
      throw new NodeHttpAdapterError('The context is missing required components.');
    }
    const proxyOptions = this.getProxyOptions();
    const cookieOptions = this.getCookieOptions();
    const url = this.extractUrl(context.rawEvent, proxyOptions);
    const ipAddresses = this.extractIpAddresses(context.rawEvent, proxyOptions);
    context.incomingEventBuilder.add('url', url).add('ips', ipAddresses).add('queryString', url.search).add('method', context.rawEvent.method).add('source', this.getSource(context)).add('headers', context.rawEvent.headers).add('protocol', this.getProtocol(context.rawEvent, proxyOptions)).add('ip', proxyAddr(context.rawEvent, isIpTrusted(proxyOptions.trustedIp, proxyOptions.untrustedIp))).add('cookies', CookieCollection.create(context.rawEvent.headers.cookie, cookieOptions, this.getCookieSecret()));
    return await next(context);
  }
  /**
   * Create the IncomingEventSource from the context.
   *
   * @param context - The adapter context containing the raw event, execution context, and other data.
   * @returns The Incoming Event Source.
   */
  getSource(context) {
    return {
      rawEvent: context.rawEvent,
      platform: NODE_HTTP_PLATFORM,
      rawResponse: context.rawResponse,
      rawContext: context.executionContext
    };
  }
  /**
   * Extracts proxy-related options from the blueprint.
   *
   * @returns Proxy options.
   */
  getProxyOptions() {
    const defaultProxyOptions = {
      trusted: [],
      trustedIp: [],
      untrustedIp: []
    };
    const proxyOptions = this.blueprint.get('stone.http.proxies', defaultProxyOptions);
    proxyOptions.trusted = this.blueprint.get('stone.http.hosts.trusted', []);
    return proxyOptions;
  }
  /**
   * Retrieves cookie-related options from the blueprint.
   *
   * @returns Cookie options.
   */
  getCookieOptions() {
    return this.blueprint.get('stone.http.cookie.options', {});
  }
  /**
   * Retrieves the cookie secret from the blueprint.
   *
   * @returns The cookie secret string.
   */
  getCookieSecret() {
    return this.blueprint.get('stone.http.cookie.secret', this.blueprint.get('stone.secret', ''));
  }
  /**
   * Extracts and parses the URL from the incoming message.
   *
   * @param message - The incoming HTTP message.
   * @param options - Proxy options.
   * @returns The parsed URL object.
   */
  extractUrl(message, options) {
    const hostname = getHostname(message.socket.remoteAddress ?? '', message.headers, options);
    const proto = getProtocol(message.socket.remoteAddress ?? '', message.headers, message.socket instanceof TLSSocket, options);
    return new URL(message.url ?? '', `${String(proto)}://${String(hostname)}`);
  }
  /**
   * Extracts a list of IP addresses from the incoming message.
   *
   * @param message - The incoming HTTP message.
   * @param options - Proxy options.
   * @returns An array of IP addresses.
   */
  extractIpAddresses(message, options) {
    const isTrusted = isIpTrusted(options.trustedIp, options.untrustedIp);
    return proxyAddr.all(message, isTrusted).slice(1).reverse();
  }
  /**
   * Determines the protocol from the incoming message.
   *
   * @param message - The incoming message.
   * @param options - Proxy options.
   * @returns The protocol string.
   */
  getProtocol(message, options) {
    return getProtocol(message.socket.remoteAddress ?? '', message.headers, message.socket instanceof TLSSocket, options);
  }
}
/**
 * Meta Middleware for processing incoming events.
 */
const MetaIncomingEventMiddleware = classMiddleware(IncomingEventMiddleware);

/**
 * Middleware for handling server responses and transforming them into the appropriate HTTP responses.
 *
 * This middleware processes outgoing responses and attaches the necessary headers, status codes,
 * and body content to the HTTP response.
 */
class ServerResponseMiddleware {
  /**
   * The blueprint for resolving configuration and dependencies.
   */
  blueprint;
  /**
   * Create a ServerResponseMiddleware.
   *
   * @param {blueprint} options - Options for creating the ServerResponseMiddleware.
   */
  constructor({
    blueprint
  }) {
    this.blueprint = blueprint;
  }
  /**
   * Handles the outgoing response, processes it, and invokes the next middleware in the pipeline.
   *
   * @param context - The adapter context containing the raw event, execution context, and other data.
   * @param next - The next middleware to be invoked in the pipeline.
   * @returns A promise resolving to the processed context.
   * @throws {NodeHttpAdapterError} If required components are missing in the context.
   */
  async handle(context, next) {
    const rawResponseBuilder = await next(context);
    if (context.rawEvent === undefined || context.incomingEvent === undefined || context.outgoingResponse === undefined || rawResponseBuilder?.add === undefined) {
      throw new NodeHttpAdapterError('The context is missing required components.');
    }
    rawResponseBuilder.add('headers', context.outgoingResponse.headers).add('statusCode', context.outgoingResponse.statusCode ?? 500).add('statusMessage', context.outgoingResponse.statusMessage ?? statuses.message[context.outgoingResponse.statusCode ?? 500]);
    if (!context.incomingEvent.isMethod('HEAD')) {
      if (context.outgoingResponse instanceof BinaryFileResponse) {
        const file = context.outgoingResponse.file;
        const options = this.blueprint.get('stone.http.files.download', {});
        rawResponseBuilder.add('streamFile', async () => await streamFile(context.rawEvent, context.rawResponse, file, options));
      } else {
        rawResponseBuilder.add('body', context.outgoingResponse.content).add('charset', context.outgoingResponse.charset);
      }
    }
    return rawResponseBuilder;
  }
}
/**
 * Meta Middleware for processing server responses.
 */
const MetaServerResponseMiddleware = classMiddleware(ServerResponseMiddleware);

/**
 * Middleware to dynamically set response resolver for adapter.
 *
 * @param context - The configuration context containing modules and blueprint.
 * @param next - The next pipeline function to continue processing.
 * @returns The updated blueprint or a promise resolving to it.
 *
 * @example
 * ```typescript
 * SetResponseResolverMiddleware(context, next)
 * ```
 */
const SetResponseResolverMiddleware = async (context, next) => {
  if (context.blueprint.get('stone.adapter.platform') === NODE_HTTP_PLATFORM) {
    context.blueprint.set('stone.kernel.responseResolver', options => OutgoingHttpResponse.create(options));
  }
  return await next(context);
};
/**
 * Configuration for adapter processing middleware.
 *
 * This array defines a list of middleware pipes, each with a `pipe` function and a `priority`.
 * These pipes are executed in the order of their priority values, with lower values running first.
 */
const metaAdapterConfigMiddlewares = [{
  module: SetResponseResolverMiddleware,
  priority: 6
}];

/**
 * Node HTTP adapter options.
 *
 * This object defines the configuration for the Node HTTP adapter.
 */
const nodeHttpAdapterBlueprint = {
  stone: {
    ...httpCoreBlueprint.stone,
    builder: {
      middleware: metaAdapterConfigMiddlewares
    },
    adapters: [{
      hooks: {},
      server: {},
      current: false,
      default: false,
      serverMiddleware: [],
      url: 'http://localhost:8080',
      platform: NODE_HTTP_PLATFORM,
      resolver: nodeHttpAdapterResolver,
      middleware: [MetaIncomingEventMiddleware, MetaServerResponseMiddleware],
      errorHandlers: [{
        module: NodeHttpErrorHandler,
        error: 'default',
        isClass: true
      }]
    }]
  }
};

/**
 * Welcome Event Handler Options
*/

/**
 * Welcome
*/
const welcome = ({
  welcomeService
}) => event => {
  return welcomeService.welcome(event.get('name', 'World'));
};

/**
 * App Route definitions
 */
const appRouteDefinitions = [{
  path: '/:name?',
  handler: factoryHandler(welcome)
}];

/**
 * Welcome Service Options
*/

/**
 * Interface for the Welcome Service
*/

/**
 * Welcome Service
*/
const welcomeService = ({
  logger
}) => ({
  welcome(name) {
    logger.info(`Welcome ${name}`);
    return {
      message: `Hello ${name}!`
    };
  }
});

/**
 * App Configurations
 * 
 * @param blueprint
 */
const appConfigurations = blueprint => {
  blueprint.set('stone.router.definitions', appRouteDefinitions).add('stone.services', [factoryService('welcomeService', welcomeService)]);
};

/**
 * Use the Stone builder to create, configure and run the application.
 * Export the result that could be an handler in serverless context.
 * Otherwise, it could be used as a server in a Node.js environment.
 */
const stone = await stoneApp().use(stoneBlueprint, routerBlueprint, nodeHttpAdapterBlueprint).configure(appConfigurations).set('stone.logger.level', LogLevel.INFO).run();

export { appConfigurations, appRouteDefinitions, stone, welcome, welcomeService };
